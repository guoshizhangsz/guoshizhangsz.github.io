{"pages":[{"title":"","text":"图片搜集于互联网，侵权请评论留言，马上处理😊。","link":"/albums/index.html"},{"title":"关于作者和本站","text":"很喜欢网上的一段话：“混一天和努力一天，看不出任何差别，三天看不到任何变化，七天也看不到任何距离！但是，一个月后，你会看到话题不同，三个月后，你会看到气场不同，半年后，你会看到距离不同，一年后，你会看到人生道路不同！所以请不要在吃苦的年纪选择安逸，不要假装很努力，结果不会陪你演戏！即使有人会亏待你，但是时间不会辜负你！“ 个人信息 个人简介 在读大学：井冈山大学 兴趣爱好：算法 / 中国象棋 / 电影 / 旅游 发展方向：Java开发 / 软件工程师 / 架构师 喜欢语录：天下断无易处之境遇，人间哪得空闲的光阴。 联系方式：2528910949 【QQ，邮箱同】 所获荣誉 1、四级证书 2、六级证书 3、普通话二乙证书 4、校园象棋个人冠军 5、校园象棋团体亚军 为什么搭建博客 知识输出 很多时候，我们学完东西，当时记得很清楚，并且能够灵活使用。但是过了一两个月之后，发现有些东西已经忘的差不多了。所以，建立博客的第一个原因就是把自己学的东西进行输出，有输出的学习才有价值，才会有收获。并且在输出的同时，我们也可以学习到独立思考、反省和如何将内容更好地进行表达。 写更好的文章 有的时候我们去解决一个技术问题，就进行网上搜索，但是发现网上的教程写的不是很好，甚至没有用。所以，那时我就想写一个自己的博客。我想啊，如果我自己写教程，一定要够详细，能够让大部分人都看懂。但是，技术文章由于软件更新，版本迭代，过了一定时间就会失效。所以搭建自己博客，可以对问题更好的进行修复。 目标与计划 我们都会做自己的规划，有些是短期计划，有些是长期计划。如果不写下来，我们可能不知不觉中就把他们忘记了。而拥有自己的博客，我们就会想去看一下计划是否完成了。 分享与交友 比如我们去旅游了，或者我们看来一场很好看的电影等等。我们想分享一下，当然，微信、QQ空间等各种交友网站也可以分享，甚至更好。但是，我想说，博客也能够作为一个分享的平台。至于交友，每个人的博客基本上都有友情链接，这些链接大部分都和自己志趣相投的人，与他们交朋友，自己也获得了成长。 本站信息 1、Hexo + icarus主题 2、gitalk评论 3、三栏首页，双栏布局 4、参考了 本站友链 中 2020-01-06 之前 的各位大佬的博客进行相关配置修改 更新日志 2020.01.18：改版评论为gitalk，并实现自动初始化文章 2020.01.06：使用对象存储，把图片音视频等资源放到存储桶 2020.01.05：文章和菜单栏页面两栏布局 2020.01.03：给博客配置域名 2019.12.29：加入版权和文章推荐 2019.12.25：开启文章目录功能，并实现目录滚动 2019.12.22：博客在Mac系统报错一直未解决，所以把博客迁移到了Windows系统 2019.12.19：对主题进行美化，并写了第一篇博客：从0开始搭建Hexo博客 2019.12.18：配置icarus主题 2019.12.17：使用Mac系统搭建了hexo博客 2020-上学期目标 复习完 Java 基础知识 LeetCode 刷题20个以上 Java 优化知识(JVM优化，数据库优化等等) 写一篇数据结构和算法详细的教程博客 如果过了六级，英语实用口语走起，单词量10000以上 准备面经，准备实习 复习 Spring Boot 知识 锻炼身体，身体才是革命的本钱 还有其他的内容暂时还没有想到，所以就先写到这里了，在以后的时光里，我会慢慢完善自己的博客，尽量把能够分享的东西分享出去，一起学习，一起进步。愿未来的你，能够活成自己喜欢的模样。喜欢我的博客就加个友链吧！！！","link":"/about/index.html"},{"title":"友情链接","text":"下马饮君酒，问君何所之。 君言不得意，归卧南山陲。 但去莫复问，白云无尽时。 ——— 唐•王维《送别》 申请友链 申请友链说明 1、排名不分先后，刷新后重新排列。 2、拒绝含有和色情、暴力、政治敏感的博客网站。 3、不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 4、申请请提供：站点名称、站点链接、站点描述、logo或头像【不要设置防盗链】。 5、会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 6、本站不存储友链图片，如果友链图片换了无法更新，需要更换的请留言告知。 申请友链模板 本站名称：何年の再遇见 本站描述：愿你走出半生，归来仍是少年 本站链接：https://guoshizhan.github.io 本站LOGO：https://guoshizhan.club/images/avatar.gif 加载中，稍等几秒...","link":"/friends/index.html"},{"title":"文字，记录成长的每一天","text":"我喜欢用文字去表达心情。无论心情晦涩，还是情绪低迷，或是激情难抑，都能借文字去消解矛盾，去冰释隔阂。文字的魅力，会给人更加通透、辽阔的感觉。这种美的感觉，刻骨铭心。用文字记录生活，用文字感悟人生。 书语 每个优秀的人，都有一段沉默的时光。那段时光，是付出了很多努力，却得不到结果的日子，我们把它叫做扎根。 —— 习近平 天下断无易处之境遇，人间哪得空闲的光阴。 —— 曾国藩 她那时候还太年轻，不知道所有命运赠送的礼物，早已在暗中标好了价格。她那时候还太年轻，不知道所有命运赠送的礼物，早已在暗中标好了价格。 —— 茨威格 有些事，只能一个人做。有些关，只能一个人过。有些路，只能一个人走。 —— 《目送》 & 龙应台 我走过你来时的路，懂得了你的孤独。 —— 《目送》 & 龙应台 日子啊，会让我们老去，也让我们被记住。这就是生命中，目送的意义。 —— 《目送》 & 龙应台 所谓父女母子一场，只不过意味着，你和他的缘分就是今生今世不断地在目送他的背影渐行渐远。 —— 《目送》 & 龙应台 读书用功，不是因为要跟别人比成就，而是因为，我希望将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。 —— 《目送》 & 龙应台 为天地立心，为生民立命，为往圣继绝学，为万世开太平。 —— 《横渠四句》 & 张载 仅一夜之间，我的心判若两人。她自人山人海中而来，原来只为给我一场空欢喜。你来时携风带雨，我无处可避，你走时乱了四季，我旧病难医。 —— 《人间失格》 & 太宰治 影视语录 希望是美好的，也许是人间至善，而美好的事物永不消逝。 生命可以归结为一种简单的选择，要么忙着生，要么忙着死。 —— 肖申克的救赎 生活就像一盒巧克力，你永远不知道下一块是什么味道。 你若遇上麻烦，不要逞强，你就跑，远远跑开。 你只有忘记以往的事情，才能继续前行。 —— 阿甘正传 我们听过无数的道理，却仍旧过不好这一生。 带不走的留不下，留不下的莫牵挂。 小孩子才分对错，成年人只看利弊。 你连世界都没观过，哪来的世界观？ 喜欢就会放肆，但爱就是克制。 —— 后会无期 愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问东西。 —— 无问东西 我的意中人是个盖世英雄，有一天他会踩着七色云彩来娶我，我猜中了开头，却猜不中结局。 曾经有一份真诚的爱情放在我面前，我没有珍惜，等我失去的时候我才后悔莫及，人世间最痛苦的事莫过于此。 如果上天能够给我一个再来一次的机会，我会对那个女孩子说三个字：我爱你。 如果非要在这份爱上加上一个期限，我希望是…… 一万年。 —— 大话西游 正义也许会迟到，但是永远不会缺席。 不装了，我是亿万富翁，摊牌了。 —— 西虹市首富 世界上只有一种病，那就是穷病。 —— 我不是药神 不要憎恨你的敌人，否则你会做出错误的判断。 为了记住你的微笑，我拼命地按下心中的快门 —— 美丽人生 斯人若彩虹，遇上方知有。【意思与下同】 有的人浅薄，有的人金玉其外败絮其中。有一天，你会遇到一个彩虹般绚烂的人，当你遇到这个人以后，会觉得其他人都是浮云。 —— 怦然心动 你要尽全力保护你的梦想，哪些嘲笑你的人，他们必定会失败，他们想把你变成和他们一样的人。如果你有梦想的话，就要努力去实现。 —— 当幸福来敲门 爱对了是爱情，爱错了是青春。 —— 左耳 后来的我们什么都有了，却没有了我们。 —— 后来的我们 励志正能量 这短短的一生，我们都会失去，不妨大胆一些，爱一个人，攀一座山，追一个梦。 放弃”有15画，“坚持”有16画，坚持只不过比放弃多一点。 我们之所以会觉得焦虑，无非是现在的自己和想象中的自己，很有距离。 你想进步，周围有一堆人是你的阻力；你想堕落，周围有一堆人是你的推力。 父母给的叫背景，自己打的叫江山，不要假装很努力，结果不会陪你演戏。 用勇气改变可以改变的事，用胸怀接受不能改变的事。 —— 记录于： 2019 / 12 / 27 做对的事情比把事情做对更重要。 经得起等待，盼得来花开；耐得住寂寞，守得住繁华。 有些事，做了，后悔三天；不做，后悔一辈子。 生死看淡，不服就干。 私底下的每一分的努力都会在公众面前表现出来。 你干的很辛苦，不代表你干的很有价值。 战胜自己，我们就是命运的主宰。 —— 记录于： 2020 / 01 / 15 爱情蔑言 情出自愿，事过无悔，不负遇见，不谈亏欠；生不逢时，爱不逢人，所到之处，皆是命数。 住进布达拉宫，我是雪域最大的王，流浪在拉萨街头，我是世间最美的情郎。 你见，或者不见我，我就在那里，不悲不喜；你念或者不念我，情就在那里，不来不去。 最好不相见，如此便可不相恋；最好不相知，如此便可不相思。 星河滚烫，你是人间理想；皓月清凉，你是人间曙光；人海冷漠，你是人间炽热；万世浮沉，你是人间归途；众人平庸，你是人间星光；世事无常，你是人间琳琅。 仅一夜之间，我的心判若两人。她自人山人海中而来，原来只为给我一场空欢喜。你来时携风带雨，我无处可避，你走时乱了四季，我旧病难医。 我也曾把光阴浪费，甚至莽撞到视死如归，却因为爱上了你，才开始渴望长命百岁。 听闻远方有你，动身跋涉千里，我吹过你吹过的风，这算不算相遇。我喜欢你，从一而终，认真且怂。 最近有谣言说我喜欢你，我要澄清一下，那不是谣言。为了遇见你，竟花光了我所有的运气！！！ 若相知，莫相弃；若相惜，莫相离。 相遇、相识、相爱、相知。 曲终未必人散，有缘自会重逢。 看到你的那一刻，我就想和你走完一生，可是事与愿违，不是所有的事情都是那么顺遂。 有一种悲伤叫做：当年的梦想实现了，可是当年的你却不在身旁。 九十九不都是爱，最后一步是尊严！ 花宵道中，有你伴我，无你随去。 低质量的恋爱，不如高质量的单身。 不是没你不行，只是希望有你更好。 谢谢你把余生交给我，我会牵你的手，带你去你想去的地方。 世界那么大，我怕你走丢。 陪伴是最深情的告白。 终是庄周梦了蝶，你是恩赐也是劫；终是庄周开了浑，昧着良心炖了鲲。 —— 记录于： 2020 / 01 / 15 人生问答 问 题 描 述 最 美 的 回 答 为什么农村老人常常坐在门前注视远方？ 目光所及皆是回忆，心之所想皆是过往，眼之所看皆是遗憾。 为什么要努力赚钱？ 十年前，你周围的人，会根据你父母的收入对待你；十年后，你周围的人会根据你的收入对待你的父母；以及你的孩子。这就是人性和人生！除了努力，我们别无选择！ 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 哲思金句 如果寒暄只是打个招呼就了事的话，那与猴子的叫声有什么不同呢?事实上，正确的寒暄须在短短一句话中明显地表露出你对他的关怀。 没有人可以永远无条件的陪伴着你，要知道，下雨的时候连影子都会缺席。 要走的人你留不住，装睡的人你叫不醒，不爱你的人你感动不了。 心若不动，风又奈何；你若不伤，岁月无恙。 轰轰烈烈只是梦，平平淡淡才是真。 人在情在，人走茶凉。 有多少人，从无话不谈到无话可谈；有多少人，从一朝相逢到一夕相离。 贵有恒，何必三更睡五更起；最无益，只怕一日暴十日寒。 你以为你在合群，其实，你是在浪费青春。 寝室是堕落的温床，合群是淘汰的开始。 一切的精彩都来自于主动出击。 —— 记录于： 2019 / 12 / 27","link":"/inspiration/index.html"},{"title":"","text":"❤网易云歌单❤ ❤文章单曲❤ ❤酷狗歌单❤ ❤视频 / MV❤","link":"/media/index.html"},{"title":"","text":"输入密码，查看文章。 9d44fc6f51c9aadddc8a68c063029e030d01d2a4a74cc7fcbd9211aee243032d9f19598faf98ddc0eaa6293365e4b0375ffc4bbb9df2260e43ea0c6d282aaa413a7c55400e53359e243e01b70e23610b78d9be63246e268f2ff4c2d6930133dac146152dfdd7343a0823255dede30bd5489ef430b5f474dc0aca20fb7b60298f5c3e61ca31538bb55b4b88f1556b7dac95a16fdcee2b96eaa3d630a74b8a189d0b9c7e44ab7fd79f095b4f2c4f0940a4ded687468251c0faea1e2bc498e5a80d18bc93a3b6bd5488c6dea4a5b702fa35e177637ce826f1a7de75d1876f4e8525244c885c8f852223324eaa7840a71e92c26f460e702590cf9f1d38838ce56768a6bd5eb9cebf421506182721319bed3f03e601c93c7b384ff7b83affd862952cbb22009c77c38404192b84524826027b111d3154bde3a035f8548ec68ee7b4aa410636a8038af3d4f607193329e611175899e9385ce73890c73a188600afa3f8658055db9c236d31102fce29bc474a735f1565e13727975f18576c18503c2b170365db078b6b5372cc8f82efe204f0ae4da129b9e89f447bd53cc9e1ff2da0dab3f61ce1c7960587ac28257ba2a8a48ad8540702c612cea260da86779da188dd8889f6de0e93b377b44512a6d4428982f5d571364cff234b0f95d9fdc3392155f044f2b71db89d7ba33a02b97628fd380234798f3a8d3bf46cc0dc4f773b1433c7716075eb8acc20e0dded7e15ada53acbb31c031c595d9bff00017620089c16d80c1d10514833074785efc18ec86acd5c2cd8461e5c0c1c99e6039dba4bf06d34b11c8ebee60c9445211a5b592b9f0f3ae6ba0e9405f0d29da8062ce0a5eb01f65ec468f1c5631ff7267cf5931afc233e7c2d34f7aa61e854e754c28b94cba86a529b10bd24ecc8f8fa85235d545a2b1d0ffdd3233a21507a6d27ec8eadc7cf9ddcfc968f78c4fc5a3ce39594624b26da01ee41f5394b5114075efafa1f78533da480d4b534e4f1b41310b5f3aceb32020ad5ab8105e4f709c65aec328f6e22bd4e42f7c845ce7893afcef4e9ce40055ba819ac5a1c69e08121f27c6fc98cca0032b24388532fd84e1ce0290c1d3d901ed321b9ee8233ae564e95c254888ac8d278403893576250cfe52cc4b1bb9a126f69355a557db63a837e5e99dc842eb7f662acf151cc317b9bcacb36f04bdc3285efe4f0ed271b73ceddd5453c5e4a6161e55240f3d2516e66ba94dfcae1f519e24ace7e2b7026cee427bd374bc669eb929cea426dfa69cabb3b10ded5762c471b22f87432c66663124803d303b8c3ff00782e9c3ae778e9f9b19fddd1df1a62ec26550bee8860c730263ed39df65341d1c218401de35d054a63b193415ef927ee4f8d9b685c12679aaf7440d638acc3cb18a3668503bba429b3ac4b9aa52d6f4cb12db2f632efaa1c8304a469c99010d4617120db9ab1b4e8937647d4280faaf7d4f702c85ad2a8d0c910b36aaf72defce243a4b31155464c144d2e240c39a8532a4b14a99d50480faf72005e3ec8eb194d8e2c5cccdae6b9020e9dc7014a08ad5de13c4dbfc626c35766d78c14b91f90808cc617145c9ad6b6837d92b54ee65e18139bd288c9dfda13181abd8b530a0a050be00f2949170cbb8c8542e0b9641a6f823733589c9cfdae87ad6d0105baae4c49b54d8c98eaff374a113ac2f690b6aed2352f8abb842b758088637e66a2ff93fb2f053a6286c9a6269d6538f6ad2b4e2ab5aca65211b7fa2ab43679c376355cd04cdb8dfe620c80988bce7295f36b8b98cf1180a142db55fef3f16015e4d2cc872df3fe267b2c34f3d2b0f45416272548d38e5128fbc67121df3ba747f86a3182ad2b06d1662b691d121db03a3c5f3f9e31d33631ac988a9a17d7ce7329e8b91599dd4dde06db8d1da429f16fb58c339a2daa0f9c5e40bec68c0c810e8bb09ae5111578a1ac93145d07178c5eb86d3a1c473fbcd317d0893ce9725d77acc67a04ba9df6c1420dfe29672b8ae906fccfc2f939d1e7038ba911edd5236564c3fff71eddf92bddf950fd3f08d723dbcf9c3586dda610b22077c93da451cfc468145905635753f7b67561b0bf24df2fcecbd48e86a883989d87deac4a92cd2f19547db9896c73f0f61f896790f2c6117bb7e21061b09ce9217ff41b347ff6088060e5aa5fbb0c7548d31798bb8cea093fb71c2d196a857942a9243d65ce2605e644e8251a8e1c480897e692d2fd62c994e640e5a43ac9232f56d74bbd4e704a602d9404abb8e06aff6041fc1235702a7be0b86e3617a2374e8dec36d92d7471ed47530cc1f1257ec04fb5a5f4de4c99d0a5a1949e0efe8923f532e2c5417352d94312b56110c2c3fe3fb30dd8df717ffec3a6fa45238e201883f1ebc0e546149d95bf2b57ab2334da5ba4f890bdfb18961ffebc5836980c72ec9aab8956810d40f6bb955bfc9230295603947d38d192b336e0c247eb4946ea313c511e5501261d15dfc7d1c1f3e1e0a0c42c4d4c6126c788df2f51ca84306262d4726a6b313cf0aae56897e0dab5d19fa99995ca471730eace9511bd9fb20b88a1eacc7423ae4dfafe88c390bb0c2922604785d9105d50d6fa7bddd6e797ffeeabd5f891659a2ca8bdb8110ec1aadd33fbf406f80ec480133edf3b0086621c3480ebbfabd546287980ee42c53bc268a38cecde93ffd0ea992e2b03db0a51a56ea9d87270f02f5a5f7ddd5c61e86daebf3b6bb1069093d5bcdb8edebe73688b88f849c33cd45e0cb977322451cc14b79db8e880ea3384f8c07b58c9854f39b33026b7178acf6721ae525c2f25c11273d4efddeb372af74493045b89535d4a2de566f5dc184eb820a8059c6a78972cbf8b6f7c7e6260f0a77069ab2d6d34b12f4268864f566611cd8184699815b5d3be419b390ef8c6b70d903236cd711d3710db417b3ca16cc53963dd8e1e2263821477ada0b59aeedaff5a14e9f3e5d71b89ad200715100e47ef89254cfe9287e2828b19d67f7e6a3833c54ec6888912feab10c5c89c4143d60be304cfef0a0ce89e3009f9875695da7791f7c5ca3b5569f90b0a7e47e938df5fc403c4f018305047f5cf74975d5fd9663a118e596ab0c9a57155151e157511ec1e1761fee34a4bd9d28d06221a7c961ab8348622365072135527dd1b953714cf57720f4fb90896a4fbc377beb58fc30329d3892e6fadd7a810863712a887ad02d683b5c28879336a28caacb99432ce5bc924076bf026b1ee25368186173a42968eb647803c35b818f4b7283bbed2fc5541602e3dfb576b6d562ad84876ec62c6eb5684a495fe7000de48773e0f3c188f6578566111a96e2613e81142e8fc7f84738ef26c06c900722ada54734bb4efc230ed5a62d390e7a769ec1760bdc7de7486f3f94c133f18f77e0bb3fb878fbebe9c56d6c1ec4baaa4e85d6e7750d7141458a8626101135a90e109eb40dc8557f7025075ed5902609b65029e2bdc6e124f68fdcfbb54c77852df719ffd2c99180df2d89b667f15b7a242b71e8fcf7c95296160f65611b7780e22d21196b1eda8ac45c1e22e0062f1005a9a0fc75ee2060b7dc281ff8654853f878d286076e5fbb0311bfef4f9c7baa8aeb20c6016eca5eb833123af1b45c880c921d4e0df4bc6440e5b7933230306bb375cf08abc2c29b66ce0cf719a2397114ba57e4fb7219e12cd08e1654f2b4c478b928c75c3d3d2263183fb19fa9520e9df8ef08f695c062641157902c7f4a6e7be8bfe2178ef681e59c27d32c74181befb4e25a3cbf990b09255cc5ac039eaf9c4b5af623c8c034b5898f1af38733f2763faac1c910886f3a6e7760b1816c1be76a0d0ed78a2f70b8c8c91b0d0e0b35cd8b0f2bc293e45b92e5697c99f7bbffc56c0e0453439dc6556ba6f1504f5090b3f7d81624bd65f2cbaba29de6686d7c32337d5dd0707ebf08b240136a685e8626eeea518128571777d244f920fd02f6c24fb23e5b2c6fbfe7518b99e9d30d34bda9bdc9cd7e8c6108e5e1ac5200828afffc5bd0a813b37d347f31fb6451db2472138ff60d65d69726537efa9b1ade6464546648b0b64e2e61173278f3bddeca77c766352752961a404c3f3eb15abf8642f8594eaf4ec6e08ed3d8ebe63ebbdcb4dba5a907a52f435ad718f40ad559b8cf7d005bca3b88ed7008633a5862deca5c46f2c1d6b74fca25f47d87ad0f2d4224c087efbab4c6d8081e312a96fbb0328f1dca24bb10d234cc1bb6f88db5886038bc2003234551ec9af7ae31fcc9c37e3beb71a6ddaa99f797fcefa64f4fc8b952114612c107c681af63d5d871c720081a0e4cfa862971d515eeb58d6a864c2042497de6291dd98b11337b89a501fbbc3a7bfe93bb0ab914b6b27841e6a952317c68067e1d1afb6ae35af99357b24c75b923a7d309593e3dee3db822fc0529cfb1cd9def1df69764bca83c409aa2cb604bf19998498d9f70e8fa5a092da15bd232d8b28267f60d2f695cb8598e291753b11ad57fb1a3b07d799eb9da3185460f487ae861f799aec6b5b7e55c70dd2f126f7e7463d14106dd824fa09fa37252e673fcce808a5aa3e7ad3384849a37b5f96ab5ef75b7420473a82aab9e4d5d4d4aa75080b3606a257e2b0025c5ccf20c451d76b7983e767e5447427b8f08f9a172cf0acc7af0f9324f98580e805f7f7cd62ba53ac99acd23c74620876391d42ca698941c2431d786bd7b5f58d00e7a7ec3dd4e841929455c9d94733a41d427b6bcf65a988cefc4bf00b981acdee473a51c5e7240006728c0f186167df6b9680b74edb3de032caafa05de9d3df867b9ab4d88261979464296524e422991c5e5edc6024f8dd551f761a60a67a543c545554fbe936c0ca5c8a266c6ce6792b97a6e0a5cf7a544034611d8954dd14e32b333a5a14119a7b1543907ce7c08e5dda1aa312af26964ff9c83b1d09d1cdbb0b9d2f9219e75a7b6ecba5aff68d21d875f149c946c8164181a4d3941db95eee7d79abf6b3f17d99af0de67bc8ee857800d86b6ce4ba07ab7ef96035072a987ad833808b6f528b014a67c36b5ab624f30dcb087061894b4679f38dd3c9a52d0ae0ae68bc18b513f150f4439f0f1f2d390e941212cfe9ed911098b2481814d8ebd898ceffa4b0991b3da3d8ab201e58a030b307abb567b5057303b9d1c0831b4f8c4e6babd7f59508e4dbbf600c86e56f34624dc8da7714aa52be67155cbbe87297ffab46e5196646c3f79240a2ab1deab61798469983dc3660ba86a569b1994fe0bccb1a18bf93c4a52ada5ac6df6e962d8d33bda8664b3ada4b7f2e3a2860edb61e3b4332857fed9c005bc90c06095a20f38305c0084eabee54722acfa57c842837a078359913db7c8be54495c8acf1a05e18d5977100917aa1fd515ad257a4f48af7ad880c611f01ca968435fb7c045bd797792eca0106bde1a1b2b1cb859efc4b4731054d7ee5149a1b3e3548edc63d35a7800fe1aa5e6223a45093226219b756bc0b548da5a4f4a895e09cb65da379b37bf54d46c0cbe96e3a9f795f3b33007e726638cd9e83b23ec35d44694b5be6e257fc8a974c558b9bd825c585173c7196fbdf78e79ec4bc963e35a2d4d6578778994d0e52077c8cca12801730de36e60d896fcf353b9c43cea914fa8deb3bba5ba122481b2a5ce64d017cfd38f4dc4a05bcffb7858dde707e597a26b81929153577460941bb2bd4fce63f87d5ee5a8efb338b6bb3f62676c416cefc27fd828a2d60e2bbdfb0d6b9ccb13b60bbcc478eb8d405891604373f8fc575f96f130d5c76fac9bdb7304bcab8c7f073e3dc7c20d1d44625915cbbc0f1fc8d40c48e85ecf8dba70ca841380dbffd13d6cd90e7189e8f68610ed7a31e75d0fbe73d90c5f5ad5313757001f8830bc29dd9ceb527ca3db7cde5182fc1eaabe3079903078efc6daac90224ec480d5e9f8aca28f0e5b014c25a646507188ff4ec94ab6cd2f118e3dbcd702bb90f7f3e7ed775ba2ab0f00d4585453c6363c3a9660663f87a991159d766fece79562c601d0b1a2384354b3ee9294b65852c4f73629984f79ec6fc72272e9edc4b6436ed4db39ce5cadddc0cc3d821113a4ec64ae6407da175c1760b287f0542410b1216cd314ffa66079369ef395dec86e0d120d854c08a6b1874a3509284908d8e3d91f9dbea513a265dbfacc9a72e6a9b7510025eac6baa47753c2bce90078dd490d2d2b22e25250e52ab564afa1ab88ca6149d5c9d8d7c303142f6565b98eea166efcb4a51903813e238906e1b8595da76f720cb6cc15a592df0557aef97f4abe04052f2980ee15cf4d5d7752a348ad32d65fb40f60b3bb614e1995342c330ea33e8b0dad51317617c6245daaec0f5baee65ea635d8a60e379eceb9c665a2ba0eef2ca9ef2716523c5f6f620c517bafd970ae8656498b18cb70ac7af00a8356979621e95df0a116b97eb01758332f4acafaf716dbbe7671c93cfcd004ae7d575a44a43f9beacbbed64d5d8bd53a3eaf2fcd2264933cae9c01e7053dec21faba69fa2a1869b78ed7e78ce8f4eabb116bbbebea443c51d29cc6d18ba50df2a2f30c38064ef60490eb41cc34fc25959f237351507135b1df818a162fd285c58baa9ea2b4a1fd3643092c1636f6a62438dd2832169c3755739e6cb37df3fbaba15aa46eef156c8312b6da91cc3847ae8ea28c0a99aa493ae2f91d1e584c8bd5ebf22a3eddc7ede240fd2d752665bec9bdfcb2e9992acd61261a59240b1022a9a5faa80426d37df6540edf08ab949fa19b1ba0e1a60bccd2753ad13326a8e7a2b3d5da2546510a40cfcf0c568ce9413f5ab945ee028427e78b82fc505fd04fb0715f5b42c9689eff1b231a70bc99865072290622a233623e6b4efc9ed96277157380519e5f8f5de26abedfdd85034d5696996168505dab0c7205ed40dd55590c6ceb1750f400344ab70f78710a2ddbd13ea24062d7623cbc6d1c9103fc2d0c418671c19a414d902855ef7ec87ccb8020ac1ffd9d981253ec00ce9d59b8ee04504f8893c880a9762e53931b5bbdc065efdf7b7734e5f308d17ee887bbf65b16d02e51162281e4aa84d175ca1108f3750964a0370ead43e9f7e7ca8819e0f2500f8db7b5a39965c6c52d1b84119facc6baaf6aed85e2bcb896052be9bca59191517562cffcf66784bce410fc6c262d33d33582a7832b262bc1a1211416588ba4f30a1959df87c9946e3f8ea6d2f1f5089305ac17afe5d2f080fe3a899a3b895f5dce5cddcca1f7e987b9ff012e823cfc297bc5a2e4d7a893442f60aa6e47241597e1a082a236428995739a7f750fcb1f06da9cc65e3dc5e5f0aa97a96d65343da1290a76921707e5e72c7217556bf9d26ab6c926201b52e0e34c305271e9387ceca7eb0e85cee7a56955b28ab4b62fa32db8993a44047ab1f96b9bc91d3a512921b5246a8a21aa12adc22667bc4d9e033a06f682952088fd45e308b66e1fa8e3ac3d8b566018a4b13659365fd81257ca762ceb93cddc8f84687b957893767ac265c78f82cadc2d0fbe045c0c469dea30560a6b7d9f57d8d65655be9b95e75c05ea0e0954a275bc9c801971edbbd277d5c9067484715467f352b5c99dfc97afd1be5f26d5109164e3d81bbb537b33f8e188c550bd26db853935860e3f73407b0a20a911238b479375a38428c206f5b77f828f829651e8a365d077198229ea63dd3edca27507f2f77db235405024754296d3e89ae8111dd358ed7dbc6cf31e6d8512bd7d192bbab1b18dac3c300b9e64204a31d6d0d3e618a08b58c5bbbf77a17ef19cd0466563f30e9cda3a5866e6dc62e1adb7d23403f5cb6979efa1b46fa941a2b9ff7a84efa69a6873c41e8a33cb3a5bcc85dc8a148e13f44d140eaeda2f5c939584ea4ebf829c27deee71bc16913c00fbfa32338cfeffc354a1ed6e4ca3f81f677b7d111ead69e10c08ad902aa4d460702f59763a4b49ffbdfa660a3045675df6b66ac5de5af5b8d84341db8c3d589abc3bd081ec34a92bc12bd61e7bdef1545c693aa04ad605814f2ff4c7900730118b0bd265afab79b8d1cfd1391030c73be88a4038dd9e4497348e055c83806c1bb455724911b7512fdebd80bd1462735772967c425e14e8529e509f56d2e1f38a2dba13cc4d621ce1ab49fdf984456df81af28b3e98b38eb4bc4b80facb8e2b148ac0fc90219cdd02bef3cca1164ddd897ce27a5265bc24f7ba1dc8b822841f4e5c191af91474c59619cc1b92645bf44e814ce30840f6f991df556af909961725d6f4a97b9ec5029889326d9810b0c584772421770e704726544b98c804ec8ab9bfccc852932183a4b5f4bc75cae989a648a87239fc8fec6319d6d393e30319adcb36f55e1f35b19dbcd5803e16e25f44fdbd27b203ee2a8484d6017c9d94eb9833434456990ca8a8a24cc731792f309425d0023f95ff627b3c043800155e2c2ff2d7d46d6682ee12270350c704a99c6f403e25978bba4b4b8e4cd67a126076a4e4dadd78355c49a737077103866c2033a1b8fd07729214635629fd2e46578fb810c85536954d61f44885377c9a2b3133a7dcec6d16795f071f2fb1e8964f3effd48f1a3d1110cf55d262a7b2448b21244bfe4ddb10327f3ddfdfadc8a236d58fcc8a534b65a20264b4a9dd92beb133cbdb6acea7ad88a2abd021d03bd781a30a797d584b1389438c80e0669737ea88b4bfe01362fe42c5797ac5c16904e8f1e84636c659884c87e6f285d21de0d4f4b9f35d878abc7c1d7925c9d78d872376849a21809f4b71190017922222ff72d1b8ea8be3c207230dbdb3be6299fae9c0cd5ee2384a4bd1a2361c80b00850be91a71b5fffe778e6e507c0f00157ed5ed4fcc5d02ac2e1b67ccd42f893ea3f0a26b0a77ead0bb7e73630fb6c2c85d94605266d76dedea1df44ebfa53452927e5039084c46c06f296d75293e24032fa2de70dd469b24c01f2868945c101ded8db292d9a4a020bb22a2403668c5c995b37d286dd07183edf10fc50a1d43e36d86840282b65ebcad9014478d354e8745774f1c47923dc1c2b8a718471c3c8fbd4f3cb210d45030326d19df9de16bc5e886d5c518d9c5592bd498e4b642aa19e2f10b27b83140d6e524f48de71f9c91bcc919138cd374d7f59320b5bfc4cf2e16a4d3350f579a833bb2d1fcde4bf32162aa0dfde436c5a6a7473354697c9d814c58e60afbaed6c39de8cc5e3d07722f83e1ed6c6183734bd823944516e581aff005ede6247b732e0220bd77b293a0e713ec1698c63a96aa5443c367447e72dbcf2fb2c4b92117a3fc9bb64f124fc333eb45a7d243b89d31d06743cf6d64ba3162e8c88d4441c666757ddde2a3df4c35f514587a5f718ee5c67de3b0a78410d30193e9fa21840d7d35390354a79d0c4b935d599338ed9f1cf48c2a5fbd61164276f9918a057539f84add0652c5ab8762f3e2fe862b59d626f13d9427ce62e3885956f72cf8692771d436b8b66ad7204378961a5279b7ef73409e23b38df0bae6f8f963f23bd9f1bc639a9e65644d58d51b92eb42ca7ff0d711859e62643e59f4a62b77eac55d78e43156c4ede670296be3f45a06dbb0d20aaa826b0d17f3e05f068bf9c57bf1097b238babe1878d173bc73e8e3e736f93d30fadcd6892751e4d5aec2768fecdf6d572c21ea58ceddebc05acb4fad57f5069f902e569f487510eb43779e5a118bd2a9613145f6d252523af58e29550d22d880ad3cb91ead818aa77dd121a62e13cb4d933ddac464aa26ee1296a616968cb4e9537fe6240f40fdcc389628bb9cd3aa9cbf7f96c23834220a0336799ec14a2ab6fab8ffd730ffebaf35d6c5b52d8b7b2ede13017d2557e8c212a0a21a1ffda10a107fb67963b75967ae3161b2a64a6b21b23fa50d53fbfb2c5e361e783f6829142041020beea5130de01c847cc4063d2c5a551e2dce5125cbfd324e6db9ab84c058aeafa8a906118f7d12c206fc1c95f0330eb7a87727b4357e673a4fda030aae8a6eee585166ec2a38858c51dfdae56c7bbd424db695f4bc5a3c379f7f4efc337c39ae061fc8d6c371c1c54f5293964890e5a18485ac273df0643c0a1493fbc8f88920fe8ac8a0fe75715905a0f08b585376c6b92017aaf444669bdd4046cc58f9d0d77ea30d45ddd6a0d05bc17909cc26d5c92c4a06b6b9f219da362f62b14c7333d32e3c70407ceadd185a93a09402c3292cdf9e1e08c423c0898009eadaae78e76b906a1304d510411dfb2d7bea62047d4b193068558b624fe4e485c8c13fb76e87b6aef3a2c1de266df9347d8865da3369f3a0a2f7919f7e6435775d2cd4594ae3f7b9c9c980ed182bf7c0fac1113d6ab4bd6bc34e169b19b1264ab6064ded4dc6caa26ce17e8674e8cbd8fe4f48e575ae2641736e80fc8b5c1d8984e8c864a7980ba9e90a5d4ce0ba00afca8469163a31766cb487465a90966588e5e8a30271d76ab2dc4ed2fb2c43fa98588229752a51ca59e5537931c3127a3d30112d01437239df567b1725a146a535aec968a3d895288b16a7064ef405169e8f831d595352ec6c3a67542c6faaeec3c5ada0003b301024c69dd4d7c0484cb23d980b9ca7f75ff2d83c7121aa88bb756d7c8d2ef3a9c2cf3ee0a15f03df8956deec27519590a704d280e13fa14c3568413404b57a1ef13c3d5b2af65056348f1ff4d1e3b8f76736038e7b014a89843477dbb350ad824248b9195e0273a26d7439de87b0adc33b58f4f22fd3073a8a4ad676a93278463fd483f66fca2166b589754da866141457f435098337fe05f6b18422e1a72b6f54dfd38a2c8bb16b6978d90fa706e57eef1e011d95911f481f1930ed422f967ce6890f74adac7ca848a6a0df95247e7060d40aa87a9c6c25e6f1827ac95ea11332a0a4cf748f1ee49528c59ca6146c088309bd6e22ebd787a1aec10f3609d565e9318f83c4914b7c9895622224f31f7b7555279300b5203f35e8a24c405ced02fddfefa9cd3417d1ea64efe92b83948d04dda62386ece0c261a3edd69f86e3bb6e99e972b32a1c3b61a8e291a95e9cdc7da5536be741c8b9a22d110fe4792d9c5358e5e8eff08ceb8502b4b37a72d2eadacf560ab44a75840cb5dc9a471dbb689c1e7da68c57f10e7358fd5000ef82ddd6d497a006b4aea95c5f6449071611abac030d2bc2909b166f0b136d7ce3b8ba381f8e1af0c0a4884cb704c8c9765792d4c9c4951fa7658381a60ac99995a6af4bce810f764e851c7f20ff07585b0f964fc38981071849482efdd0a7a9b1516f84629ecdb6f0982fa9bc8a422f94723be19a8e5e7fba0242f27855a05761e347ed409f92b488252784a9522e2bf4899c836778e557e2720c7d494c94533fed9dbfe86e12f3caae5f7ed89045fd9daffdec33ac2a07ea97dc6685123331cd4719916f05f94bedfd8750da3de9f5312b6a14f5dc241e8134c826bb397423505744964365fc9407a3697ee6c82b50c5c06945db15e03a0574b305f211a42e899c91b4d0dff3aba5d425b852aa59c26f02645034a15d6a1d2a4689c55b7aa7cc2928d92eb06bf9f9b59b952008ab313e169603b1ae05d4647b5522f5f9e16c76171f50d55c04334f6e87a5f188bdb651d9475d25b576404694e03b8df93e3107a","link":"/secret/index.html"}],"posts":[{"title":"AJAX 和 JSON 知识","text":"内容概要： AJAX 知识 JSON 知识 AJAX 知识AJAX 简介AJAX 【Asynchronous JavaScript and XML】 翻译过来是 异步的 JavaScript 和 XML ，它不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是 在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容 。 AJAX 不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行 AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新【传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面】。 有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网 等等。 AJAX 实例这是一段前端代码，用于 模拟 AJAX ，就是不通过刷新页面就可以得到数据 。代码如下： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;AJAX 实例&lt;/title&gt; &lt;/head&gt; &lt;script type=\"text/javascript\"&gt; function loadPage() { var URL = document.getElementById('url').value; document.getElementById('iframePosition').src = URL; } &lt;/script&gt; &lt;body&gt; &lt;div&gt; &lt;h3&gt;请输入要加载的网址：&lt;/h3&gt; &lt;p&gt; &lt;input type=\"text\" placeholder=\"https://www.baidu.com\" value=\"\" id=\"url\" /&gt; &lt;input type=\"button\" value=\"submit\" id=\"url\" onclick=\"loadPage()\" /&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;加载页面的位置：&lt;/h3&gt; &lt;iframe style=\"width:100%;height: 500px;\" id=\"iframePosition\"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 最终效果如下图： AJAX 和 Java 交互这部分内容就不再写了，具体可参考以下教程。搜索关键词：【Ajax java】： 菜鸟教程之AJAXJava Web 之 AJAX JSON 知识JSON 简介CSDN教程之JSON菜鸟教程之JSON JSON 的数据格式一览： 123456789101112{ \"date\": \"2019.12.27\", \"src\": \"https://guoshizhan.github.io/avatar.gif\", \"name\": \"何年の再遇见\", \"desc\": \"愿你走出半生，归来仍是少年\", \"url\": \"https://guoshizhan.github.io\", \"address\": { \"street\": \"学苑路\", \"city\": \"吉安\" }, \"hobby\": [sleep, read, music]}","link":"/Ajax-Json.html"},{"title":"运维：Docker 容器和 Jenkins 持续集成","text":"Docker 知识 快捷导航： Docker 官网： http://www.docker.comDocker 文档： https://docs.docker.com/engine/install/Docker 中文网： https://www.docker.org.cn/page/resources.htmlDocker Hub 官网： https://hub.docker.com/ Docker 简介有没有想过一个 问题： 我写的代码在我的机子上可以运行，到了你的机子上却不行？ 这其中的原因就是环境问题。所以在工作中，你写好的代码给了运维和测试人员，发现你写的有 bug ，然后你们就开始了撕逼……（不就是个环境问题，嚷嚷啥） 那么此时，我们是不是应该使用一种技术，来打破这种环境的限制呢？那么，它来了，它就是 Docker 容器化技术！！！ 推荐阅读（转载）: Docker 入门教程 什么是虚拟化​在计算机中，虚拟化（Virtualization） 是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。 这些资源的新虚拟部份是不受现有资源的架设方式、地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。 ​在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件， 从而最大化的利用物理硬件和对资源充分利用。虚拟化技术种类很多，例如： 软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机 等等。 什么是 Docker​Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。 它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议， 项目代码在 GitHub 上进行维护。 ​Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。 Redhat 已经在其 RHEL6.5 中集中支持 Docker ；Google 也在其 PaaS 产品中广泛应用。Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。 用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 那我们为什么要选择 Docker 呢？其 优势 如下： 1234567891011121314++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 1、上手快+ ​用户只需要几分钟，就可以把自己的程序 “Docker 化”。Docker 依赖于 “写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，+ 可以说达到 “随心所致，代码即改” 的境界。随后，就可以创建容器来运行应用程序了。大多数 Docker 容器只需要不到 1 秒中即可启动。+ 由于去除了管理程序的开销，Docker 容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。+++ 2、职责的逻辑分类+ 使用 Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。+ Docker 设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。+ 从而降低那种 “开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）” 。+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 12345678910111213++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 3、快速高效的开发生命周期+ Docker 的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。+ （通俗一点说，Docker 就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。）+++ 4、鼓励使用面向服务的架构+ Docker 还鼓励面向服务的体系结构和微服务架构。Docker 推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型。+ 在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单。+ 同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序）+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 容器与虚拟机比较​下面的图片比较了 Docker 和传统虚拟化方式的不同之处 ，由此可见， Docker 容器 是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统；而传统虚拟化方式则是在硬件层面实现。 如下图所示： 与传统的虚拟机相比，Docker 优势 体现为 启动速度快、占用体积小 。 Docker 组件服务器和客户端​Docker 是一个客户端-服务器（C/S）架构程序。Docker 客户端 只需要向 Docker 服务器或者守护进程 发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker 提供了一个命令行工具以及一整套RESTful API，你可以在同一台宿主机上运行 Docker 守护进程和客户端，也可以从本地的 Docker 客户端连接到运行在另一台宿主机上的远程 Docker 守护进程。 镜像与容器镜像 是构建 Docker 的基石，用户基于镜像来运行自己的容器。镜像 也是 Docker 生命周期中的 “构建” 部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。 例如： 123456789++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 1、添加一个文件+ 2、执行一个命令+ 3、打开一个窗口+++ 也可以将镜像当作容器的 “源代码” 。镜像体积很小，非常“便携”，易于分享、存储和更新。+++ 镜像和容器的关系： 镜像就好比我们的类，容器就是对象，一个镜像可以创建多个容器。+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ Docker 可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。 容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是 Docker 生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。所以 Docker 容器就是： 1234567++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 1、一个镜像格式+ 2、一些列标准操作+ 3、一个执行环境+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ Docker 借鉴了标准集装箱的概念。 标准集装箱将货物运往世界各地，Docker 将这个模型运用到自己的设计中。唯一不同的是：集装箱运输货物，而 Docker 运输软件。 和集装箱一样，Docker 在执行上述操作时，并不关心容器中到底装了什么， 它不管是 web 服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。Docker 也不关心你要把容器运到何方， 我们可以在自己的笔记本中构建容器，上传到 Registry ，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker 容器方便替换，可以叠加，易于分发，并且尽量通用。 注册中心（Registry）Docker 用 Registry 来保存用户构建的镜像。Registry 分为公共和私有两种。 Docker 公司运营公共的 Registry 叫做 Docker Hub 。用户可以在 Docker Hub 注册账号，分享并保存自己的镜像【这里说明一下：在 Docker Hub 下载镜像巨慢，可以自己构建私有的 Registry】。Docker Hub 官方网站： https://hub.docker.com/ Docker 的安装与启动安装 DockerDocker 官方建议 在 Ubuntu 中安装，因为 Docker 是基于 Ubuntu 发布的，而且一般 Docker 出现的问题 Ubuntu 是最先更新或者打补丁的。 在很多版本的 CentOS 中是不支持更新最新的一些补丁包的。 由于我的环境使用的是 CentOS ，因此这里我将 Docker 安装到 CentOS 上。 注意啦： 这里建议安装在 CentOS7.x 以上的版本，在 CentOS6.x 的版本中，安装前需要安装其他很多的环境而且 Docker 很多补丁不支持更新。 接下来我们使用如下命令安装 Docker 。如果你是 root 用户，可以把 sudo 去掉。 相关命令如下： 123456789101112131415161718192021222324252627# 1、移除 Docker 旧版本。推荐按照官网教程安装：https://docs.docker.com/engine/install/centos/sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine# 2、将 yum 包更新到最新。这个过程需要点时间，我的花了 10 多分钟sudo yum update# 3、安装需要的软件包 yum-utilssudo yum install -y yum-utils# 4、设置 yum 源为阿里云sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 5、安装 Docker 。docker-ce 是免费的，所示安装它。可以加上 -y ，中途就不用我们自己点击了sudo yum install docker-ce docker-ce-cli containerd.io# 6、安装后查看 Docker 版本docker -vdocker version 如果一切顺利，则可看到如下结果【如果出错，一定从第一步开始重新安装】： 设置 ustc 的镜像ustc 是老牌的 linux 镜像服务提供者了， 还在遥远的 ubuntu 5.04 版本的时候就在用， ustc 的 docker 镜像加速器速度很快。 ustc docker mirror 的优势之一就是不需要注册，是真正的公共服务。相关链接： Docker 镜像使用帮助 那么我们如何来配置 ustc 镜像呢？ 步骤如下： 123456789101112+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 1、编辑 daemon.json 文件，如果没有这个文件，那就创建： touch /etc/docker/daemon.json+ vi /etc/docker/daemon.json+++ 2、在该文件中输入如下内容+ {+ \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn\"]+ }++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 启动与停止 Docker以下是 Docker 启动与停止的相关命令： 123456789101112# Docker 的启动与停止的相关命令systemctl start docker # 1、启动 Docker 命令systemctl stop docker # 2、停止 Docker 命令systemctl restart docker # 3、重启 Docker 命令systemctl status docker # 4、查看 Docker 状态systemctl enable docker # 5、设置开机启动docker version # 6、查看 Docker 版本信息docker info # 7、查看 Docker 概要信息【Docker 启动了才有用】docker --help # 8、查看 Docker 帮助文档【Docker 启动了才有用】# Docker 的启动与停止的相关命令 Docker 的部分命令截图如下： 镜像相关命令查看镜像查看镜像的相关命令以及介绍如下： 12345678# 查看镜像的命令。这些镜像都是存储在 Docker 宿主机的 /var/lib/docker 目录下docker images# REPOSITORY： 镜像名称# TAG： 镜像标签# IMAGE ID： 镜像 ID ，这个是唯一的，后面的命令中常用到# CREATED： 镜像的创建日期（不是获取该镜像的日期）# SIZE： 镜像大小 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索： 12345678# 搜索镜像的命令docker search 镜像名称# NAME： 镜像名称# DESCRIPTION： 镜像描述# STARS： 用户评价【收藏】，反应一个镜像的受欢迎程度# OFFICIAL： 是否官方# AUTOMATED： 自动构建，表示该镜像由 Docker Hub 自动构建流程创建的 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地，命令如下： 12345# 拉取镜像的命令docker pull 镜像名称# 例如，我要下载 centos7 镜像。7 代表 TAG，如果是 latest ，那么可以省略docker pull centos:7 删除镜像删除镜像的相关命令以及介绍如下： 12345# 按镜像-ID【也可以是镜像的名字】 删除镜像docker rmi 镜像-ID# 删除所有镜像docker rmi `docker images -q` 容器相关命令创建与启动容器接下来，我们介绍容器的创建和启动相关的命令。 文字版介绍如下： 12345678910111213#########################################################################################################docker run # 创建容器命令# 创建容器常用的参数说明-i： # 表示运行容器-t： # 表示容器启动后会进入其命令行。加入这两个参数后，容器创建后就进入到了容器内部。--name： # 为创建的容器命名。（这里要注意：容器的名字是唯一的，如果容器名字相同会报错）-d： # 加上这个参数则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加 -i -t 两个参数，创建后就会自动进去容器）。-p： # 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个 -p 做多个端口映射-v： # 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个 -v 做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。######################################################################################################### 12345678910111213141516########################################################################################################## 交互式方式创建容器。这时我们通过开启另外一个窗口（当前窗口已进入到容器），# 然后使用 docker ps 命令查看，发现可以看到启动的容器，状态为启动状态 docker run -it --name=容器名称 镜像名称:标签 /bin/bash# 退出当前容器exit# 守护式方式创建容器（容器名称是唯一的）docker run -di --name=容器名称 镜像名称:标签# 登录守护式容器方式（容器名称是唯一的）docker exec -it 容器名称 (或者容器ID) /bin/bash######################################################################################################### 上述命令的综合使用如下图： 查看容器查看容器的相关命令以及截图如下： 12345678#########################################################################################################docker ps # 1、查看正在运行的容器docker ps –a # 2、查看所有容器docker ps –l # 3、查看最后一次运行的容器docker ps -f status=exited # 4、查看停止的容器######################################################################################################### 停止与启动容器停止与启动容器相关命令如下： 123456#########################################################################################################docker stop 容器名称（或者容器ID） # 停止容器docker start 容器名称（或者容器ID） # 启动容器######################################################################################################### 文件拷贝文件拷贝相关命令如下： 12345678910111213########################################################################################################## 1、如果我们需要将文件拷贝到容器内，我们可以使用 cp 命令docker cp 需要拷贝的文件或目录 容器名称:容器目录# 2、我们也可以将文件从容器内拷贝出来（注意：拷贝完成之后，文件所在目录为宿主系统的当前位置）docker cp 容器名称:容器目录 需要拷贝的文件或目录# 3、将文件从容器内拷贝出来（我们指定拷贝文件以及文件放置位置）docker cp 容器名称:容器目录/需要拷贝的文件或目录 拷贝后的文件目录docker cp myCentos2:/usr/local/Hello.java /root/Java # 表示把容器中的 Hello.java 拷贝到宿主机的 /root/Java 目录下######################################################################################################### 目录挂载目录挂载： 我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。 具体详情介绍以及操作截图如下： 123456789########################################################################################################## 创建容器，添加 -v 参数。 后边为：宿主机目录:容器目录docker run -di --name=myCentos3 -v /usr/local:/usr/local centos# 如果你共享的是多级的目录，可能会出现权限不足的提示。这是因为 CentOS7 中的安全模块 selinux 把权限禁掉了，# 我们需要添加参数 --privileged=true 来解决挂载的目录没有权限的问题######################################################################################################### 目录挂载 相关操作截图如下： 查看容器 IP 地址查看容器 相关命令和截图如下： 123456789########################################################################################################## 查看容器中运行的各种数据docker inspect 容器名称（容器ID） # 查看容器的 IP 地址docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称（容器ID）######################################################################################################### 删除容器删除指定的容器 相关命令和截图如下： 1234567########################################################################################################## 删除指定的容器docker rm 容器名称（容器ID）docker rm myCentos3 # 删除名字为 myCentos3 的容器，如果容器开启了，则无法删除######################################################################################################### 应用部署MySQL 部署MySQL 部署 的相关步骤以及截图如下： 123456789101112########################################################################################################## 1、拉取 MySQL 镜像docker pull centos/mysql-57-centos7# 2、创建 MySQL 容器。-p 代表端口映射，格式为：宿主机映射端口:容器运行端口。# -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是 root 用户的登陆密码docker run -di --name=Guo_mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql# 3、远程登录 MySQL 。即连接宿主机的 IP ,指定端口为 3306 ######################################################################################################### 这里需要注意一下： 当我们进行远程数据库连接时，我们可能会遇到如下问题【可能报的错误】 authentication protocol requested by server; consider upgrading MySQL。 那么有效的解决方案如下： 1234567891011121314151617########################################################################################################## 1、先进入到 docker 容器里面。命令： docker exec -it 容器名称 (或者容器ID) /bin/bashdocker exec -it Guo_mysql /bin/bash# 2、登陆 MySQL 数据库，密码是刚刚指定的 123456mysql -uroot -p123456# 3、执行以下两条命令ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456'; # 注意： 123456 是你自己的 MySQL 密码ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456'; # 注意： 123456 是你自己的 MySQL 密码# 4、退出 MySQL 和容器即可进行远程连接了exitexit######################################################################################################### Tomcat 部署Tomcat 部署 的相关步骤以及截图如下： 1234567891011########################################################################################################## 1、拉取 Tomcat 镜像docker pull tomcat# 2、创建 Tomcat 容器docker run -di --name=myTomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat# 3、浏览器登陆即可访问我们的页面。（我这里 war 包出来问题，所以页面没出来，呜呜呜~~~）######################################################################################################### Nginx 部署Nginx 部署 的相关步骤以及截图如下： 123456789########################################################################################################## 1、拉取 Tomcat 镜像docker pull nginx# 2、创建 Nginx 容器docker run -di --name=mynginx -p 80:80 nginx######################################################################################################### 那我们如何把漂亮的页面放到这里并进行访问呢？ 接下来，我们这样做：首先： 下载好右边的静态资源文件，并上传到自己的服务器。 【点击即可下载： 静态资源下载 】 如下图： 第二步： 进入到 nginx 容器，获取到静态页面所在的目录。 具体操作如下图： 在获取到静态页面所在的目录之后，我们退出 nginx 容器。如下图： 第三步： 解压 dist 压缩包，并改名为 html 【解压我自己提前做了】。然后把 html 复制到 nginx 容器中， 如下图： 最后： 打开浏览器访问即可。 如下图： Redis 部署Redis 部署 的相关步骤以及截图如下： 123456789########################################################################################################## 1、拉取 Redis 镜像docker pull redis# 2、创建 Redis 容器docker run -di --name=myRedis -p 6379:6379 redis######################################################################################################### 当 Redis 启动好了之后，我们使用客户端 Redis 进行远程连接。 如下图： 迁移与备份容器保存为镜像我们可以通过命令将容器保存为镜像，供他人使用。 命令如下： 1234567########################################################################################################## myNginx 是容器的名字。 mynginx_i 是保存之后的镜像的名字docker commit myNginx mynginx_i# 注意：镜像的名字不能大写，只能小写######################################################################################################### 然后我们使用自己保存的镜像来创建一个容器，看一下效果如何。 具体操作及结果如下图： 镜像备份我们可以通过命令将镜像保存为 tar 文件。 操作如下： 123456########################################################################################################## 把镜像保存为 tar 格式的压缩文件docker save -o mynginx.tar mynginx_i######################################################################################################### 镜像恢复与迁移首先，我们先删除掉 mynginx_i 镜像，然后执行相关命令进行恢复。操作如下图： 123456########################################################################################################## 把 tar 格式的压缩文件恢复为镜像docker load -i mynginx.tar######################################################################################################### Dockerfile 初识Dockerfile 是什么Dockerfile 是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 Dockerfile 是 docker 中镜像文件的的描述文件，说的直白点就是镜像文件到底是由什么东西一步步构成的。例如我们在淘宝上买了一件商品，但是这个商品需要组装才能使用，于是卖家就给了你一张图纸，你就按照图纸一步一步的组装起来，然后就成了你所需要的样子。那么 Dockerfile 就是这张图纸，镜像文件就是你需要的商品。Dockerfile 名字可以随便命名，但是不建议你这做，还是按照规范来使用，首字母要大写。 1234567891011121314########################################################################################################## 1、Dockerfile 的好处1、对于开发人员：可以为开发团队提供一个完全一致的开发环境； 2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了； 3、对于运维人员：在部署时，可以实现应用的无缝移植。# 2、Dockerfile、镜像、容器之间的关系1、Dockerfile：是镜像的构建文件，描述的镜像是一步步怎么来的。2、镜像：是通过 Dockerfile 做出来的，包含操作系统基础文件和软件运行环境，它使用分层的存储方式。3、容器：是运行起来的镜像，简单理解，Docker 镜像相当于程序，容器相当于进程。######################################################################################################### Dockerfile 常用命令了解命令之前，我们先看一下 Dockerfile 的关键字。 如下： 12345678910111213141516########################################################################################################## 关键字 作用 FROM # 指定基础镜像 MAINTAINER # 作者的信息 RUN # 执行什么命令 EXPOSE # 容器对外暴露的端口 WORKDIR # 进入到容器后进入到哪个目录 ENV # 配置环境变量 ADD # 将文件拷贝到镜像中并解压 COPY # 将文件拷贝到镜像中 VOLUME # 配置数据卷 CMD # 容器启动时候执行的命令 ENTRYPOINT # 容器启动时候执行的命令######################################################################################################### 了解关键字之后，我们再来了解 Dockerfile 的命令。 常用命令如下： 123456789101112########################################################################################################## 命令 作用 FROM image_name:tag # 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name # 声明镜像的创建者 ENV key value # 设置环境变量 (可以写多条) RUN command # 是 Dockerfile 的核心部分(可以写多条) ADD source_dir/file dest_dir/file # 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file # 和 ADD 相似，但是如果有压缩文件并不能解压 WORKDIR path_dir # 设置工作目录######################################################################################################### 使用脚本创建镜像我们以构建 JDK1.8 镜像作为演示，其基础镜像是 centos 。 构建步骤如下： 12345678910111213########################################################################################################## 1、创建目录mkdir –p /usr/local/dockerjdk8# 2、下载 jdk-8u171-linux-x64.tar.gz 并上传到服务器（虚拟机）中的 /usr/local/dockerjdk8 目录mv jdk-8u221-linux-x64.tar.gz /usr/local/dockerjdk8/cd /usr/local/dockerjdk8/# 3、创建 Dockerfile 文件vi Dockerfile######################################################################################################### 上述三个步骤截图如下： 接下来，我们需要编写 Dockerfile 文件。 其具体内容如下： 123456789101112131415161718########################################################################################################## Dockerfile 文件的内容如下：FROM centos # 依赖镜像名称和 IDMAINTAINER root # 指定镜像创建者信息WORKDIR /usr # #切换工作目录RUN mkdir /usr/local/java# ADD 是相对路径 jar ，把 java 添加到容器中ADD jdk-8u221-linux-x64.tar.gz /usr/local/java/ # 配置 java 环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_221ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH######################################################################################################### 编写完成之后，我们查看 Dockerfile 这个文件。 如下图： 接下来我们使用命令构建镜像。 具体操作及结果如下图： 123456789########################################################################################################## 4、执行命令构建镜像。注意：后边的空格和点，不要省略docker build -t='jdk1.8' .# 5、查看镜像是否建立完成docker images######################################################################################################### 构建成功之后截图如下： Docker 私有仓库私有仓库搭建与配置私有仓库： 顾名思义就是私人的，不对外开放的一种仓库，一般供企业内部使用。 如果我们不想把自己的镜像让互联网的用户使用，那么私有仓库就是最佳的选择。接下来，我们就介绍私有仓库的搭建过程和配置。如下： 123456789101112########################################################################################################## 1、拉取私有仓库镜像docker pull registry# 启动私有仓库容器docker run -di --name=myRegistry -p 5000:5000 registry# 3-1、打开浏览器 输入地址 http://192.168.0.141:5000/v2/_catalog 进行访问。# 3-2如果看到 `{\"repositories\":[]}` 表示私有仓库搭建成功并且内容为空######################################################################################################### 上述的操作截图以及结果如下图： 如果能够访问到上述页面，则代表私有仓库搭建成功。 至于页面内容返回值为空数组，那是因为这个私有仓库刚刚搭建，它里面还没有 docker 镜像。那么接下来的操作就是把我们的 docker 镜像上传到我们的私有仓库。 操作步骤如下： 123456789101112########################################################################################################## 4、修改 daemon.jsonvi /etc/docker/daemon.json# 5、添加以下内容(用于让 docker 信任私有仓库地址)，然后保存退出。里面是 =&gt; 虚拟机IP地址:端口号\"insecure-registries\": [\"192.168.0.141:5000\"]# 6、重启 docker 服务systemctl restart docker######################################################################################################### 上述三个步骤操作截图如下： TIPS： 私有仓库搭建与配置 到这里就搞定了！！！ 上传镜像至私有仓库现在，我们就上传镜像到私有仓库。【下载和上传类似，这里就不写了，不明白的自行搜索即可解决】 步骤如下： 123456789101112########################################################################################################## 1、标记此镜像为私有仓库的镜像。命令：docker tag 镜像名 服务器IP地址:端口号/镜像名docker tag redis 192.168.0.141:5000/redis# 2、再次启动私服容器。如果 registry 已启动，则跳过这一步docker start registry# 3、上传标记的镜像docker push 192.168.0.141:5000/redis######################################################################################################### 上述三个步骤的操作截图如下： 最终的结果如下： TIPS： Docker 的入门教程 到此结束！！！ Jenkins 知识DockerMaven 插件首先，我们先来了解一下 微服务的两种部署方法， 如下： 1234567########################################################################################################## 微服务的两种部署方法1、手动部署：把源码打包生成 jar 包（或 war 包）,将 jar 包（或 war 包）上传至虚拟机并拷贝至 JDK 容器中。2、自动部署：通过 Maven 插件来实现自动部署。######################################################################################################### 对于数量众多的微服务，手动部署无疑是非常麻烦的做法，并且容易出错。 所以我们这里学习如何自动部署，这也是企业实际开发中经常使用的方法。那么接下来，我们就通过 Maven 插件来实现自动部署。 其具体步骤如下： 12345678910111213141516########################################################################################################## 1、修改宿主机的 docker 配置，让其可以实现远程访问vi /lib/systemd/system/docker.service# 2、进入到 docker.service 配置文件，找到 ExecStart= 字样，然后在其后面加入如下代码，然后保存退出-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock# 3、刷新配置，重启服务。注意：docker start registry 命令被我替换成了下列第 3，4，5 这三条命令systemctl daemon-reloadsystemctl restart dockerdocker imagesdocker run -di --name=registry registrydocker ps######################################################################################################### 上述三个步骤的操作截图如下： TIPS： 这里需要你有一个微服务项目，如果没有，点击右侧下载： 微服务项目下载 如果上面的三个步骤都没有问题，那么我们来进行 第四步： 在工程下的 pom.xml 中增加配置。 代码及截图如下： 12345678910111213141516171819202122232425262728&lt;build&gt; &lt;finalName&gt;app&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- docker 的 maven 插件，官网：https://github.com/spotify/docker-maven-plugin --&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.4.13&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;192.168.0.141:5000/${project.artifactId}:${project.version}&lt;/imageName&gt; &lt;baseImage&gt;jdk1.8&lt;/baseImage&gt; &lt;entryPoint&gt;[\"java\", \"-jar\", \"/${project.build.finalName}.jar\"]&lt;/entryPoint&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;${project.build.directory}&lt;/directory&gt; &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;dockerHost&gt;http://192.168.0.141:2375&lt;/dockerHost&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 以上配置会自动生成 Dockerfile ，相当于如下三个命令【 注意： 以上的 IP 地址须改为自己的】： 1234567#########################################################################################################FROM jdk1.8ADD app.jar /ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]######################################################################################################### 第五步： 使用 IDEA 打开微服务项目，然后在 IDEA 下打开终端，执行 mvn install 命令。 如下图： 当上述操作完成后，我们进入到 第六步： 进入到需要实现自动部署的微服务工程目录下，输入命令 mvn docker:build -DpushImage 进行打包和上传镜像。 具体操作与详情请参照下图： 123456789101112# 注意：由于上述没有执行成功，所以下面的步骤也无法进行。搞了一天，老是出错，所以问题先留在这里，以后再来解决。上述操作完成后，我们进入宿主机 , 查看镜像docker images输出如上内容，表示微服务已经做成镜像浏览器访问 http://192.168.184.141:5000/v2/_catalog ，输出浏览器访问 http://192.168.184.141:5000/v2/_catalog ，输出{\"repositories\":[\"tensquare_base\"]}（7） 启动容器：docker run -di --name=base -p 9001:9001 192.168.184.141:5000/tensquare_base:1.0-SNAPSHOT # 注意：由于上述没有执行成功，所以下面的步骤也无法进行。搞了一天，老是出错，所以问题先留在这里，以后再来解决。 Jenkins 安装2.1 什么是持续集成 ​ 持续集成 Continuous integration ，简称CI ​ 随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile） 在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。 ​ 持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。 持续集成具有的特点： 它是一个自动化的周期性的集成测试过程，从检出代码、编译构建、运行测试、结果记录、测试统计等都是自动完成的，无需人工干预； 需要有专门的集成服务器来执行集成构建； 需要有代码托管工具支持，我们下一小节将介绍Git以及可视化界面Gogs的使用持续集成的作用： 保证团队开发人员提交代码的质量，减轻了软件发布时的压力； 持续集成中的任何一个环节都是自动完成的，无需太多的人工干预，有利于减少重复过程以节省时间、费用和工作量；2.2 Jenkins简介 ​ Jenkins，原名Hudson，2011年改为现在的名字，它 是一个开源的实现持续集成的软件工具。官方网站：http://jenkins-ci.org/。 ​ Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。 ​ 特点： 易安装：仅仅一个 java -jar jenkins.war，从官网下载该文件后，直接运行，无需额外的安装，更无需安装数据库； 易配置：提供友好的GUI配置界面； 变更支持：Jenkins能从代码仓库（Subversion/CVS）中获取并产生代码更新列表并输出到编译输出信息中； 支持永久链接：用户是通过web来访问Jenkins的，而这些web页面的链接地址都是永久链接地址，因此，你可以在各种文档中直接使用该链接； 集成E-Mail/RSS/IM：当完成一次集成时，可通过这些工具实时告诉你集成结果（据我所知，构建一次集成需要花费一定时间，有了这个功能，你就可以在等待结果过程中，干别的事情）； JUnit/TestNG测试报告：也就是用以图表等形式提供详细的测试报表功能； 支持分布式构建：Jenkins可以把集成构建等工作分发到多台计算机中完成； 文件指纹信息：Jenkins会保存哪次集成构建产生了哪些jars文件，哪一次集成构建使用了哪个版本的jars文件等构建记录； 支持第三方插件：使得 Jenkins 变得越来越强大2.3 Jenkins安装2.3.1 JDK安装 （1）将jdk-8u171-linux-x64.rpm上传至服务器（虚拟机） （2）执行安装命令 rpm -ivh jdk-8u171-linux-x64.rpm 1RPM方式安装JDK，其根目录为：/usr/java/jdk1.8.0_171-amd642.3.2 Jenkins安装与启动 （1）下载jenkins wget https://pkg.jenkins.io/redhat/jenkins-2.83-1.1.noarch.rpm 1或将jenkins-2.83-1.1.noarch.rpm上传至服务器 （2）安装jenkins rpm -ivh jenkins-2.83-1.1.noarch.rpm 1（3）配置jenkins vi /etc/sysconfig/jenkins 1修改用户和端口 JENKINS_USER=”root”JENKINS_PORT=”8888” 1 2（4）启动服务 systemctl start jenkins 1（5）访问链接 http://192.168.184.135:8888 从/var/lib/jenkins/secrets/initialAdminPassword中获取初始密码串 （6）安装插件 （7）新建用户 完成安装进入主界面 2.4 Jenkins插件安装 我们以安装maven插件为例，演示插件的安装 （1）点击左侧的“系统管理”菜单 ,然后点击 （2）选择“可选插件”选项卡，搜索maven，在列表中选择Maven Integration ，点击“直接安装”按钮 看到如下图时，表示已经完成 详情参考： 持续集成与容器管理","link":"/Docker-Jenkins.html"},{"title":"IDEA 入门教程","text":"第一章：初识 IntelliJ IDEAIDEA(IntelliJ IDEA) 概述IDEA 是一个专门针对 Java 的集成开发工具(IDE)，由 Java 语言编写。所以，需要有 JRE 运行环境并配置好环境变量。IDEA 可以极大的提高 Java 开发效率，是全世界用得最多的Java开发软件。它可以极大地提升我们的开发效率。可以自动编译，检查错误。在公司中，使用的就是IDEA进行开发。 IDEA 的下载安装IDEA的下载地址: https://www.jetbrains.com/idea/download 选择对应的操作系统和版本进行下载。在这里介绍一下IDEA的两个版本，旗舰版(Ultimate)和社区版(Community)。旗舰版用于Web和企业级应用开发，免费试用，后期收费。当然，我们会对其破解。社区版主要用于JVM和安卓开发，它是免费的。这些信息它都写在那儿了，我就不多说了。下载可参考下图： 接下来，让我们来安装一下IDEA。首先，双击下载好的IDEA，出现如下图界面： 点击Next，然后选择安装位置，不建议安装在C盘，参考如下图： 然后再点击Next，出现安装选项界面，这里我要说一下update context menu，当勾选了之后，待到IDEA完成安装时，在桌面点击鼠标右键就会出现IDEA。不过，默认不勾选，参考如下图： 点击Next，选择Install即可，参考如下图： 然后等待几分钟便可安装成功。如果电脑配置不高的话可能要十多分钟才能安装成功。成功界面参考如下： 勾选 Run IntelliJ IDEA，然后点击 finish，即可打开 IDEA。 IDEA 的激活打开 IDEA 之后，出现如下界面： 建议选择Do not impart settings，如果你先前安装过IDEA，需要导入原先的设置，那么请自己找到相关文件夹进行设置。然后点击OK，便进入到激活界面： 首先选择顶部Activate，然后使用以下三种激活方式任意一种： JetBrainsJetBrains Account 如果你有该账户，并且购买了此产品，那才可以激活。不过，一般我们不会购买这产品，毕竟贵呀，能省则省，哈哈。 Activation Code 使用激活码激活。激活码自己可以百度，或者去各大论坛搜索。如CSDN等等。以下是我的激活码，可能过期了，但还有用处： 1MNQ043JMTU-eyJsaWNlbnNlSWQiOiJNTlEwNDNKTVRVIiwibGljZW5zZWVOYW1lIjoiR1VPIEJJTiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wNC0wNSIsInBhaWRVcFRvIjoiMjAyMC0wNC0wNCJ9XSwiaGFzaCI6IjEyNjIxNDIwLzBwIiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOnRydWUsImlzQXV0b1Byb2xvbmdhdGVkIjp0cnVlfQ==-Zmbxcn7NPlqBNqAURX0uiLzybnruyx6PG+6KYZrpzm/IJJs5nnIogGgdfIJoifO6fbaaJYc5pjds7CHdrt/neIpvF2o/HvIjMEF4/AhNV7HUGsAa9zpMszc6YBIkMmVFh4Y7GPKOStA14/Ld83AC7kGnwL1Fq7eAXKJFljc00GMejPpfE0zDqTN634bC+0ojfklhWXaLqhUt230SiE8onnd3quvEaH5NsW7sIQm2spyONZI+iHvHFtl4EvG7tlRlD1StsfhrbgNNxz61FOEEQ+GtZIzMx+T4sbpfoRyms7lbWQecrbAtE0c2sR98esm4PcDUhrFVBxGorPC1ppOLSQ==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow== License Server 复制以下网址即可。但是网站好像访问不了，具体成功与否，本人未曾尝试，如无法激活，勿怪！网址如下： 1http://www.jetlicense.nss.im/ 以上三种方式都介绍完了。一般都是使用第二种方式激活，第三种简单，但我本人没用过，所以不知道能否成功。写在这里，仅供参考！除了上述三种方法之外，还有另一种破解的方法。所以这时，上面可能过期的激活码就派上用场了。我自己的IDEA就是这样激活的。话不多说，安排！找到hosts文件，文件路径在下面代码上方。这是针对windows系统的，如果是苹果系统，那就需要自己找一下了，我对苹果系统不熟。然后打开，添加代码到最后一行： C:\\Windows\\System32\\drivers\\etc\\hosts10.0.0.0 account.jetbrains.com 然后保存，回到IDEA，复制上面的激活码，使用第二种方式激活即可。这种方式和上面的第二种方式激活区别在于：上面第二种方式激活码过期了就无法激活，而这种不会。仅此一点。教程仅供参考，具体以实际情况为准。软件更新太快，教程不可能一直都适用，只是参考而已。成功之后截图如下，这个过程中还会遇到主题样式选择等一下界面，跳过即可： IDEA的配置目录介绍代码框顶部是文件夹或文件的路径。 C:\\Users\\guoshizhan\\.IntelliJIdea2018.3\\123#这个目录下就是IDEA的配置目录，不同操作系统不同用户都不一样，但相似，仅供参考！这些目录建议不要动！configsystem D:\\01_Programs\\02_Java\\03_IDEA\\IntelliJ IDEA 2018.3.5\\1234#这个目录下就是IDEA的安装目录，bin目录下面的idea64.exe.vmoptions文件可以修改IDEA所需最大内存或缓冲区大小等等。bin--&gt;idea64.exe.vmoptions#bin目录下面的idea64.properties文件可以修改IDEA的一些配置等等，要了解更多，自行Google或百度。bin--&gt;idea64.properties 第二章：IDEA 个性化配置各种自定义配置的路径 操作 路径 打开工具条 View \\ Toolbar 全局主题配置 File \\ Settings \\ Appearance &amp; Behavior \\ Appearance –&gt; Theme 主题字体 File \\ Settings \\ Appearance &amp; Behavior \\ Appearance –&gt; use custom font 编辑区主题配置 File \\ Settings \\ Editor \\ Color Scheme –&gt; Scheme 鼠标滑轮修改字体大小 File \\ Settings \\ Editor \\ General –&gt; Mouse –&gt; Change font··· 鼠标悬浮提示 File \\ Settings \\ Editor \\ General –&gt; Other –&gt; Show quick··· 自动导包 File \\ Settings \\ Editor \\ General \\ Auto Import –&gt; Java –&gt;Add unambiguous··· + Optimize imports··· 代码行号和方法分隔符 File \\ Settings \\ Editor \\ General 忽略大小写配置 File \\ Settings \\ Editor \\ General \\ Code Completion –&gt; Match case··· 文件多行显示 File \\ Settings \\ Editor \\ General \\ Editor Tabs –&gt; Appearance–&gt;Show tabs in one row 默认字体大小\\行间距 File \\ Settings \\ Editor \\ Font –&gt; Font \\ Size \\ Line spacing 注释颜色修改 File \\ Settings \\ Editor \\ Color Scheme \\ Language Defaults –&gt; Comments –&gt; ··· 工程项目编码 File \\ Settings \\ Editor \\ File Encodings –&gt;··· 自动编译 File \\ Settings \\ Build, Execution, Deployment \\ Compiler –&gt; Build project··· + Compiler independent··· 代码补全快捷键 FileFile \\ Settings \\Keymap –&gt; Main menu \\ Code \\ Completion \\ Basic 取消方法一行自动折叠 File \\ Settings \\ Editor \\ General \\ Code Folding –&gt; one-line methods IDEA 快捷键最常用快捷键 操作 快捷键 代码自动补全 Alt + / 自动生成构造方法等 Alt + Ins 复制一行 Ctrl + D 删除一行 Ctrl + Y 撤回操作 Ctrl + Z 自动代码生成模板 Ctrl + J 显示最近更改代码 Ctrl + E 非常好用 专注模式 shift + f4 代码格式化 Ctrl + Alt + F 移动代码 Alt + Shift + 上下箭头 跳转到指定行 Ctrl + G 查找类或文件 Ctrl + N 查找文本 Ctrl + F 单行注释 Ctrl + / 多行注释 Ctrl + Shift + / 重命名 shift + f6 其他快捷键 操作 快捷键 补全结尾 Ctrl + Shift + 回车 自动选中代码 Ctrl + W 反选代码 Ctrl + Shift + W 代码包围 Ctrl + Alt + T 方法间切换 Alt + 上下箭头 大小写切换 Ctrl+ Alt + U 替换文本 Ctrl + R IDEA 自定义模板路径：File | Settings | Editor | Live Templates–&gt; output 。 如输入guo，按下Enter出现以下代码： 123456789/** * @author $user$ * @date $date$ $time$ * @version V1.0 * @Description: */public void $NAME$(){ } 路径：File | Settings | Editor | File and Code Templates –&gt; Files –&gt; Class 12345/** *@author: guoshizhan *@create: ${YEAR}-${MONTH}-${DAY}-${TIME} *@description: */ 路径：File | Settings | Editor | File and Code Templates –&gt; Includes –&gt; File Header 12345/** *@Author: ${USER} *@Create: ${DATE} ${TIME} *@Description: */ 各种快捷键路径：File | Settings | Editor | General | Postfix Completion如：10.fori 则成下列代码： 123for(int i = 0; i &lt; 10; i++){} IDEA导入 Eclipse 中的 maven 项目，直接点即 open 即可。 分享几款好用的插件 material theme UI rainbow brackets power modeⅡ Lombok","link":"/IDEA.html"},{"title":"LeetCode 解题记录","text":"前言： 这是一篇关于 LeetCode 题解 的文章，总共分为三章：简单题型 、中等题型 、困难题型 ， 主要用于记录自己的解题过程，同时也为了以后看到类似的问题时，自己能够及时查阅并解决问题。最后，也希望能够帮助到其他人，这才是写这篇博客的初衷。当然了，这里 只提供思路和 Java 语言的实现 ，不提供其他语言的实现。（因为其他语言我不会呀，呜呜呜~ ~ ~） 简单题型两数之和题目描述 代码实现第一种：代码实现简单版，代码如下： 1234567891011121314151617class Solution { public int[] twoSum(int[] nums, int target) { for (int i = 0; i &lt; nums.length; i++) { for (int j = i + 1; j &lt; nums.length; j++) { if (nums[i] == target - nums[j]) { return new int[]{i, j}; } } } throw new IllegalArgumentException(\"No two sum solution !!!\"); }} 第二种：代码实现高级版，代码如下： 1234567891011121314151617class Solution { public static int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { int complement = target - nums[i]; if (map.containsKey(complement)) { return new int[]{map.get(complement), i}; } map.put(nums[i], i); } throw new IllegalArgumentException(\"No two sum solution !!!\"); }} 移除元素题目描述 代码实现123456789101112class Solution { public int removeElement(int[] nums, int val) { int count = 0; for(int i = 0; i &lt; nums.length; i++){ if(nums[i] != val){ nums[count++] = nums[i]; } } return count--; } } 中等题型困难题型","link":"/LeetCode.html"},{"title":"Git 使用教程","text":"Git 初识Git 历史同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。到 2005 年的时候，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统订了若干目标： 若干目标： • 速度 • 简单的设计 • 对非线性开发模式的强力支持（允许上千个并行开发的分支） • 完全分布式 • 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） Git 与 svn 对比SVN 介绍SVN 是 集中式版本控制系统 ，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器那里得到最新的版本，然后干活。干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就郁闷了。下图就是标准的集中式版本控制工具管理方式： 集中管理方式优缺点： 优点： 开发人员在一定程度上看到其他开发人员在干什么，而管理员也可以很轻松掌握每个人的开发权限。缺点： 1、服务器单点故障问题。2、容错性差。 Git 介绍Git 是 分布式版本控制系统 ，那么它是没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了 文件 A ，其他人也在电脑上改了 文件 A 。这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。下图就是分布式版本控制工具管理方式： Git 工作流程： 1、从远程仓库中克隆 Git 资源作为本地仓库。 2、从本地仓库中 CheckOut 代码然后进行代码修改。 3、在提交前先将代码提交到暂存区。 4、提交修改。提交到本地仓库。本地仓库中保存修改的各个历史版本。 5、在修改完成后，需要和团队成员共享代码时，可以将代码 push 到远程仓库。 下图展示了 Git 的工作流程： Git 的下载安装访问官网： www.git-scm.com/download/ 选择 相应操作系统 下载。下载好之后，安装即可【建议： 安装的时候一直点 Next 即可，直到完成，不必去改安装目录】。安装完成之后，点击鼠标右键会出现 Git GUI Here 和 Git Bash Here ，如下图所示： 当我装上了 Git 之后，发现其实并不是特别好用。此时就要装一个更好操作 Git 的软件 TortoiseGit ，这是 TortoiseGit 的官网: https://tortoisegit.org/download/ ，下载安装即可。安装时注意以下两项，如下图： 安装完成后，点击鼠标右键，就可看到新增了 三项功能 ，如下图： 安装后发现，全部都是英文的，好像有点看不懂。没关系，汉化一下就可以了。汉化包自行搜索或者联系我。汉化完成后，点击右键，选择 TortoiseGit --&gt; settings 就进入到了以下界面，选择即可。如下图： 完成之后，界面的所有文字就都是中文的了。接下来介绍 Git 的使用。 Git 的使用Git 命令汇总123456789101112# 查看 Git 版本git --version# 初始化一个本地仓库git init# 生成密钥对ssh-keygen -t rsa -C \"Jack@qq.com\"# 参数含义：# -t 指定密钥类型，默认是 rsa ，可以省略。# -C 设置注释文字，比如邮箱。# -f 指定密钥文件存储文件名。 创建版本库什么是版本库版本库又名 仓库 ，英文名 repository 。可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。由于 Git 是分布式版本管理工具，所以 Git 在不需要联网的情况下也具有完整的版本管理能力。 版本库的创建创建一个版本库非常简单，可以使用 Git Bash 也可以使用 TortoiseGit ，还可以使用 Git GUI ，这三种方式都可以创建一个版本库。接下来就开始介绍如何创建一个版本库。第一步： 选择一个合适的地方，创建一个空目录，如：在桌面。如下图： 第二步： 在版本库创建好之后，在版本库目录下创建一个 本地仓库 ，如下图： 到这里为止，版本库就创建好了。注意一下： 这里的版本库指的是本地版本库，仓库也是本地仓库。 各种概念介绍 本地版本库： .git 文件夹 就叫做本地版本库 。工作目录： 包含 .git 的那个目录就叫做工作目录，如 repo_1 。工作区： 包含本地仓库的目录就是工作区。如 Repositories 。 操作版本库向本地仓库添加文件第一步： 在 repo_1 目录下添加一个文件 hello.txt ，然后使用 TortoiseGit 中的 add 加入到暂存区。此时的 hello.txt 并没有添加到本地仓库，如下图： 第二步： 提交到本地仓库。在 repo_1 目录下空白处点击鼠标右键，选择 Git commit-&gt;master ，然后出现如下界面： 提交成功后出现一个弹窗，选择关闭即可。此时 hello.txt 就加入到了本地版本库，效果如下图： 第三步： 在添加完文件之后，我们查看一下本地仓库【在 repo_1 目录下 点击右键：选择 TortoiseGit--&gt;Repo-browser 】如下图： 向本地仓库修改文件通过上图我们发现，结果只有 hello.txt 。因为我们只添加了这一个文件，所以只有这么一个文件。现在我们修改一下这个文件里面的内容，随便修改就行。修改完之后进行第二次提交。提交参考 第二步 【Git 可以不需要添加到暂存区就可以直接提交】。提交完成之后再次修改文件内容，然后再次提交。这个时候我们就有版本了。就可以进行 第四步： 查看版本信息。那么如何来查看呢？在 repo_1 目录下 点击右键 TortoiseGit--&gt;Show log 即可查看到各个版本。如下图： 那我们如何知道 第二次提交 和 第三次提交 修改了什么内容呢？别急，参考下面图解： 向本地仓库删除文件如果我们把 hello.txt 误删了怎么办？没关系，点击右键选择： TortoiseGit--&gt;Revert... 即可把误删了的文件给还原回来。如果 TortoiseGit 汉化了的话，那么你会看到 还原 ，而不是 Revert… 。这里要注意： 如果 hello.txt 文件修改了没有提交，那么此时删除了，再次还原的话，修改的内容就没了。因为还原操作是从本地仓库找到文件还原回来，所以修改的内容就没有了。还原也有下面一种操作，点击右键选择： Git Sync... ，如下图： 如果我们想把 hello.txt 从版本库里面删除 ，但又 不想删除本地 的 hello.txt ，又该怎么办呢？这么办，如下图： 如果我们就是想删除 hello.txt ，且本地也不保存，如何做？简单，只要本地删除 hello.txt ，然后 commit 提交一下，这样就把这个文件从本地删除了，且版本库也没有了这个文件。 提交工程代码如何去提交我们的代码呢？以为一个工程中，有些文件夹是不需要提交到本地仓库的，例如 .diea 文件夹 和 out 文件夹 ，那我们该如何忽略它们呢？这么干。第一步： 把整个项目添加到 暂存区 ，如下图： 第二步： 在添加到暂存区之后，我们进入到 HelloProject ，选中需要忽略的文件或文件夹，然后右键，如下图： 第三步： 选中忽略方式，我们选择递归忽略，如下图： 第四步： 查看 HelloProject 工程，并查看 .gitignore 文件，如下图： 第五步： 提交到本地仓库，并进行仓库查看，如下图： 添加远程仓库要使用远程仓库的话，必须要有 GitHub 账号 。当然，码云账号 也行，都是同类型的产品。本教程使用 GitHub 为例（GitHub 知名度高嘛）。首先我们得注册账号并新建远程仓库，详情参考：GitHub 账号注册 新建仓库如下图： 推送到远程仓库那我们有了远程仓库之后，我们就要把 本地仓库 推送到 远程仓库 。如何推送呢？别急，先介绍下列概念。 Github 支持两种同步方式 HTTPS 和 SSH 。*如果使用 HTTPS * ，那就很简单，基本不需要配置就可以使用。但是每次提交代码和下载代码时都需要输入用户名和密码，很麻烦。如果使用 SSH 方式 ，就需要 客户端先生成一个密钥对 ，即一个公钥一个私钥。然后还需要把公钥放到 GitHub 的服务器上。接下来先看 SSH 方式。 SSH 方式SSH 为 Secure Shell（安全外壳协议） 的缩写，由 IETF 的网络小组（Network Working Group）所制定。SSH 是目前较可靠、专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。使用 SSH 协议通信时，推荐使用基于密钥的验证方式。你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到 SSH 服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙， 然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密 质询（challenge） 并把它发送给客户端软件。客户端软件收到 质询 之后就可以用你的私人密匙解密再把它发送给服务器。 创建 SSH 密钥在 repo_1 目录下点击右键，选择 Git Bash Here ，相关操作如下图： 以下是我的公钥，我们需要把公钥复制出来，然后去 GitHub 进行相关操作： id_rsa.pub1ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCuKASZWC4eMblBf0Pcqrvp9xjqLH+bOp5ogVLi01HwrCnD79bp/VtfyOpeGr3NLRgZzImHvms532c+jNbzFFoDdFGyNyis4l01eudE4wRdzcJ6cxhrMVd0l1VK7mc4hwE3jocRleiSJBE0J3hrxkPGpcHco6u2wW8majmuk2FLfvEgcOh0xKT3N9DQsecIx6cCtIJu8Krr7IdVJvNBB1v9AzNb4lwjNkLzBDJB0OOKF21a12wJo+WFhMqJkf5ktAU8TthBB51/NHTxDyOD5gBFIhVtesow0hQhZmdO84LC4b+KJIGIM+i5MlFB3GeEmjhYF2BvMmcXfzJdPC9UZx5T guoshizhan@guoshizhan 复制好自己的公钥，然后去 GitHub 网站，点击自己头像 ，选择 settings ，此时进入到另一个页面，选择左侧的 SSH and GPA keys ，如下图： 点击 add SSH key ，然后验证一下 GitHub 账户的密码，这样就添加成功了。这样做的 目的就是： 不需要输入账号密码，也可以和 GitHub 服务器进行通信，也可以保证通信的安全可靠。虽然生成密钥及配置有点麻烦，但是后面操作的时候就翻方便多了。而不是像 HTTPS 那样了，每操作一次，就输入一次账号密码，头都大了。成功添加 SSH key 如下图： 推送到远程仓库第一种方式：命令行。 在 repo_1 目录下点击右键，选择 Git Bash Here ，相关操作如下图： TIPS： origin 是个别名，代表 远程仓库 ，你也可以叫 aaa 或者其他的名字，都行，无所谓的。 第二种方式：TortoiseGit 图形界面方式。 在 repo_1 目录下点击右键，选择 Git Sync... ，相关操作如下图： 接下来介绍 HTTPS 通信方式，通过此方式推送到远程仓库。 HTTPS 方式在本地仓库新建 https.txt 文件，然后添加到本地仓库。这样做是为了区分是否推送成功。首先： 复制 HTTPS 连接，如下图： 接着： 在 repo_1 目录下点击右键，选择 Git Sync... ，相关操作如下图： 克隆远程仓库到本地第一种方式：命令行。 在 repo_1 目录下点击右键，选择 Git Bash Here ，相关操作如下图： TIPS： 克隆下来的代码和远程仓库是一模一样的，提交次数、修改信息等等都可以查看。 第二种方式：TortoiseGit 图形界面方式。 在 Repositories 目录下新建 test 文件夹 ，然后进入文件夹，点击鼠标右键，选择 Git clone ，【提前复制好远程仓库 HTTPS 连接或者 SSH 连接】 如下图： 推送修改文件和拉取最新文件推送修改文件如果我们在本地仓库新建了一个 XYZ.txt 文件，并把这个文件添加到本地版本库，即本地仓库。那么远程仓库是没有这个文件的，我们应该把我们的修改提交到远程仓库，如何做？这里就用文字描述了，就不上图片了。步骤： 点击右键 –&gt; Git Sync... –&gt; push ，等待推送完成即可。完成之后去远程仓库查看，就发现多了 XYZ.txt 文件。这里要注意：推送的时候要选择对应的远程仓库，别推送错了。其次，建议使用 SSH 方式，使用 HTTPS 方式输账号密码好烦，软件好像没有记忆功能，我太难了。最后说一下，以为我是用的是英文版的 TortoiseGit ，所以都是 Git Sync… 、push 等等之类的，他们对应的中文是 同步， 推送，只要看的懂就行了，不行就查一下嘛，问题不大。 拉取最新文件加入别人推送了最新的代码，我们应该如何把它拉取到本地呢？仍然是文字教程，就不上图了。在你的本地仓库下点击右键，Git Sync… ，然后选择左侧的 pull 。 注意：远程仓库地址要选好，别拉取错了。拉取完成之后，本地仓库就是最新的了。 冲突问题冲突问题的产生： A 程序员修改了 aa.txt 文件，并推送到了远程仓库。然而，在 A 程序员推送到远程仓库之前，B 程序员也修改了 aa.txt 文件，B 程序员修改完之后，A 程序员已经把代码推送到了远程仓库。但是，此时的 B 程序员也想推送到远程仓库，但是发现报错了，推送不了了。B 程序员想拉取远程仓库代码，拉取也不行了。这就是冲突。冲突产生的原因： 同时修改同一个文件，然后推送后导致本地仓库和远程仓库不一致。解决办法：手动解决，只能自己去决定采用 A 程序员修改的还是 B 程序员修改的。 此处都是文字描述，不好参照。限于时间的关系，只能这样了，有时间的话，我会重新给这一部分加上图片描述。 搭建私有 Git 服务器远程仓库实际上和本地仓库没啥不同，纯粹为了 7x24 小时开机并交换大家的修改。GitHub 就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给 GitHub 交保护费，那就只能自己搭建一台 Git 服务器作为私有仓库使用。 需要的工具： 1、一台 Linux 虚拟主机或者云主机2、远程连接工具（云主机需要，虚拟机可用可不用） 推荐：SecureCRT 搭建步骤第一步： 安装 C 语言环境： 1yum -y install curl curl-devel zlib-devel openssl-devel perl cpio expat-devel gettext-devel gcc cc 第二步： 发送 git 压缩包到服务器，git-2.5.0 压缩包下载 步骤如下图： 接下来的内容我就不再写了，直接给个压缩包，里面 软件和文字版教程 都有，点击右侧下载即可。 git 所有资料","link":"/Git.html"},{"title":"Linux 入门教程","text":"内容概要： Liunx-介绍 系统操作 服务管理 shell-脚本 文本操作 服务管理 Liunx 介绍什么是 Linux Linux 版本内核版本 发行版本 安装 Linux 系统我将使用的 VMware 虚拟机 来安装 Liunx 操作系统，具体安装步骤如下： Linux 安装步骤： 1、安装 VMware 虚拟机 2、下载 Linux 镜像 3、安装 Liunx 系统 安装 VMware 虚拟机虚拟机的安装和普通电脑软件安装一样，这个就不演示了。虚拟机点击左侧下载： VMware 虚拟机下载 下载 Linux 镜像以下是各种 Linux 镜像下载地址 ，选择下载即可。如下图： 安装 Liunx 系统 刚安装好是无法联网的，通过以下设置即可联网： 使用 Linux 系统小白命令汇总1234567init 0 # 让 Linux 系统关机init 3 # 由图形界面进入到命令行startx # 由命令行进入到图形界面exit # 退出当前用户su - root # 用户切换操作：切换到 root 管理员用户su - Jack # 用户切换操作：切换到 Jack 普通用户ls / # 查看根目录下的文件或文件夹，例如：ls /root ls /bin ls /sbin root 用户和普通用户如果 非 root 用户 登陆，用户名后面显示的是 &quot;$&quot; ，如下图： 如果是 root 用户 登陆，用户名后面显示的是 &quot;#&quot; ，如下图： 使用终端 使用终端的三种方式： 1、图形终端 2、命令行终端 3、远程终端（SSH , VNC） 常见目录介绍 系统操作 万能帮助命令 为什么要学习帮助命令： Linux 的基本操作是命令行，里面有海量的命令不适合我们死记硬背，所以当我们不知道如何使用一个 Liunx 命令时，我们就可以使用以上的三种帮助命令来获取相关命令介绍，从而学会如何使用该命令。 man 帮助命令 通过上图介绍，我们知道了 man 命令 的相关用法。举个例子，如果我们不知道 ls 命令 怎么用，那么就使用 man ls 来获取 ls 命令的相关介绍。当然了，我们也可以使用 man man 来获取 man 命令的相关帮助。如下图： man 后面为什么要加上章节呢？ 因为 有些命令是重名的，不加上章节的话，就容易相关命令弄混。举例如下： 12345678# 命令 passwd 帮助man 1 passwd# 文件格式规范中的 passwd 帮助man 5 passwd# 如果不知道是哪一章的命令man -a passwd help 帮助命令 上图中有 内部命令 和 外部命令 ，那么如何区分呢？欲知详情，请看下图： 由上图可知， cd 命令 是内部命令，ls 命令 是外部命令。 info 帮助命令 info 帮助命令是英文的，理解优点难度。下图是 ls 的 info 帮助命令： 文件操作相关命令12345678910111213141516171819man pwd # 查看 pwd 命令帮助信息pwd # 显示当前目录名称pwd --help # 显示帮助信息，然后退出pwd --version # 显示版本信息，然后退出 cd # 更改当前的操作目录cd / # 回到根目录cd - # 返回上一次操作cd .. # 返回上一级 cd /path/to/... # 绝对路径cd ./path/to/... # 相对路径cd ../path/to/... # 相对路径 ls # 查看当前目录下的文件ls -l . # 这个 . 是作为参数，代表当前目录，默认可省略ls [选项] [文件名] # 选项是用来扩充 ls 命令的功能，文件名是 ls 命令的参数clear # 清除屏幕，Ctrl + L 也行 初识 ls 命令 Linux 中文件的颜色代表了是否有权限，有时 ls 命令 会提示权限不足，说明当前的用户还没有权限查看当前的文件。如下图： 以下各种命令都在图片中了，这样方便查看效果： 初识 cd 命令 目录操作相关命令123456789101112131415161718192021222324252627282930313233# 创建一级文件夹mkdir /guo # 在根目录下创建 guo 文件夹mkdir guo # 在当前目录创建 guo 文件夹mkdir A B C # 在当前目录创建 A B C 三个文件夹mkdir A # 如果文件已经存在，那么会提示无法船创建目录# 创建多级文件夹mkdir A/E # 在 A 文件夹里创建 E 文件夹mkdir A/E/F # 在 A 文件夹下的 E 文件夹里创建 F 文件夹mkdir -p A/G/H # 这样创建可以一次性创建多个文件夹，不需要一个一个地创建# 删除文件夹rmdir /guo # 删除根目录下的 guo 文件夹，如果文件夹非空，会无法删除rm -r /a # 删除根目录下的 guo 文件夹，如果文件夹非空，会进行提示rm -r -f /a # 删除根目录下的 guo 文件夹，如果文件夹非空，不会进行提示rm -r -f / a # 这条命令慎用，一旦执行，操作系统就没了。慎用~~~# 复制文件和目录touch f-A # 创建一个文件cp guo /tmp # cp 是 copy 的意思，命令表示把当前 guo 这文件复制到 tmp 文件夹下cp -r guo /tmp # guo 如果是文件夹，就要用这条命令，是文件，就用上一条命令即可cp -v f-A /tmp # 把文件复制到 tmp 目录，并且显示进度条，去掉 -v 则不显示进度条cp -p f-A /tmp # -p 表示保留原先文件的时间cp -a f-A /tmp # -a 表示保留原先文件的的所有属性。例如：权限、作者、创建时间等等# 移动和重命名文件和文件夹mv f-A f-B # 把文件 f-A 重命名为 f-B，其实 Linux 底层做的就是一个移动操作mv f-A /tmp # 把文件 f-A 移动到 tmp 文件夹下面mv /tmp/f-A /f-C # 移动操作和重命名操作同时进行，把 tmp 文件夹下的 f-A 文件移动到根目录并重命名为 f-C 创建和删除目录 移动和复制目录 通配符 文本查看相关命令1234567891011cat file-1 # 查看文件head file-1 # 查看文件开头部分，默认 10 行head -3 file-1 # 查看文件开头前 3 行内容tail file-1 # 查看文件结尾部分，默认 10 行tail -3 file-1 # 查看文件结尾 3 行内容tail -f file-1 # 动态追踪文件，如日志文件wc -l file-1 # 显示文件的总行数more file-1 # 按行显示内容less file-1 # 使用 less 可以随意浏览文件，比 more 更强大 打包和压缩相关命令 1234567891011121314151617tar cf /AA.tar /etc # tar 命令的选项是没有减号的，选项中的 f 代表打包成文件ls -l /AA.tar # 查看文件大小，单位是字节ls -lh /AA.tar # 查看文件大小，单位是兆# 打包并压缩tar czf /AA.tar.gz /etc # z 代表集成了 gzip 压缩命令，此处代表打包并压缩tar cjf /AA.tar.bz2 /etc # j 代表集成了 bzip2 压缩命令，此处代表打包并压缩,且压缩程度比 gzip 高，耗时也更多# 解压tar xf /AA.tar -C /guo # 解压 AA.tar ，-C 代表指定解压到某个目录，它的后面就是解压的目的地。如果不写 -C ,那么会报错tar zxf /AA.tar.gz -C /guo # 解压 AA.tar.gztar jxf /AA.tar.bz2 -C /guo # 解压 AA.tar.bz2# 小提示：# tar.gz 的缩写 tgz ， tar.bz2 的缩写 tbz2 。# tar xf 也可以解压 tar.gz 和 tar.bz2 等压缩文件。# It is over !!! vim 的四种模式 vi 与 vim 的区别： 1、多级撤消：在 vi 中，按u只能撤消上次命令，而在 vim 里可以无限制的撤消。 2、易用性：vi 只能运行于 unix 中，而 vim 不仅可以运行于 unix，还可用于 windows、mac 等多操作平台。 3、语法加亮：vim 可以用不同的颜色来加亮你的代码，在 vi 中没有。 4、对 vi 完全兼容：可以把 vim 当成 vi 来使用。 小结一下： vi 和 vim 都是 Linux 中的编辑器，不同的是 vim 比较高级，可以视为 vi 的升级版本。vi 适用于文本编辑，但是 vim 更适用于写代码。注意事项： 如果不在正常模式，就按 Esc 即可回到正常模式。 那我们来练习一下，在 Liunx 终端输入 vi ，然后就进入到了 vi 模式： 在 Liunx 终端输入 vim ，然后也可以进入到了 vim 模式： vim 命令汇总123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# 正常模式下可进行的操作## 光标移动操作 上下左右键盘也可以移动光标，但是如果是字符终端对文本进行控制，那么可能产生乱码 小写 h # 光标向左移动小写 j # 光标向下移动小写 k # 光标向上移动小写 l # 光标向右移动## 文本复制、剪切、粘贴、撤回、恢复等操作yy # 复制光标所在位置的一整行，此处复制产生换行y$ # 复制光标所在位置到行末，此处复制不产生换行n yy # 复制 n 行，n 是数字，起始位置为光标所在位置算作第一行n y$ # 复制 n 行，n 是数字，起始位置为光标所在位置到行末算作第一行dd # 剪切光标所在一整行，包括换行符d$ # 剪切光标所在一整行，不包括换行符p 或 P # 粘贴操作，直接按 p 即可把复制的内容粘贴到光标位置小写 u # 撤回操作ctrl + r 或 R # 恢复操作x # 删除单个字符，即光标所在字符会被删除r + 需替换字符 # 替换单个字符，即光标所在字符会被替换成其他字符:set nu # 显示行号 n shift + g # 跳转到指定行，n 代表行数，此操作类似于 Windows 中的 ctrl + ggg # 直接跳转到第一行大写 G # 跳转到最后一行^ # 来到光标所在行开头$ # 来到光标所在行结尾 ## 模式进入操作小写 i # 进入到插入模式大写 I # 进入到插入模式小写 o # 进入到插入模式大写 O # 进入到插入模式小写 a # 进入到插入模式大写 A # 进入到插入模式小写 s # 进入到插入模式大写 S # 进入到插入模式冒号 : # 进入到命令模式esc键 # 回到正常模式小写 v # 进入到可视模式，选中光标所在的字符，上下左右移动的单位是字符大写 V # 进入到可视模式，选中光标所在的行，上下移动的单位是行ctrl + v # 可视块，以列为单位，相当于 Windows 中的 alt 键的块，然后插入需要的值，按 esc 即可看到效果# 命令模式可进行的操作## 保存和退出操作:w # 保存已有文件名的文件:wq # 保存已有文件名的文件并退出:x # 保存已有文件名的文件并退出:w /a.txt # 保存没有文件名的文件，并保存到根目录下的 a.txt:q # 表示退出:qa! # 强制退出且不保存:q! # 表示不保存!+linux命令 # 临时执行一条 Linux 命令，例如：!ifconfig，表示临时查看 ip 地址## 查找和替换命令/+查找内容 # 文本查找，正斜杠后面不要空格，除非你需要查询空格，按小写 n 查找下一个匹配项， 大写 N 查找上一个匹配项:s/x/B # 单个字符替换，把光标所在位置的 x 替换成 B:%s/x/B # 全文替换，把整篇文本每行的第一个 x 替换成 B，如果一行存在多个 x，只会替换第一个:%s/x/B/g # 全文替换，把全文的 x 替换成 B,如果一行存在多个 x，那么全部都会被替换成 B3,5/x/B # 指定范围替换单个匹配字符，每行被找到的第一个 x 会被替换成 B，范围在第 3 行到第 5 行3,5/x/B/g # 指定范围全局替换，第三行到第五行所有匹配字符 x 都会被替换成 B## 对 vim 的设置:set nu # 显示行号，单次生效:set nonu # 不显示行号，单次生效:set hlsearch # 高亮显示，单次生效:set nohlsearch # 去除高亮显示，单次生效## 修改 vim 配置文件,使设置永久生效vim /etc/vimrc # 编辑 vim 配置文件:set nu # 然后到最后一行添加此代码，表示每次使用 vim 编辑文本都会显示行号 正常模式 正常模式下的各种命令操作汇总： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 光标移动操作 上下左右键盘也可以移动光标，但是如果是字符终端对文本进行控制，那么可能产生乱码 小写 h # 光标向左移动小写 j # 光标向下移动小写 k # 光标向上移动小写 l # 光标向右移动# 文本复制、剪切、粘贴、撤回、恢复等操作yy # 复制光标所在位置的一整行，此处复制产生换行y$ # 复制光标所在位置到行末，此处复制不产生换行n yy # 复制 n 行，n 是数字，起始位置为光标所在位置算作第一行n y$ # 复制 n 行，n 是数字，起始位置为光标所在位置到行末算作第一行dd # 剪切光标所在一整行，包括换行符d$ # 剪切光标所在一整行，不包括换行符p 或 P # 粘贴操作，直接按 p 即可把复制的内容粘贴到光标位置小写 u # 撤回操作ctrl + r 或 R # 恢复操作x # 删除单个字符，即光标所在字符会被删除r + 需替换字符 # 替换单个字符，即光标所在字符会被替换成其他字符:set nu # 显示行号 n shift + g # 跳转到指定行，n 代表行数，此操作类似于 Windows 中的 ctrl + ggg # 直接跳转到第一行大写 G # 跳转到最后一行^ # 来到光标所在行开头$ # 来到光标所在行结尾 # 模式进入操作小写 i # 进入到插入模式大写 I # 进入到插入模式小写 o # 进入到插入模式大写 O # 进入到插入模式小写 a # 进入到插入模式大写 A # 进入到插入模式小写 s # 进入到插入模式大写 S # 进入到插入模式冒号 : # 进入到命令模式esc键 # 回到正常模式小写 v # 进入到可视模式，选中光标所在的字符，上下左右移动的单位是字符大写 V # 进入到可视模式，选中光标所在的行，上下移动的单位是行ctrl + v # 可视块，以列为单位，相当于 Windows 中的 alt 键的块，然后插入需要的值，按 esc 即可看到效果 插入模式 命令模式命令模式也叫做末行模式，即在文件最后一行进行操作，如下图： 命令模式相关的命令汇总： 1234567891011121314151617181920212223242526272829# 保存和退出操作:w # 保存已有文件名的文件:wq # 保存已有文件名的文件并退出:w /a.txt # 保存没有文件名的文件，并保存到根目录下的 a.txt:q # 表示退出:qa! # 强制退出且不保存:q! # 表示不保存!+linux命令 # 临时执行一条 Linux 命令，例如：!ifconfig，表示临时查看 ip 地址## 查找和替换命令/+查找内容 # 文本查找，正斜杠后面不要空格，除非你需要查询空格，按小写 n 查找下一个匹配项， 大写 N 查找上一个匹配项:s/x/B # 单个字符替换，把光标所在位置的 x 替换成 B:%s/x/B # 全文替换，把整篇文本每行的第一个 x 替换成 B，如果一行存在多个 x，只会替换第一个:%s/x/B/g # 全文替换，把全文的 x 替换成 B,如果一行存在多个 x，那么全部都会被替换成 B3,5/x/B # 指定范围替换单个匹配字符，每行被找到的第一个 x 会被替换成 B，范围在第 3 行到第 5 行3,5/x/B/g # 指定范围全局替换，第三行到第五行所有匹配字符 x 都会被替换成 B# 对 vim 的设置:set nu # 显示行号，单次生效:set nonu # 不显示行号，单次生效:set hlsearch # 高亮显示，单次生效:set nohlsearch # 去除高亮显示，单次生效# 修改 vim 配置文件,使设置永久生效vim /etc/vimrc # 编辑 vim 配置文件:set nu # 然后到最后一行添加此代码，表示每次使用 vim 编辑文本都会显示行号 修改 vim 配置文件,使设置永久生效，操作如下图： 可视模式 服务管理用户和用户组管理在 Windows 系统中，一般情况下是一个用户使用当前操作系统。但是在 Liunx 系统中，它是多用户操作系统，所以会有多个用户使用同一个操作系统。这时，我们就要对这些用户进行相应管理了。在 Liunx 系统中，用户分为 root 用户 和 普通用户 。root 用户可以操作系统的一切，而普通用户只能使用被分配的权限，不能进行危害系统的操作。 用户与用户组相关命令123456789101112131415useradd Tom # 新建 Tom 用户id Tom # 判断系统是否有这个用户passwd Tom # 为 Tom 用户设置密码passwd root # 修改 root 用户密码userdel Tom # 删除 Tom 用户，这样删除的话，用户的家目录会被保存，不会被删除。这样子可以防止删除用户的同时不会把数据给删了userdel -r Tom # 彻底删除 Tom 用户，家目录也会被删除usermod -d /home/a2 a1 # -d 表示修改用户家目录位置。这条命令就是把原来 a1 位置移到了 a2 位置，相当于此用户搬了一次家chage # 对用户的生命周期进行设置groupadd group01 # 新建 group01 用户组usermod -g group01 Tom # 把 Tom 的用户组改为 group01useradd -g group01 Tom # 新建 Tom 用户并加入到 group01 用户组 新建用户新建一个用户之后，Linux 系统会做哪些事情呢？首先： 会给用户分配一个家目录，位置在 /home/用户名 。第二： 用户还会被记录到 etc/passwd 文件当中，如下图。只要包含 Tom 这一行，就说明有这个用户存在。第三： 用户还会被记录到 /etc/shadow 文件当中,这是与用户密码相关的文件。图片如下： 温馨小提示：1、如果创建用户时没有指定组，那么系统就会创建和用户同名的组。2、root 用户才有权限创建用户，普通用户没有此权限。 删除用户123userdel Tom # 删除用户，但是保留了家目录和邮箱命令userdel -r Tom # 彻底删除用户，清空用户数据userdel -f Tom # 强制删除用户，但是保留了家目录和邮箱命令 若使用 userdel Tom 命令删除该用户时，并不能删除该用户的所有信息，只是删除了 /etc/passwd、/etc/shadow、/etc/group/、/etc/gshadow 四个文件里的该账户和组的信息。默认情况下。我们创建了一个用户账号，同时也会创建一个家目录和一个用户邮箱，位置在 /var/spool/mail 目录以用户名命名。 修改用户使用 usermod 命令 和 chage 命令 用户信息和用户的生命周期修改以及用户密码相关操作等等进行修改。如下图： 12usermod # 可用来修改用户帐户的各项设定chage # 修改帐号和密码的有效期限！ tips： 详情参考他人博客 新建用户组如果有三个用户，他们需要相同的权限，或者是希望操作相同的文件时，然而我们并不想对每一个用户单独设置，那该怎么办？我们就把他们加入到一个用户组，这样他们就有了相同的权限，也方便我们对一类用户进行管理。 123groupadd group02 # 新建 group02 用户组usermod -g group02 user1 # 把 user1 的用户组改为 group02useradd -g group02 Lisa # 新建 Lisa 用户并加入到 group02 用户组 用户切换 su 和 sudo 有的时候我们需要临时将用户身份变一下，该怎么办呢？举个例子：我们想测试一下普通用户对某一个目录是否具有权限，当前用户是 root 用户，那该怎么办？当然，我们可以退出 root 用户，然后登陆该普通用户，但是这样很麻烦。有没有更简单的方法呢？当然有，如下： 12su - user1 # - 的作用就是切换用户的同时，并把当前运行环境变更为 user1 的环境su user1 # 不带减号，不完全切换，环境带不过去，还在 root 目录下 温馨小提示： 1、root 用户到普通用户，不需要输入密码。2、普通用户切换到普通用户，要输入密码。3、普通用户到 root 用户，要输入密码。 有时候，普通用户想使用命令行关机，但是权限不足，需要切换到 root 用户。这样的话，root 用户的密码就暴露了，普通用户可以拿着密码 干点坏事 。那么如何让普通用户关机且不给 root 密码呢？这么做，如下： 1234567891011121314151617181920# root 用户模式下新建用户useradd user03shutdown -h 30 # 30 分钟关机# 切换到普通用户模式su - user03shutdown -c # 停止关机操作，此时是 user03 普通用户，会提示权限不足# 如果我一定要 user03 执行这条命令呢，该怎么办？# 1、把 root 用户密码告知 user03 ，但是这样做不安全，万一它拿着密码干坏事呢？# 2、使用 sudo 命令，给 user03 设置密码，然后给他分配 停止关机操作的权限，接下来就操作一下吧# 给 user03 设置密码，此时在 root 用户模式下，只有root 模式才可以对用户进行相关操作passwd user03 # 输入自己密码即可，密码是看不到的visudo # 如果不知道要授予权限的命令位置在哪里，就是用 :!which 相关命令:!which shutdown# 注意：字符终端使用 localhost ， 图形终端使用 ALL 用户和用户组配置12345678910111213141516171819202122232425262728293031# /etc/passwd 用户的配置文件，分为七个字段# 第一个字段： 用户名称 如：root# 第二个字段： 是否需要密码 如 X 代表要，删除即不需要，就算是登陆的时候以及其他操作不需要密码# 第三个字段： 用户 uid ，Linux 系统中，不是靠 用户名称识别用户，而是靠用户的 uid 识别。 如果 uid 是 0 的话，那就具有 root 权限了。# 第四个字段： 用户 gid ，用户组相关# 第五个字段： 这个字段是注释，为空，啥都没有# 第六个字段： 用户家目录所在位置# 第七个字段： 用户命令解释器。就是当这个用户登陆之后，使用哪个解释器来解释相关命令。一般都是：/bin/bash ，如果是 /sbin/nologin ，则代表此用户无法登陆vim /etc/passwd# 我们不使用 useradd 新建用户了，来点高级的，如下user04:x:1005:1005::/home/user04:/bin/bash# 接下来使用 user04 登陆系统su - user04 # 发现提示没有家目录，然后命令提示符为：-bash# /etc/shadow 保存用户和用户密码相关的文件# 第一个字段：用户名称，如：root# 第二个字段：加密过的密码， 如 $sfdklasjfkjjf$，随便写的，自己可以编辑 shadow 文件看一下就知道了。即使用户密码相同，显示的也是不同的字符串vim /etc/shadow# /etc/group 用户组相关配置文件# 第一个字段：组的名称# 第二个字段：是否需要密码# 第三个字段：组的 gid ，很重要# 第四个字段：其他组设置，一般很少用，如：mail 组下的 postfix 用户。如果 A 用户 属于 A 组，他也想属于 B 组，那就在 B 组的第四个字段 写上 A，即写用户名称。这样 A 用户就同时属于 A 主和 B 组了。vim /etc/group vim /etc/passwd 的内容如下： vim /etc/shadow 的内容如下： vim /etc/group 的内容如下： 文件与目录权限文件与目录权限介绍 12345678910111213drwxr-xr-x. 2 root root 6 4月 22 10:37 桌面-rw-------. 1 root root 1486 4月 22 17:56 anaconda-ks.cfg-rw-r--r--. 1 root root 1641 4月 22 17:59 initial-setup-ks.cfg# 分析上面三行前 10 个字符的含义# 第一个字符：如果是 d ，则代表这个一个目录，如第一行的，桌面就是一个目录。如果是 - ， 则代表是文件，如第二三行# 第 2~4 个字符： 代表创建这个文件的用户所具有的操作权限# 第 5~7 个字符： 代表创建这个文件的用户所在的用户组所具有的操作权限# 第 8~10 个字符： 代表其他用户所具有的操作权限# 解释 r w x 是是什么意思：r 代表可读，w 代表可写，x 代表可执行# 第一个 root 代表创建这个文件或者文件夹的用户# 第二个 root 代表用户当时创建此文件或文件夹所属的用户组 文件权限修改 1234567891011121314151617181920212223242526272829303132333435363738394041# 方便演示，新建一个目录mkdir /test# 查看 test 目录的权限。注意：这是 root 用户创建的目录ls -ld /test# 注意一下： 权限只是针对于非 root 用户，root 用户啥都能干，管你权限不权限# 改变 test 目录的属主chown user04 /testls -ld /test# 使用 chown 命令改变 test 目录的属组chown :group01 /testls -ld /test# 使用 chgrp 命令改变 test 目录的属组chgrp group02 /testls -ld /test# 修改文件权限操作： chmod u g o a + - =cd /test # 进入到 test 目录ls # 查看是否有文件。我们还没创建呢，哪来文件，哈哈哈touch afile # 在 test 目录下创建 afile 文件ls -l afile # 查看 afile 的相关权限chmod u+x afile # 给属主增加执行权限【就是第 2~4 个字符】，u 代表属主，+ 代表增加，- 代表减少，x 代表执行【前面有介绍】chmod g-r afile # 给属组减少读的权限【就是第 5~7 个字符】，g 代表属组chmod o=rwx afile # 给其他用户设置 rwx 权限【就是第 8~10 个字符】，o 代表其他用户ls -l afile # 查看设置过后的权限，进行对比一下chomd a+r afile # 给所有用户及用户组添加 r 权限，a 代表所有chmod 446 afile # 数字设置权限的方式，代表 属主只读-属组只读-其他用户可读写 权限。 r=4 w=2 x=1ls -l afile # 结果：-r--r--rw-. 1 root root 0 5月 15 01:40 afiletouch bfile # 创建 bfile 文件ls # 查看它的默认权限 666 - umask = 666 - 022 = 644umask # 默认权限本来是 666 ，但是要减去 umask 的值，所以是 644 。umask 的值是 0022 TIPS： 使用 CTRL + R 可以查找使用过的命令，非常使用哦！ 各个权限的功能1234567891011121314151617181920212223# 还是以上面的 /test 作为例子chmod 777 /test # 给所有用户及用户组所有权限。ls -ld /test # 此刻发现，test 目录有背景颜色，什么情况我也不知道，哈哈哈touch cfilels -l cfilechown user1:group01 cfile # 同时修改 cfile 文件的属主和属组ls -l cfilechmod 400 cfile # 只给属主只读权限【为了方便测试，设置为 400 ，减少干扰】echo 123 &gt; cfile # 把 123 显示到 cfile 中。这个操作是先把 cfile 里面的内容先清空，然后写入 123 。所有操心系统文件是这个命令慎用！！！# 此时切换到用户 user1 测试权限su - user1cat /test/cfile # 可以读出内容为 123echo &gt; 456 /test/cfile # 报错了，权限不足，无法写入 456。因为 user1 用户对这个文件只有读权限，没有写权限exit # 退出当前用户，如果需要修改 cfile 其他权限，就要到 root 用户下修改，普通用户没有权限去操作# 一个权限冲突问题chmod 020 /test/cfile # 此时属主没有任何权限，属组具有写的权限，但是属主又在属组中，那么属主是否有写的权限呢？所以出现了权限冲突。提示：以属主权限设置为准，所以属主没有写的权限，属组中，除了属主之外的用户才有写的权限。# 到此为止，文件权限就说完了，接下来的目录权限原理是一样的，就不演示了，参考上图 x rx wx 自己操作即可。wx 具有删除文件的功能。 特殊权限 特别提示： root 用户 有特权，即使没有权限也可以查看。就是这么拽，哈哈哈！！！ 如何增加特殊权限呢？看下图： Liunx 全屏问题以后再弄 以后再弄 以后再弄 如何设置 VMware 中 Linux 命令行环境全屏 在VMware安装Linux后默认屏幕为640×480，如需修改，则请参考以下步骤。 工具原料 VMware Workstation CentOS 6.6 ##第一步：进入命令行 登录账户后，输入 ls /dev 命令并按回车。注意：输入此命令只是为比较显示结果。如下图： 第二步：设置 GRUB 输入 vi /etc/default/grub.conf 并按回车键确定。然后查询到以“kernel”开头行。按“i”键进入编辑状态，并在“rhgb”前添加“vga=791”（下图蓝色框内部分）,确认无误后按ESC到命令模式，并输入“:x”保存退出。 注意：此处“791”为十进制数字。 输入“reboot”重新启动。 重启登录后再次输入“ls /dev”，对比显示结果。 常用参数列表。 vga=769 (640x480x256) vga=771 (800x600x256) vga=788 (800x600x645536） vga=773 (1024x768x256) vga=791 (1024x768x65536)在 /boot/grub/menu.lst 的内核命令后加上 vga=nnn （nnn为整数）参数可以使用高分辨率的命令行界面。其值如下。 640x480 800x600 1024x768 1280x10248bit 769 771 773 77515bit 784 787 790 79316bit 785 788 791 79424bit 786 789 792 795","link":"/Linux.html"},{"title":"Mybatis 入门教程","text":"mybatis 的入门 特别提示： mybatis 官方教程：https://mybatis.org/mybatis-3/zh/index.html) 既然要学习框架，那就要知道 什么是框架 。框架 是我们软件开发中的 一套解决方案 ，相当于一个半成品软件，不同的框架解决的是不同的问题。使用框架的好处 ：框架封装了很多的细节，使开发者可以使用极简的方式实现功能，大大提高开发效率 。 mybatis 的概述mybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者 只需要关注 sql 语句本身 ，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 它通过 xml 或 注解 的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回 。 该框架采用 ORM 思想 解决了 实体和数据库映射的问题 ，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。这里解释一下 ORM 。 ORM 是 Object Relational Mappging 对象关系映射 的缩写，它的功能就是 把数据库表和实体类及实体类的属性对应起来 ，让我们可以操作实体类就实现操作数据库表。 mybatis 属于持久层框架 ，在三层架构中的位置如下： mybatis 的环境搭建第一步： 先创建一个数据库 ，然后把以下 数据表 创建好，复制代码执行即可 ，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL auto_increment, `username` varchar(32) NOT NULL COMMENT '用户名称', `birthday` datetime default NULL COMMENT '生日', `sex` char(1) default NULL COMMENT '性别', `address` varchar(256) default NULL COMMENT '地址', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (41,'老王','2018-02-27 17:47:08','男','北京'),(42,'小二王','2018-03-02 15:09:37','女','北京金燕龙'),(43,'小二王','2018-03-04 11:34:34','女','北京金燕龙'),(45,'传智播客','2018-03-04 12:04:06','男','北京金燕龙'),(46,'老王','2018-03-07 17:37:26','男','北京'),(48,'小马宝莉','2018-03-08 11:44:00','女','北京修正');DROP TABLE IF EXISTS `account`;CREATE TABLE `account` ( `ID` int(11) NOT NULL COMMENT '编号', `UID` int(11) default NULL COMMENT '用户编号', `MONEY` double default NULL COMMENT '金额', PRIMARY KEY (`ID`), KEY `FK_Reference_8` (`UID`), CONSTRAINT `FK_Reference_8` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `account`(`ID`,`UID`,`MONEY`) values (1,41,1000),(2,45,1000),(3,41,2000);DROP TABLE IF EXISTS `role`;CREATE TABLE `role` ( `ID` int(11) NOT NULL COMMENT '编号', `ROLE_NAME` varchar(30) default NULL COMMENT '角色名称', `ROLE_DESC` varchar(60) default NULL COMMENT '角色描述', PRIMARY KEY (`ID`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `role`(`ID`,`ROLE_NAME`,`ROLE_DESC`) values (1,'院长','管理整个学院'),(2,'总裁','管理整个公司'),(3,'校长','管理整个学校');DROP TABLE IF EXISTS `user_role`;CREATE TABLE `user_role` ( `UID` int(11) NOT NULL COMMENT '用户编号', `RID` int(11) NOT NULL COMMENT '角色编号', PRIMARY KEY (`UID`,`RID`), KEY `FK_Reference_10` (`RID`), CONSTRAINT `FK_Reference_10` FOREIGN KEY (`RID`) REFERENCES `role` (`ID`), CONSTRAINT `FK_Reference_9` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `user_role`(`UID`,`RID`) values (41,1),(45,1),(41,2); 第二步： 创建一个 maven 工程 ，以图的方式展示创建过程，如下： 第三步： 导入相关依赖 。打开 pom.xml 文件，把以下 代码中的 &lt;dependencies&gt; 依赖部分 复制进去即可【打包方式顺便加上】。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;club.guoshizhan&lt;/groupId&gt; &lt;artifactId&gt;mybatis-01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- mybatis 依赖，必须要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql 数据库驱动依赖，必须要 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 日志依赖，不是一定要 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 测试依赖，不是一定要 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 第四步： 建立包结构 。如下图： 第五步： 在 club/guoshizhan/domain 包下新建 User 类 ，和数据库中的 user 表 相映射。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package club.guoshizhan.domain;import java.io.Serializable;import java.util.Date;/** * @Author: guoshizhan * @Create: 2020/6/22 23:52 * @Description: User 实体类 */public class User implements Serializable { private Integer id; private String username; private Date birthday; private String sex; private String address; @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", birthday=\" + birthday + \", sex='\" + sex + '\\'' + \", address='\" + address + '\\'' + '}'; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; }} 第六步： 在 club/guoshizhan/dao 包下新建 IUserDao 接口 ，然后定义方法，用于对 user 表 的增删改查。代码如下： 1234567891011121314151617package club.guoshizhan.dao;import club.guoshizhan.domain.User;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/6/22 23:53 * @Description: 用户持久层接口 */public interface IUserDao { // 查询所有用户 List&lt;User&gt; findAll();} 第七步： 在 resources 目录 下新建 SqlMapConfig.xml 文件【文件名随意取，不一定是 SqlMapConfig】。这是 mybatis 的主配置文件，各种配置都写好了对应的注释 。代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!-- 01-mybatis 的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 02-配置 mybatis 的环境，default 属性的值随便写，写完之后，下面 id 的值必须和 default 的值一样 --&gt; &lt;environments default=\"mysql\"&gt; &lt;!-- 03-配置 mysql 的环境 --&gt; &lt;environment id=\"mysql\"&gt; &lt;!-- 04-配置事务的类型，type 先写 JDBC ，其他的以后说 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!-- 05-配置连接数据库的信息：用的是数据源(连接池) --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/eesy_mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 06-指定 mybatis 映射配置的位置，即从 resources/club/guoshizhan/dao/ 包下找 IUserDao.xml 文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"club/guoshizhan/dao/IUserDao.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 第八步： 编写 IUserDao.xml 文件 。在 resources 目录下新建 club 目录，然后在 club 目录下新建 guoshizhan 目录，最后在 guoshizhan 目录下 新建 dao 目录。然后在 dao目录下新建 IUserDao.xml 文件 ，代码如下： IUserDao.xml123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- 01-持久层映射配置中，mapper 标签的 namespace 属性取值必须是持久层接口的全限定类名 --&gt;&lt;mapper namespace=\"club.guoshizhan.dao.IUserDao\"&gt; &lt;!-- 02-查询所有用户：resultType 很重要，是查询结果的封装位置，不写会报错，表示 mybatis 框架不知道把结果往哪里封装 --&gt; &lt;!-- 03-属性 id 不能随便写，必须是接口中方法的名称 --&gt; &lt;select id=\"findAll\" resultType=\"club.guoshizhan.domain.User\"&gt; select * from user; &lt;/select&gt;&lt;/mapper&gt; mybatis 环境搭建到此结束，搭建好之后的目录结构 如下： mybatis 环境搭建的注意事项： 1、在 Mybatis 中，持久层的操作接口名称和映射文件也叫做 Mapper 。所以 IUserDao 和 IUserMapper 是一样的。建议使用 IUserMapper 。 2、在 IDEA 中创建目录的时候，它和包的创建是不一样的。包在创建时： club.guoshizhan.dao 是三级结构，目录在创建时： club.guoshizhan.dao 是一级目录。 3、mybatis 的映射配置文件 IUserDao.xml 的位置必须和 dao 接口的包结构相同。 4、映射配置文件的 mapper 标签 namespace 属性的取值必须是 dao 接口的全限定类名。 5、映射配置文件的操作配置（select），id 属性的取值必须是 dao 接口的方法名。 6、当遵从了第三，四，五点之后，我们在开发中就无须再写 dao 的实现类，即简化了开发。 mybatis 的入门案例第一步： 在 resources 目录下 新建 log4j.properties 日志文件 ，用于打印日志【也可以不写，不写就看不到出错的地方，建议加上】。代码如下： log4j.properties123456789101112131415161718# Set root category priority to INFO and its only appender to CONSOLE.#log4j.rootCategory=INFO, CONSOLE debug info warn error fatallog4j.rootCategory=debug, CONSOLE, LOGFILE# Set the enterprise logger category to FATAL and its only appender to CONSOLE.log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE# CONSOLE is set to be a ConsoleAppender using a PatternLayout.log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n# LOGFILE is set to be a File appender using a PatternLayout.log4j.appender.LOGFILE=org.apache.log4j.FileAppenderlog4j.appender.LOGFILE.File=d:\\axis.loglog4j.appender.LOGFILE.Append=truelog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n 第二步： 在 test/java 目录下 新建 club.guoshizhan.Test.MybatisTest 类，这样写的目的就是让 IDEA 自动生成三级包结构。然后编写 MybatisTest 类 ，代码如下： MybatisTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445package club.guoshizhan.Test;import club.guoshizhan.dao.IUserDao;import club.guoshizhan.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/6/23 11:03 * @Description: Mybatis 测试类 */public class MybatisTest { public static void main(String[] args) throws Exception { // 01-读取 mybatis 主配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 02-创建 SqlSessionFactory 工厂 ，SqlSessionFactory 是一个接口，不能 new 对象，所以使用它的实现类 SqlSessionFactoryBuilder 来创建对象 SqlSessionFactoryBuilder factory = new SqlSessionFactoryBuilder(); SqlSessionFactory build = factory.build(in); // 03-使用上面创建的工厂来生产 SqlSession 对象，SqlSession 的作用是创建 Dao 接口的代理对象 SqlSession session = build.openSession(); // 04-使用 SqlSession 创建 Dao 接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); // 05-使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) { System.out.println(user); } // 06-关闭资源 session.close(); in.close(); }} 第三步： 运行 main 方法，结果如下： mybatis 入门案例到此结束，最终的目录结构和入门案例分析 如下： mybatis 注解案例第一步： 创建一个 maven 工程 ，以图的方式展示创建过程，如下： 第二步： 导入相关依赖 。打开 pom.xml 文件，把以下 代码中的 &lt;dependencies&gt; 依赖部分 复制进去即可【打包方式顺便加上】。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;club.guoshizhan&lt;/groupId&gt; &lt;artifactId&gt;mybatis-02&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包方式使用 jar --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- mybatis 依赖，必须要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql 数据库驱动依赖，必须要 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 日志依赖，不是一定要 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 测试依赖，不是一定要 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 第三步： 建立包结构 。如下图： 第四步： 在 club/guoshizhan/domain 包下新建 User 类 ，和数据库中的 user 表 相映射。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package club.guoshizhan.domain;import java.io.Serializable;import java.util.Date;/** * @Author: guoshizhan * @Create: 2020/6/22 23:52 * @Description: User 实体类 */public class User implements Serializable { private Integer id; private String username; private Date birthday; private String sex; private String address; @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", birthday=\" + birthday + \", sex='\" + sex + '\\'' + \", address='\" + address + '\\'' + '}'; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; }} 第五步： 在 club/guoshizhan/dao 包下新建 IUserDao 接口 ，然后定义方法，用于对 user 表 的增删改查 【此处代码可是用到了注解哦】 。代码如下： 12345678910111213141516171819package club.guoshizhan.dao;import club.guoshizhan.domain.User;import org.apache.ibatis.annotations.Select;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/6/22 23:53 * @Description: 用户持久层接口 */public interface IUserDao { // 查询所有用户，此处使用的是注解的方式 @Select(\"select * from user\") List&lt;User&gt; findAll();} 第六步： 在 resources 目录 下新建 SqlMapConfig.xml 主配置文件，各种配置都写好了对应的注释【注意对比注释 06 和原先 xml 配置的区别】 。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!-- 01-mybatis 的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 02-配置 mybatis 的环境，default 属性的值随便写，写完之后，下面 id 的值必须和 default 的值一样 --&gt; &lt;environments default=\"mysql\"&gt; &lt;!-- 03-配置 mysql 的环境 --&gt; &lt;environment id=\"mysql\"&gt; &lt;!-- 04-配置事务的类型，type 先写 JDBC ，其他的以后说 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!-- 05-配置连接数据库的信息：用的是数据源(连接池) --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/eesy_mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 06-指定 mybatis 映射配置的位置，即从 resources/club/guoshizhan/dao/ 包下找 IUserDao.xml 文件 &lt;mappers&gt; &lt;mapper resource=\"club/guoshizhan/dao/IUserDao.xml\"/&gt; &lt;/mappers&gt; --&gt; &lt;!-- 06-如果使用注解的方式，那么此处应该使用 class 属性指定被注解的 Dao 的全限定类名 --&gt; &lt;mappers&gt; &lt;mapper class=\"club.guoshizhan.dao.IUserDao\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 第七步： 在 resources 目录下 新建 log4j.properties 日志文件 ，用于打印日志。代码如下： log4j.properties123456789101112131415161718# Set root category priority to INFO and its only appender to CONSOLE.#log4j.rootCategory=INFO, CONSOLE debug info warn error fatallog4j.rootCategory=debug, CONSOLE, LOGFILE# Set the enterprise logger category to FATAL and its only appender to CONSOLE.log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE# CONSOLE is set to be a ConsoleAppender using a PatternLayout.log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n# LOGFILE is set to be a File appender using a PatternLayout.log4j.appender.LOGFILE=org.apache.log4j.FileAppenderlog4j.appender.LOGFILE.File=d:\\axis.loglog4j.appender.LOGFILE.Append=truelog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n 第八步： 在 test/java 目录下 新建 club.guoshizhan.Test.MybatisTest 类，这样写的目的就是让 IDEA 自动生成三级包结构。然后编写 MybatisTest 类 ，代码如下： MybatisTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445package club.guoshizhan.Test;import club.guoshizhan.dao.IUserDao;import club.guoshizhan.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/6/23 11:03 * @Description: Mybatis 测试类 */public class MybatisTest { public static void main(String[] args) throws Exception { // 01-读取 mybatis 主配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 02-创建 SqlSessionFactory 工厂 ，SqlSessionFactory 是一个接口，不能 new 对象，所以使用它的实现类 SqlSessionFactoryBuilder 来创建对象 SqlSessionFactoryBuilder factory = new SqlSessionFactoryBuilder(); SqlSessionFactory build = factory.build(in); // 03-使用上面创建的工厂来生产 SqlSession 对象，SqlSession 的作用是创建 Dao 接口的代理对象 SqlSession session = build.openSession(); // 04-使用 SqlSession 创建 Dao 接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); // 05-使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) { System.out.println(user); } // 06-关闭资源 session.close(); in.close(); }} 第九步： 运行 MybatisTest 测试类中的 main 方法，结果如下： 注解使用总结： 1、把 IUserDao.xml 移除，在 dao 接口中的方法上使用 @Select 注解，并且指定 SQL 语句。2、同时需要在 SqlMapConfig.xml 中的 mapper 配置时，使用 class 属性指定 dao 接口的全限定类名。 自定义 mybatis 框架 第一步： 创建一个 Maven 工程。这里就不新创建了。具体创建可参考上一小节： mybatis 注解案例 。 第二步： 导入相关依赖 。打开 pom.xml 文件，复制如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;club.guoshizhan&lt;/groupId&gt; &lt;artifactId&gt;mybatis-03&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- mybatis 依赖，这个依赖注释掉或删掉，因为我们要自己定义一个 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; --&gt; &lt;!-- mysql 数据库驱动依赖，必须要 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 日志依赖，不是一定要 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 测试依赖，不是一定要 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 用于解析 XML ，必须要 --&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 与 xpath 相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 第三步： 删除工程中的 src 目录 。 然后把以下压缩文件里的 src 目录 复制到工程中。做这一步的原因主要是不想再去重复创建上面几个小结的步骤，也是为了节省时间。代码都是看的懂的。压缩包点击即可下载： src 目录文件的压缩包 复制完成之后的工程截图如下： 第四步： 在 guoshizhan 包 下新建 mybatis 包 ，然后在 mybatis 包中新建 Resources 类 。该类的代码如下： Resources.java1234567891011121314151617package club.guoshizhan.mybatis;import java.io.InputStream;/** * @Author: guoshizhan * @Create: 2020/7/8 0:38 * @Description: 使用类加载器读取配置文件的类 */public class Resources { // 根据传入的参数，获取一个字节输入流 public static InputStream getResourceAsStream(String filePath) { return Resources.class.getClassLoader().getResourceAsStream(filePath); }} 接着在 mybatis 包 下新建 SqlSession 接口 ，该接口的代码如下： SqlSession.java12345678910111213141516package club.guoshizhan.mybatis;/** * @Author: guoshizhan * @Create: 2020/7/8 0:52 * @Description: 自定义 SqlSession 接口，这是和数据库交互的核心接口，它里面可以创建 dao 接口的代理对象 */public interface SqlSession { // 根据 dao 接口的字节码创建一个代理对象 &lt;T&gt; T getMapper(Class&lt;T&gt; daoInterfaceClass); // 释放资源 void close();} 然后在 mybatis 包 下新建 SqlSessionFactory 接口 ，该接口的代码如下： SqlSessionFactory.java12345678910111213package club.guoshizhan.mybatis;/** * @Author: guoshizhan * @Create: 2020/7/8 0:47 * @Description: 自定义 SqlSessionFactory 接口 */public interface SqlSessionFactory { // 用于打开一个新的 SqpSession 对象 SqlSession openSession();} 最后在 mybatis 包 下新建 SqlSessionFactoryBuilder 类 ，该类初始代码如下【后面还需完善】： SqlSessionFactoryBuilder.java12345678910111213141516package club.guoshizhan.mybatis;import java.io.InputStream;/** * @Author: guoshizhan * @Create: 2020/7/8 0:45 * @Description: 自定义 SqlSessionFactoryBuilder 类 */public class SqlSessionFactoryBuilder { public SqlSessionFactory build(InputStream config) { return null; }} 当类和接口创建好后，就去把 MybatisTest 测试类 中的报红问题解决。先删除无用的包，然后导入自定义的接口和类即可。最终 MybatisTest 测试类 代码和截图如下： MybatisTest.java1234567891011121314151617181920212223242526272829303132333435363738394041424344package club.guoshizhan.Test;import club.guoshizhan.dao.IUserDao;import club.guoshizhan.domain.User;import club.guoshizhan.mybatis.Resources;import club.guoshizhan.mybatis.SqlSession;import club.guoshizhan.mybatis.SqlSessionFactory;import club.guoshizhan.mybatis.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/6/23 11:03 * @Description: Mybatis 测试类 */public class MybatisTest { public static void main(String[] args) throws Exception { // 01-读取配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 02-创建 SqlSessionFactory 工厂 ，SqlSessionFactory 是一个接口，不能 new 对象 SqlSessionFactoryBuilder factory = new SqlSessionFactoryBuilder(); SqlSessionFactory build = factory.build(in); // 03-使用工厂生产 SqlSession 对象 SqlSession session = build.openSession(); // 04-使用 SqlSession 创建 Dao 接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); // 05-使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) { System.out.println(user); } // 06-关闭资源 session.close(); in.close(); }} 第五步： 解析 XML 配置文件 。首先在 mybatis 包 下新建 Configuration 配置类 ，该类的代码如下： Configuration.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package club.guoshizhan.mybatis;import java.util.HashMap;import java.util.Map;/** * @Author: guoshizhan * @Create: 2020/7/8 10:08 * @Description: 自定义 mybatis 的配置类 */public class Configuration { private String driver; private String url; private String username; private String password; private Map&lt;String, Mapper&gt; mappers = new HashMap&lt;&gt;(); public Map&lt;String, Mapper&gt; getMappers() { return mappers; } public void setMappers(Map&lt;String, Mapper&gt; mappers) { this.mappers.putAll(mappers); // 采用追加方式，而不是覆盖【this.mappers = mappers】 } public String getDriver() { return driver; } public void setDriver(String driver) { this.driver = driver; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; }} 然后在 mybatis 包 下新建 Mapper 类 ，该类的代码如下： Mapper.java1234567891011121314151617181920212223242526272829package club.guoshizhan.mybatis;/** * @Author: guoshizhan * @Create: 2020/7/8 10:12 * @Description: 用于封装执行的 SQL 语句和结果类型的全限定类名 */public class Mapper { private String queryString; // SQL private String resultType; // 实体类的全限定类名 public String getQueryString() { return queryString; } public void setQueryString(String queryString) { this.queryString = queryString; } public String getResultType() { return resultType; } public void setResultType(String resultType) { this.resultType = resultType; }} 最后在 mybatis 包 下新建 XMLConfigBuilder 类 用于解析 xml 文件 。该类的代码如下： XMLConfigBuilder.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202package club.guoshizhan.mybatis;import org.dom4j.Attribute;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.io.IOException;import java.io.InputStream;import java.util.HashMap;import java.util.List;import java.util.Map;public class XMLConfigBuilder { /** * 解析主配置文件，把里面的内容填充到DefaultSqlSession所需要的地方 * 使用的技术：dom4j + xpath */ public static Configuration loadConfiguration(InputStream config) { try { // 定义封装连接信息的配置对象（mybatis的配置对象） Configuration cfg = new Configuration(); // 1.获取 SAXReader 对象 SAXReader reader = new SAXReader(); // 2.根据字节输入流获取 Document 对象 Document document = reader.read(config); // 3.获取根节点 Element root = document.getRootElement(); // 4.使用 xpath 中选择指定节点的方式，获取所有 property 节点 List&lt;Element&gt; propertyElements = root.selectNodes(\"//property\"); // 5.遍历节点 for (Element propertyElement : propertyElements) { //判断节点是连接数据库的哪部分信息 //取出name属性的值 String name = propertyElement.attributeValue(\"name\"); if (\"driver\".equals(name)) { //表示驱动 //获取property标签value属性的值 String driver = propertyElement.attributeValue(\"value\"); cfg.setDriver(driver); } if (\"url\".equals(name)) { //表示连接字符串 //获取property标签value属性的值 String url = propertyElement.attributeValue(\"value\"); cfg.setUrl(url); } if (\"username\".equals(name)) { //表示用户名 //获取property标签value属性的值 String username = propertyElement.attributeValue(\"value\"); cfg.setUsername(username); } if (\"password\".equals(name)) { // 表示密码 // 获取 property 标签 value 属性的值 String password = propertyElement.attributeValue(\"value\"); cfg.setPassword(password); } } // 取出 mappers 中的所有 mapper 标签，判断他们使用了 resource 还是 class 属性 List&lt;Element&gt; mapperElements = root.selectNodes(\"//mappers/mapper\"); // 遍历集合 for (Element mapperElement : mapperElements) { // 判断 mapperElement 使用的是哪个属性 Attribute attribute = mapperElement.attribute(\"resource\"); if (attribute != null) { System.out.println(\"使用的是 XML \"); // 表示有 resource 属性，用的是XML // 取出属性的值 String mapperPath = attribute.getValue(); // 获取属性的值\"club/guoshizhan/dao/IUserDao.xml\" // 把映射配置文件的内容获取出来，封装成一个 map Map&lt;String, Mapper&gt; mappers = loadMapperConfiguration(mapperPath); // 给 configuration 中的 mappers 赋值 cfg.setMappers(mappers); } else { /*System.out.println(\"使用的是注解\"); //表示没有resource属性，用的是注解 //获取class属性的值 String daoClassPath = mapperElement.attributeValue(\"class\"); //根据daoClassPath获取封装的必要信息 Map&lt;String, Mapper&gt; mappers = loadMapperAnnotation(daoClassPath); //给configuration中的mappers赋值 cfg.setMappers(mappers);*/ } } // 返回 Configuration return cfg; } catch (Exception e) { throw new RuntimeException(e); } finally { try { config.close(); } catch (Exception e) { e.printStackTrace(); } } } /** * 根据传入的参数，解析XML，并且封装到Map中 * * @param mapperPath 映射配置文件的位置 * @return map中包含了获取的唯一标识（key是由dao的全限定类名和方法名组成） * 以及执行所需的必要信息（value是一个Mapper对象，里面存放的是执行的SQL语句和要封装的实体类全限定类名） */ private static Map&lt;String, Mapper&gt; loadMapperConfiguration(String mapperPath) throws IOException { InputStream in = null; try { // 定义返回值对象 Map&lt;String, Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); // 1.根据路径获取字节输入流 in = Resources.getResourceAsStream(mapperPath); // 2.根据字节输入流获取 Document 对象 SAXReader reader = new SAXReader(); Document document = reader.read(in); // 3.获取根节点 Element root = document.getRootElement(); // 4.获取根节点的 namespace 属性取值 String namespace = root.attributeValue(\"namespace\"); // 是组成 map 中 key 的部分 // 5.获取所有的 select 节点 List&lt;Element&gt; selectElements = root.selectNodes(\"//select\"); // 6.遍历 select 节点集合 for (Element selectElement : selectElements) { // 取出 id 属性的值【map 中 key 的部分】 String id = selectElement.attributeValue(\"id\"); // 取出 resultType 属性的值 组成map中value的部分 String resultType = selectElement.attributeValue(\"resultType\"); // 取出文本内容【map 中 value 的部分】 String queryString = selectElement.getText(); // 创建 Key String key = namespace + \".\" + id; // 创建 Value Mapper mapper = new Mapper(); mapper.setQueryString(queryString); mapper.setResultType(resultType); // 把 key 和 value 存入 mappers 中 mappers.put(key, mapper); } return mappers; } catch (Exception e) { throw new RuntimeException(e); } finally { in.close(); } } /** * 根据传入的参数，得到 dao 中所有被 select 注解标注的方法。 * 根据方法名称和类名，以及方法上注解 value 属性的值，组成 Mapper 的必要信息 */ /*private static Map&lt;String, Mapper&gt; loadMapperAnnotation(String daoClassPath) throws Exception { //定义返回值对象 Map&lt;String, Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); //1.得到dao接口的字节码对象 Class daoClass = Class.forName(daoClassPath); //2.得到dao接口中的方法数组 Method[] methods = daoClass.getMethods(); //3.遍历Method数组 for (Method method : methods) { //取出每一个方法，判断是否有select注解 boolean isAnnotated = method.isAnnotationPresent(Select.class); if (isAnnotated) { //创建Mapper对象 Mapper mapper = new Mapper(); //取出注解的value属性值 Select selectAnno = method.getAnnotation(Select.class); String queryString = selectAnno.value(); mapper.setQueryString(queryString); //获取当前方法的返回值，还要求必须带有泛型信息 Type type = method.getGenericReturnType();//List&lt;User&gt; //判断type是不是参数化的类型 if (type instanceof ParameterizedType) { //强转 ParameterizedType ptype = (ParameterizedType) type; //得到参数化类型中的实际类型参数 Type[] types = ptype.getActualTypeArguments(); //取出第一个 Class domainClass = (Class) types[0]; //获取domainClass的类名 String resultType = domainClass.getName(); //给Mapper赋值 mapper.setResultType(resultType); } //组装key的信息 //获取方法的名称 String methodName = method.getName(); String className = method.getDeclaringClass().getName(); String key = className + \".\" + methodName; //给map赋值 mappers.put(key, mapper); } } return mappers; }*/} 第六步： 编写工具类和代理类 。首先在 mybatis 包 下新建 DataSourceUtil 类 ，该类的代码如下： DataSourceUtil.java1234567891011121314151617181920212223package club.guoshizhan.mybatis;import java.sql.Connection;import java.sql.DriverManager;/** * @Author: guoshizhan * @Create: 2020/7/8 13:38 * @Description: 创建数据源的工具类 DataSourceUtil */public class DataSourceUtil { // 用于获取一个连接 public static Connection getConnection(Configuration cfg) { try { Class.forName(cfg.getDriver()); return DriverManager.getConnection(cfg.getUrl(), cfg.getUsername(), cfg.getPassword()); } catch (Exception e) { throw new RuntimeException(e); } }} 接着在 mybatis 包 下新建 Executor 类 ，该类的代码如下： Executor.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package club.guoshizhan.mybatis;import java.beans.PropertyDescriptor;import java.lang.reflect.Method;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.util.ArrayList;import java.util.List;public class Executor { public &lt;E&gt; List&lt;E&gt; selectList(Mapper mapper, Connection conn) { PreparedStatement pstm = null; ResultSet rs = null; try { // 1.取出 mapper 中的数据 String queryString = mapper.getQueryString(); // select * from user String resultType = mapper.getResultType(); Class domainClass = Class.forName(resultType); // 2.获取 PreparedStatement 对象 pstm = conn.prepareStatement(queryString); // 3.执行 SQL 语句，获取结果集 rs = pstm.executeQuery(); // 4.封装结果集 List&lt;E&gt; list = new ArrayList&lt;&gt;(); // 定义返回值 while (rs.next()) { // 实例化要封装的实体类对象 E obj = (E) domainClass.newInstance(); // 取出结果集的元信息：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 取出总列数 int columnCount = rsmd.getColumnCount(); // 遍历总列数 for (int i = 1; i &lt;= columnCount; i++) { // 获取每列的名称，列名的序号是从1开始的 String columnName = rsmd.getColumnName(i); // 根据得到列名，获取每列的值 Object columnValue = rs.getObject(columnName); // 给obj赋值：使用 Java 内省机制（借助 PropertyDescriptor 实现属性的封装） PropertyDescriptor pd = new PropertyDescriptor(columnName, domainClass); // 要求：实体类的属性和数据库表的列名保持一种 // 获取它的写入方法 Method writeMethod = pd.getWriteMethod(); // 把获取的列的值，给对象赋值 writeMethod.invoke(obj, columnValue); } // 把赋好值的对象加入到集合中 list.add(obj); } return list; } catch (Exception e) { throw new RuntimeException(e); } finally { release(pstm, rs); } } private void release(PreparedStatement pstm, ResultSet rs) { if (rs != null) { try { rs.close(); } catch (Exception e) { e.printStackTrace(); } } if (pstm != null) { try { pstm.close(); } catch (Exception e) { e.printStackTrace(); } } }} 最后在 mybatis 包 下新建 MapperProxy 类 ，该类的代码如下： MapperProxy.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package club.guoshizhan.mybatis;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.sql.Connection;import java.util.Map;/** * @Author: guoshizhan * @Create: 2020/7/8 13:21 * @Description: MapperProxy 代理类 */public class MapperProxy implements InvocationHandler { private Map&lt;String, Mapper&gt; mappers; private Connection connection; public MapperProxy(Map&lt;String, Mapper&gt; mappers, Connection connection) { this.mappers = mappers; this.connection = connection; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 1、获取方法名 String methodName = method.getName(); // 2、获取方法所在的类名称 String className = method.getDeclaringClass().getName(); // 3、组合 key String key = className + \".\" + methodName; // 4、获取 mappers 中的 Mapper 对象 Mapper mapper = mappers.get(key); // 5、判断是否有 mapper if (mapper == null) { throw new IllegalArgumentException(\"The args is wrong!!!\"); } // 6、调用工具类执行查询所有 return new Executor().selectList(mapper, connection); }} 第七步： 编写实现类 。首先在 mybatis 包 下新建 DefaultSqlSession 类 来实现 SqlSession 接口，该类的代码如下： DefaultSqlSession.java123456789101112131415161718192021222324252627282930313233343536373839package club.guoshizhan.mybatis;import java.lang.reflect.Proxy;import java.sql.Connection;/** * @Author: guoshizhan * @Create: 2020/7/8 10:52 * @Description: SqlSession 接口的实现类 */public class DefaultSqlSession implements SqlSession { private Configuration cfg; private Connection conn; public DefaultSqlSession(Configuration cfg) { this.cfg = cfg; conn = DataSourceUtil.getConnection(cfg); } // 用于创建代理对象 @Override public &lt;T&gt; T getMapper(Class&lt;T&gt; daoInterfaceClass) { return (T) Proxy.newProxyInstance(daoInterfaceClass.getClassLoader(), new Class[]{daoInterfaceClass}, new MapperProxy(cfg.getMappers(), conn)); } // 用于释放资源 @Override public void close() { if (conn != null) { try { conn.close(); } catch (Exception e) { e.printStackTrace(); } } }} 接着在 mybatis 包 下新建 DefaultSqlSessionFactory 类 来实现 SqlSessionFactory 接口，该类的代码如下： DefaultSqlSessionFactory.java12345678910111213141516171819202122package club.guoshizhan.mybatis;/** * @Author: guoshizhan * @Create: 2020/7/8 10:55 * @Description: SqlSessionFactory 接口的实现类 */public class DefaultSqlSessionFactory implements SqlSessionFactory { private Configuration cfg; public DefaultSqlSessionFactory(Configuration cfg) { this.cfg = cfg; } // 用于创建一个新的操作数据库对象 @Override public SqlSession openSession() { return new DefaultSqlSession(cfg); }} 最后继续编写 mybatis 包 下的 SqlSessionFactoryBuilder 类 【原先没有写完】，该类的代码如下： 123456789101112131415161718package club.guoshizhan.mybatis;import java.io.InputStream;/** * @Author: guoshizhan * @Create: 2020/7/8 0:45 * @Description: 自定义 SqlSessionFactoryBuilder 类，用于创建一个 SqlSessionFactory 对象 */public class SqlSessionFactoryBuilder { // 根据参数的字节输入流来构建一个 SqlSessionFactory 工厂 public SqlSessionFactory build(InputStream config) { Configuration cfg = XMLConfigBuilder.loadConfiguration(config); return new DefaultSqlSessionFactory(cfg); }} 最后一步： 运行 MybatisTest 测试类中的 main 方法 ，结果如下图： 附加功能： 自定义 mybatis 并支持注解 。第一步： 修改 IUserDao 接口【就是加一个 Select 注解】 。代码如下： IUserDao.java12345678910111213141516171819package club.guoshizhan.dao;import club.guoshizhan.domain.User;import club.guoshizhan.mybatis.Select;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/6/22 23:53 * @Description: 用户持久层接口 */public interface IUserDao { // 查询所有用户 @Select(\"select * from user\") List&lt;User&gt; findAll();} 第二步： 修改 SqlMapConfig.xml 配置文件中的 mapper 属性，将其改为 class 。代码如下： SqlMapConfig.xml1234&lt;!-- 06-使用注解的话，将 mapper 属性改为 class --&gt;&lt;mappers&gt; &lt;mapper class=\"club.guoshizhan.dao.IUserDao\"/&gt;&lt;/mappers&gt; 第三步： 新建 Select 注解类 。在 mybatis 包 下新建 Select 注解 。代码如下： Select.java1234567891011121314151617181920package club.guoshizhan.mybatis;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @Author: guoshizhan * @Create: 2020/7/8 15:10 * @Description: 自定义的 Select 注解 */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Select { // 配置 SQL 语句 String value();} 第四步： 修改 XMLConfigBuilder 类 。即把原先注释的部分放开【原先注解部分被注释掉了】 。代码如下： XMLConfigBuilder.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205package club.guoshizhan.mybatis;import org.dom4j.Attribute;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.HashMap;import java.util.List;import java.util.Map;public class XMLConfigBuilder { /** * 解析主配置文件，把里面的内容填充到DefaultSqlSession所需要的地方 * 使用的技术：dom4j + xpath */ public static Configuration loadConfiguration(InputStream config) { try { // 定义封装连接信息的配置对象（mybatis的配置对象） Configuration cfg = new Configuration(); // 1.获取 SAXReader 对象 SAXReader reader = new SAXReader(); // 2.根据字节输入流获取 Document 对象 Document document = reader.read(config); // 3.获取根节点 Element root = document.getRootElement(); // 4.使用 xpath 中选择指定节点的方式，获取所有 property 节点 List&lt;Element&gt; propertyElements = root.selectNodes(\"//property\"); // 5.遍历节点 for (Element propertyElement : propertyElements) { //判断节点是连接数据库的哪部分信息 //取出name属性的值 String name = propertyElement.attributeValue(\"name\"); if (\"driver\".equals(name)) { //表示驱动 //获取property标签value属性的值 String driver = propertyElement.attributeValue(\"value\"); cfg.setDriver(driver); } if (\"url\".equals(name)) { //表示连接字符串 //获取property标签value属性的值 String url = propertyElement.attributeValue(\"value\"); cfg.setUrl(url); } if (\"username\".equals(name)) { //表示用户名 //获取property标签value属性的值 String username = propertyElement.attributeValue(\"value\"); cfg.setUsername(username); } if (\"password\".equals(name)) { // 表示密码 // 获取 property 标签 value 属性的值 String password = propertyElement.attributeValue(\"value\"); cfg.setPassword(password); } } // 取出 mappers 中的所有 mapper 标签，判断他们使用了 resource 还是 class 属性 List&lt;Element&gt; mapperElements = root.selectNodes(\"//mappers/mapper\"); // 遍历集合 for (Element mapperElement : mapperElements) { // 判断 mapperElement 使用的是哪个属性 Attribute attribute = mapperElement.attribute(\"resource\"); if (attribute != null) { System.out.println(\"使用的是 XML \"); // 表示有 resource 属性，用的是XML // 取出属性的值 String mapperPath = attribute.getValue(); // 获取属性的值\"club/guoshizhan/dao/IUserDao.xml\" // 把映射配置文件的内容获取出来，封装成一个 map Map&lt;String, Mapper&gt; mappers = loadMapperConfiguration(mapperPath); // 给 configuration 中的 mappers 赋值 cfg.setMappers(mappers); } else { System.out.println(\"使用的是注解\"); //表示没有resource属性，用的是注解 //获取class属性的值 String daoClassPath = mapperElement.attributeValue(\"class\"); //根据daoClassPath获取封装的必要信息 Map&lt;String, Mapper&gt; mappers = loadMapperAnnotation(daoClassPath); //给configuration中的mappers赋值 cfg.setMappers(mappers); } } // 返回 Configuration return cfg; } catch (Exception e) { throw new RuntimeException(e); } finally { try { config.close(); } catch (Exception e) { e.printStackTrace(); } } } /** * 根据传入的参数，解析XML，并且封装到Map中 * * @param mapperPath 映射配置文件的位置 * @return map中包含了获取的唯一标识（key是由dao的全限定类名和方法名组成） * 以及执行所需的必要信息（value是一个Mapper对象，里面存放的是执行的SQL语句和要封装的实体类全限定类名） */ private static Map&lt;String, Mapper&gt; loadMapperConfiguration(String mapperPath) throws IOException { InputStream in = null; try { // 定义返回值对象 Map&lt;String, Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); // 1.根据路径获取字节输入流 in = Resources.getResourceAsStream(mapperPath); // 2.根据字节输入流获取 Document 对象 SAXReader reader = new SAXReader(); Document document = reader.read(in); // 3.获取根节点 Element root = document.getRootElement(); // 4.获取根节点的 namespace 属性取值 String namespace = root.attributeValue(\"namespace\"); // 是组成 map 中 key 的部分 // 5.获取所有的 select 节点 List&lt;Element&gt; selectElements = root.selectNodes(\"//select\"); // 6.遍历 select 节点集合 for (Element selectElement : selectElements) { // 取出 id 属性的值【map 中 key 的部分】 String id = selectElement.attributeValue(\"id\"); // 取出 resultType 属性的值 组成map中value的部分 String resultType = selectElement.attributeValue(\"resultType\"); // 取出文本内容【map 中 value 的部分】 String queryString = selectElement.getText(); // 创建 Key String key = namespace + \".\" + id; // 创建 Value Mapper mapper = new Mapper(); mapper.setQueryString(queryString); mapper.setResultType(resultType); // 把 key 和 value 存入 mappers 中 mappers.put(key, mapper); } return mappers; } catch (Exception e) { throw new RuntimeException(e); } finally { in.close(); } } /** * 根据传入的参数，得到 dao 中所有被 select 注解标注的方法。 * 根据方法名称和类名，以及方法上注解 value 属性的值，组成 Mapper 的必要信息 */ private static Map&lt;String, Mapper&gt; loadMapperAnnotation(String daoClassPath) throws Exception { //定义返回值对象 Map&lt;String, Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); //1.得到dao接口的字节码对象 Class daoClass = Class.forName(daoClassPath); //2.得到dao接口中的方法数组 Method[] methods = daoClass.getMethods(); //3.遍历Method数组 for (Method method : methods) { //取出每一个方法，判断是否有select注解 boolean isAnnotated = method.isAnnotationPresent(Select.class); if (isAnnotated) { //创建Mapper对象 Mapper mapper = new Mapper(); //取出注解的value属性值 Select selectAnno = method.getAnnotation(Select.class); String queryString = selectAnno.value(); mapper.setQueryString(queryString); //获取当前方法的返回值，还要求必须带有泛型信息 Type type = method.getGenericReturnType();//List&lt;User&gt; //判断type是不是参数化的类型 if (type instanceof ParameterizedType) { //强转 ParameterizedType ptype = (ParameterizedType) type; //得到参数化类型中的实际类型参数 Type[] types = ptype.getActualTypeArguments(); //取出第一个 Class domainClass = (Class) types[0]; //获取domainClass的类名 String resultType = domainClass.getName(); //给Mapper赋值 mapper.setResultType(resultType); } //组装key的信息 //获取方法的名称 String methodName = method.getName(); String className = method.getDeclaringClass().getName(); String key = className + \".\" + methodName; //给map赋值 mappers.put(key, mapper); } } return mappers; }} 最后一步： 运行 MybatisTest 测试类中的 main 方法 ，结果如下图： mybatis 的基本使用mybatis 的单表操作mybatis 的参数和返回值mybatis 的基本配置mybatis 的 CRUD","link":"/Mybatis.html"},{"title":"权限管理系统（SSM 版）","text":"前期准备前期的准备主要就是建立数据库和创建表，所使用的数据库为 Oracle 数据库。往下看！！！ 产品表1234567891011121314151617181920212223-- 创建 product 产品表CREATE TABLE product(id varchar2(32) default SYS_GUID() PRIMARY KEY,productNum VARCHAR2(50) NOT NULL,productName VARCHAR2(50),cityName VARCHAR2(50),DepartureTime timestamp,productPrice Number,productDesc VARCHAR2(500),productStatus INT,CONSTRAINT product UNIQUE (id,productNum));-- 查询产品表select * from product;-- 向产品表插入值insert into PRODUCT (id,productnum,productname,cityname,departuretime,productprice,productdesc,productstatus)values('676C5BD1D35E429A8C2E114939C5685A','itcast-002','北京三日游','北京',to_timestamp('10-10-201810:10:00.000000','dd-mm-yyyyhh24:mi:ss.ff'),1200,'不错的旅行',1);insert into PRODUCT (id,productnum,productname,cityname,departuretime,productprice,productdesc,productstatus)values('12B7ABF2A4C544568B0A7C69F36BF8B7','itcast-003','上海五日游','上海',to_timestamp('25-04-201814:30:00.000000','dd-mm-yyyyhh24:mi:ss.ff'),1800,'魔都我来了',0);insert into PRODUCT (id,productnum,productname,cityname,departuretime,productprice,productdesc,productstatus)values('9F71F01CB448476DAFB309AA6DF9497F','itcast-001','北京三日游','北京',to_timestamp('10-10-201810:10:00.000000','dd-mm-yyyyhh24:mi:ss.ff'),1200,'不错的旅行',1); 订单表12345678910111213141516171819-- 创建 orders 订单表CREATE TABLE orders(id varchar2(32) default SYS_GUID() PRIMARY KEY,orderNum VARCHAR2(20) NOT NULL UNIQUE,orderTime timestamp,peopleCount INT,orderDesc VARCHAR2(500),payType INT,orderStatus INT,productId varchar2(32),memberId varchar2(32),FOREIGN KEY (productId )REFERENCES product(id),FOREIGN KEY (memberId) REFERENCES member(id));-- 向订单表插入值insert into ORDERS(id,ordernum,ordertime,peoplecount,orderdesc,paytype,orderstatus,productid,memberid)values('5DC6A48DD4E94592AE904930EA866AFA','54321',to_timestamp('02-03-201812:00:00.000000','dd-mm-yyyyhh24:mi:ss.ff'),2,'没什么',0,1,'676C5BD1D35E429A8C2E114939C5685A','E61D65F673D54F68B0861025C69773DB'); 会员表1234567891011-- 创建 member 会员表CREATE TABLE member(id varchar2(32) default SYS_GUID()PRIMARY KEY,NAME VARCHAR2(20),nickname VARCHAR2(20),phoneNum VARCHAR2(20),email VARCHAR2(20))-- 向会员表插入值insert into MEMBER(name,nickname,phonenum,email)values('张三','小si','18884588888','zs@163.com'); 旅客表1234567891011121314-- 创建 traveller 旅客表CREATE TABLE traveller(id varchar2(32) default SYS_GUID() PRIMARY KEY,NAME VARCHAR2(20),sex VARCHAR2(20),phoneNum VARCHAR2(20),credentialsType INT,credentialsNum VARCHAR2(50),travellerType INT)-- 向旅客表插入值insert into TRAVELLER(id,name,sex,phonenum,credentialstype,credentialsnum,travellertype)values('3FE27DF2A4E44A6DBC5D0FE4651D3D3E','张龙','男','13333333333',0,'123456789009876543',0);insert into TRAVELLER(id,name,sex,phonenum,credentialstype,credentialsnum,travellertype)values('EE7A71FB6945483FBF91543DBE851960','张小龙','男','15555555555',0,'987654321123456789',1); 用户表123456789-- 用户表CREATE TABLE users(id varchar2(32) default SYS_GUID() PRIMARY KEY,email VARCHAR2(50) UNIQUE NOT NULL,username VARCHAR2(50),PASSWORD VARCHAR2(50),phoneNum VARCHAR2(20),STATUS INT) 角色表123456789-- 角色表CREATE TABLE role(id varchar2(32) default SYS_GUID() PRIMARY KEY,roleName VARCHAR2(50) ,roleDesc VARCHAR2(50))insert into role values('1111','ADMIN','VIP'); 用户角色关联表1234567891011-- 用户角色关联表CREATE TABLE users_role(userId varchar2(32),roleId varchar2(32),PRIMARY KEY(userId,roleId),FOREIGN KEY (userId) REFERENCES users(id),FOREIGN KEY (roleId) REFERENCES role(id))insert into users_role values('111-222','1111'); 资源权限表123456-- 资源权限表CREATE TABLE permission(id varchar2(32) default SYS_GUID() PRIMARY KEY,permissionName VARCHAR2(50) ,url VARCHAR2(50)) 角色权限关联表12345678-- 角色权限关联表CREATE TABLE role_permission(permissionId varchar2(32),roleId varchar2(32),PRIMARY KEY(permissionId,roleId),FOREIGN KEY (permissionId) REFERENCES permission(id),FOREIGN KEY (roleId) REFERENCES role(id)) SSM 环境搭建工程搭建搭建父工程首先打开 IDEA , 然后 File -&gt; New -&gt; Project ，接着按下图进行操作即可搭建好父工程。如下图所示： 创建 ssm_dao 模块按照下图操作即可，如下： TIPS： 接下来的 ssm_service ，ssm_utils ，ssm_domain 模块的创建和 ssm_dao 的创建方式一模一样，这里就不再一 一赘述了。创建好这些模块之后的工程目录结构如下图。 创建 ssm_web 模块这个模块有点特殊，需要用到骨架 ，创建方式如下图： 导入依赖打开 ssm_parent 工程下的 pom.xml 文件，复制如下依赖到下图指定区域： ssm_parent 工程下的 pom.xml 文件的相关依赖如下： ssm_parent 下的 pom.xml 的相关依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177&lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;${log4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;${spring.security.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;${spring.security.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;${spring.security.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;${spring.security.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc14&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt; 编写工具类在 ssm_utils -&gt; src -&gt; main -&gt; java 文件下建立一个 utils 包，选择 java ，点击右键，选择 New -&gt; Package ，输入包名为 club.guoshizhan.utils ，然后再在 utils 包下新建 DateUtils 工具类 ，代码内容及截图如下： DateUtils.java12345678910111213141516171819202122232425262728package club.guoshizhan.utils;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * @Author: guoshizhan * @Create: 2020/5/29 22:29 * @Description: 日期工具类 */public class DateUtils { //日期转换成字符串 public static String date2String(Date date, String patt) { SimpleDateFormat sdf = new SimpleDateFormat(patt); String format = sdf.format(date); return format; } //字符串转换成日期 public static Date string2Date(String str, String patt) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat(patt); Date parse = sdf.parse(str); return parse; }} 然后再在 utils 包下新建一个与 密码加密 相关的类，类名为 BCryptPasswordEncoderUtils ，代码如下： BCryptPasswordEncoderUtils.java12345678910111213141516171819202122232425package club.guoshizhan.utils;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;/** * @Author: guoshizhan * @Create: 2020/5/29 22:40 * @Description: 对密码加密 */public class BCryptPasswordEncoderUtils { private static BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); public static String encodePassword(String password) { return bCryptPasswordEncoder.encode(password); } public static void main(String[] args) { String password = \"123\"; String pwd = encodePassword(password); //$2a$10$tJHudmJh6MRPdiL7mv0yfe0nZJbDHuhl7sSTnqNC4DauMik9ppi4K //$2a$10$Ce8LB3jdYDZ2f6HB281zA.4eC7v6ziJdK8MMWg0Yu8ETMg5ToMpIe System.out.print(pwd.length()); }} 写完这两个工具类，ssm_utils 模块 就不需要再进行其他修改了。接下来我们 编写实体类 。 编写实体类在 ssm_domain -&gt; src -&gt; main -&gt; java 文件下建立一个 domain 包，选择 java ，点击右键，选择 New -&gt; Package ，输入包名为 club.guoshizhan.domain ，然后再在 domain 包下新建 Product 实体类 ，代码内容及见截图如下： Product.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package club.guoshizhan.domain;import club.guoshizhan.utils.DateUtils;import org.springframework.format.annotation.DateTimeFormat;import java.util.Date;/** * @Author: guoshizhan * @Create: 2020/5/29 22:17 * @Description: 产品信息 */public class Product { private String id; // 主键 private String productNum; // 编号 唯一 private String productName; // 名称 private String cityName; // 出发城市 @DateTimeFormat(pattern=\"yyyy-MM-dd HH:mm\") private Date departureTime; // 出发时间 private String departureTimeStr; private double productPrice; // 产品价格 private String productDesc; // 产品描述 private Integer productStatus; // 状态 0 关闭 1 开启 private String productStatusStr; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getProductNum() { return productNum; } public void setProductNum(String productNum) { this.productNum = productNum; } public String getProductName() { return productName; } public void setProductName(String productName) { this.productName = productName; } public String getCityName() { return cityName; } public void setCityName(String cityName) { this.cityName = cityName; } public Date getDepartureTime() { return departureTime; } public void setDepartureTime(Date departureTime) { this.departureTime = departureTime; } public String getDepartureTimeStr() { if(departureTime!=null){ departureTimeStr= DateUtils.date2String(departureTime,\"yyyy-MM-dd HH:mm:ss\"); } return departureTimeStr; } public void setDepartureTimeStr(String departureTimeStr) { this.departureTimeStr = departureTimeStr; } public double getProductPrice() { return productPrice; } public void setProductPrice(double productPrice) { this.productPrice = productPrice; } public String getProductDesc() { return productDesc; } public void setProductDesc(String productDesc) { this.productDesc = productDesc; } public Integer getProductStatus() { return productStatus; } public void setProductStatus(Integer productStatus) { this.productStatus = productStatus; } public String getProductStatusStr() { if (productStatus != null) { // 状态 0 关闭 1 开启 if(productStatus==0) productStatusStr=\"关闭\"; if(productStatus==1) productStatusStr=\"开启\"; } return productStatusStr; } public void setProductStatusStr(String productStatusStr) { this.productStatusStr = productStatusStr; }} 如果遇到 DataUtils 工具类报红 不要慌，按照下图解决即可，如下图： TIPS： 以后如果遇到 模块之间类的调用 ，就用上述方法解决，以后就不再解释了。 编写 dao 接口在 ssm_dao -&gt; src -&gt; main -&gt; java 文件下建立一个 dao 包，选择 java ，点击右键，选择 New -&gt; Package ，输入包名为 club.guoshizhan.dao ，然后再在 dao 包下新建 IProductDao 接口 ，代码内容及见截图如下： IProductDao.java123456789101112131415161718package club.guoshizhan.dao;import club.guoshizhan.domain.Product;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/5/29 23:01 * @Description: 产品接口 */public interface IProductDao { // 查询所有产品信息 @Select(\"select * from product\") public List&lt;Product&gt; findAll() throws Exception; } 编写 service 业务逻辑在 ssm_service -&gt; src -&gt; main -&gt; java 文件下建立一个 service 包，选择 java ，点击右键，选择 New -&gt; Package ，输入包名为 club.guoshizhan.service ，然后再在 service 包下新建 IProductService 接口 ，代码内容及见截图如下： IProductService.java12345678910111213141516package club.guoshizhan.service;import club.guoshizhan.domain.Product;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/5/29 23:07 * @Description: service 接口 */public interface IProductService { public List&lt;Product&gt; findAll() throws Exception;} 然后再在 service 包下新建 Impl 包，接着在 Impl 包下新建 ProductServiceImpl 类，代码及截图如下： ProductServiceImpl.java1234567891011121314151617181920212223242526272829package club.guoshizhan.service.Impl;import club.guoshizhan.dao.IProductDao;import club.guoshizhan.domain.Product;import club.guoshizhan.service.IProductService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/5/29 23:10 * @Description: IProductService 接口的实现类 */@Service@Transactionalpublic class ProductServiceImpl implements IProductService { @Autowired private IProductDao iProductDao; @Override public List&lt;Product&gt; findAll() throws Exception { return iProductDao.findAll(); }} 编写各种配置文件 新建目录在 ssm_web 模块 下，选择 src -&gt; main ，点击右键，选择 New -&gt; Directory 。新建 java 和 resources 两个目录，然后按照下图操作即可。如下： 编写配置文件上述操作完成后，就在 resources 下新建三个配置文件，先看图： 第一步： 在 ssm_web -&gt; src -&gt; main -&gt; resources 下新建 database.properties 文件，并写上相关内容，如下： database.properties1234567891011# Oracle 数据库连接驱动jdbc.driver=oracle.jdbc.driver.OracleDriver# Oracle 数据库的 urljdbc.url=jdbc:oracle:thin:@localhost:1521:orcl# Oracle 数据库用户名jdbc.username=SSM# Oracle 用户的密码jdbc.password=root 第二步： 在 ssm_web -&gt; src -&gt; main -&gt; resources 下新建 applicationContext.xml 文件，并写上相关内容，如下： applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!-- 开启注解扫描，管理 service 和 dao --&gt; &lt;context:component-scan base-package=\"club.guoshizhan.service\"&gt; &lt;/context:component-scan&gt; &lt;context:component-scan base-package=\"club.guoshizhan.dao\"&gt; &lt;/context:component-scan&gt; &lt;context:property-placeholder location=\"classpath:database.properties\"/&gt; &lt;!-- 配置连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"${jdbc.driver}\"/&gt; &lt;property name=\"jdbcUrl\" value=\"${jdbc.url}\"/&gt; &lt;property name=\"user\" value=\"${jdbc.username}\"/&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/bean&gt; &lt;!-- 交给 IOC 管理 SqlSessionFactory --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 传入 PageHelper 的插件 --&gt; &lt;property name=\"plugins\"&gt; &lt;array&gt; &lt;!-- 传入插件的对象 --&gt; &lt;bean class=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"helperDialect\"&gt;oracle&lt;/prop&gt; &lt;prop key=\"reasonable\"&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 扫描 dao 接口 --&gt; &lt;bean id=\"mapperScanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"club.guoshizhan.dao\"/&gt; &lt;/bean&gt; &lt;!-- 配置 Spring 的声明式事务管理,配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt;&lt;/beans&gt; 第三步： 在 ssm_web -&gt; src -&gt; main -&gt; resources 下新建 spring-mvc.xml 文件，并写上相关内容，如下： spring-mvc.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd \"&gt; &lt;!-- 扫描 controller 的注解，别的不扫描 --&gt; &lt;context:component-scan base-package=\"club.guoshizhan.controller\"&gt; &lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- JSP 文件所在的目录 --&gt; &lt;property name=\"prefix\" value=\"/pages/\" /&gt; &lt;!-- 文件的后缀名 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;!-- 设置静态资源不过滤 --&gt; &lt;mvc:resources location=\"/css/\" mapping=\"/css/**\" /&gt; &lt;mvc:resources location=\"/img/\" mapping=\"/img/**\" /&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\" /&gt; &lt;mvc:resources location=\"/plugins/\" mapping=\"/plugins/**\" /&gt; &lt;!-- 开启对 SpringMVC 注解的支持 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 支持 AOP 的注解支持，AOP 底层使用代理技术 JDK 动态代理，要求必须有接口 cglib 代理，生成子类对象，proxy-target-class=\"true\" 默认使用 cglib 的方式 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt;&lt;/beans&gt; 第四步： 编辑 ssm_web -&gt; src -&gt; main -&gt; webapp -&gt; WEB-INF 下的 web.xml 文件。注意： 先把 web.xml 的内容清空，然后再把以下代码复制到 web.xml 里面，代码如下： web.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;!-- 配置加载类路径的配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 解决中文乱码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 前端控制器（加载 classpath:spring-mvc.xml 服务器启动创建servlet） --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置初始化参数，创建完 DispatcherServlet 对象，加载 spring-mvc.xml 配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 服务器启动的时候，让 DispatcherServlet 对象创建 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 编写 controllerresources 目录下 的配置文件已经搞定了。现在在 ssm_web -&gt; src -&gt; main -&gt; java 目录下新建一个包 club.guoshizhan.controller ，然后在 controller 包下新建 ProductController 类，相关代码如下： ProductController.java1234567891011121314151617181920212223242526272829303132333435package club.guoshizhan.controller;import club.guoshizhan.domain.Product;import club.guoshizhan.service.IProductService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/5/30 10:26 * @Description: 产品 controller */@Controller@RequestMapping(\"/product\")public class ProductController { @Autowired private IProductService productService; @RequestMapping(\"/findAll.do\") public ModelAndView findAll() throws Exception { ModelAndView mv = new ModelAndView(); List&lt;Product&gt; all = productService.findAll(); mv.addObject(\"all\",all); mv.setViewName(\"product-list\"); return mv; }} 配置 tomcat打开 ssm_web 模块 下的 pom 文件，加入下列代码，按如图所示放置并配置即可。如下： 1234567891011&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8886&lt;/port&gt; &lt;/configuration&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt;&lt;/plugins&gt; 导入前端相关导入 img css plugins，然后按照如图新建 pages ，加入三个页面即可。如下图；","link":"/SSM-01.html"},{"title":"Spring Boot 教程详细版（下篇）","text":"输入密码，查看文章。 dc70c08e095095708fc6b5299989fa7ce69fd1fc15a66d331cae1a62fefba345bd6c7fec4358d653e0ad1ff756f550216875834d209c56d8ee9a513ab500fe14b2d8d2dd2d5ee4c4e2ef0c854b822818e7c3222ec1e12683d368e66f1900200021370a15450c91e5950d4435fc60caaeaab5cf5b53f1c4353a6d7b36eafe3a15c6da45bbd891c2e97648135d872882ee829b7d223678f81ee72f5e21f3aed5b7840b9af9f2ca3f891903e56db9c650201ba09f10ed312b617cb2a7df1d1981b7f3ac1d06e981201175d949119269c15a45cd8a36c83ddd2109cb6666b0a85581fc16e217b3ea2332fe68ef5fdedbde21d5b424030bbb848e1857e4fd2584d6462989785f829ef19f39c1c3b1689d47d002decd2f17f02f1b0e0c1c85be0e02727ee1cf0a9e7333a2605e6f186bb7aa0d0b9373bf3c3eccb09e685957db605cdf2dae925943d9248f72da3f01e563f0906cce4a68e223b7393fe21401ba54b24376e528dd95417effe65d610c7d2e30e00c4a46ccd6d8bff0a1c4602eea440ad04b87b89cc8b532f4f7c077b00687a431d07acfa1412f242099259cbfe875f2b37f0cd305f4f6c8d3d1f86e68a3c044bb6eee7f45912cce78d766fbc119d9a03c87772ec1ae196218ede4f3aea4453b372c47906d46a613d7b1f0988c3f4479f497cad15fff435f350fc6096acf49149ac537ab2a1d949486aac9b45742cede4a62a9483edd3fde7533dedd92ef7c30ae1f2c302f311c49773131dcd2cbebc4d208aa94a2d8b85764bcf97ab0bc33a9b2c3737f8fea1639e2080d388aa988c8a26e19ea0805e368e13904578c73bf0c3a9ffadfecc06ad183dd3049700c148e2ef96a0e6666e7feecd6197a68de498234d208ac082c142651bf8d80a4ae8dd4d59c299f72612396a73bf7496874eebb1e5c90ddd0e24ee4f2d96601b8ba281e9087c5670223e73e0836f4d2b75c61400e3ef4ebca0b8500c7e29e564a5f35044636b75b371263a077efeb48cb87ccb5261da8941aa0dbd4f920a959bd2f3b91b6c4602b119fa1e30d392e5919be44f5e03f9eca2d1094175edef975218d178e3e9854232b79943ae7ee3afaa97e44ad3180ce146584829ff2cdddf7bd9c09d68496f386c629c0cfef864498c18eaa89be8697d7d4163ff0274f2a2e7daedde0018a022fb86519f311ae0d8851eb2892afa85b67660e21ef68fd56f92082745132f1f52806674f684f1815a05e174a8ee2b0518898a974f7dfe52ff3644fb36ad88538a10e367d58bafaf666db75d7390a369b9cabca7884371dd24af1f4064a47d34fba1adaa03a2b9430fd08702c3834b5c5fa3899abf5def6f59d107d0a0bbce4d8b6b7acb64211404462ba83249acc948eeb8e3d08d62b6d09dfab335b033b33ba9be218e1063485299880ee42c731d1b4964779cc1d93c7a2e1f67586ff21833824449044b15dd70de139200675ad62b2796e0214cc8526af3e7a92926386f74d94a5a5070eb17cba9d94e3b849a42b1881c5aa0d3f8b87cf433a033ce591072e490c6e6a7f053db2cbbcdfe5682e9928145f30a4be176ce5b7f77fe6f81bb00b8e91383adf5105a84bf1149a8d7f8f99d8a5f5f31faf095f4cbe04886c3e894762e3e782607a6bdfe2f68e34940f5d6f67448fb5e69a132d099550a3427e3249cbecbef1a66883d2e4f5e250c3d47c206b6b1972fb89892f86d88fd4dbfb451e7b182d9141ad85659928ef88af4f9e4a45e3170fc2200f34f72c7e1bbbb010e7b7327773c970f1a6aefd7d5379ac76467153dd31b2d5af2c391cdfa469c75b4e38a14cb9c884f7262b6f9ebb41d740abba9c3c3f3cabc9bba310239ce701d951852f750dcb21edee3b149be1ff52c51cbc89d1d9a15526b620766269fe419030435456331120de23f0353e4d03699f8ed146d214dceee7b25e73bd8e6d6b444ebf19e60ccd7690818884ed833d8c581bf94ec9dff3db65ccf6695a7560fa9f3a7ff5149568373b7823d14c458f0435fbf8ef0bcccd6678a92abc8e2e11766b6efe6de2fb2e9ac633d84edc62a6e25763be7a6893fb060a97c1b31b6f4bcb03c8a2d868b7399fa53061c0c2b77013292ed20539950bfc35f1e04b15a0c5bb13629070b932b683eacd7c4c03484e556c11423b4074812f6353603b9943b466b7131f6392b92dd04dc7c4218cc333d05481181d1d68879b74a5dd7e40bbc3ba7720ef40f9cb6073a7535f09c05398f7806e1054ed1ecc460f46105693c0a9080edf63f37217b76ac401431ba4b9713615111cc8503a3a1a24918bcc008a1374f0fe9acc24bcd631b9778eec7f9d60f87c3cfc4f1f92eefb872a2b16f1006a1747325808d0d150b2fad205a5479d2d11d1fde5276c9a974a980fcea76b37f8097b9017d000046a0d2e7a179354911f1966d607c7114fcf1907b3d8ec26cffa05f2dfde431f67defde4d2f4f5ca713d490d45328090d2827a2614be7c5d09857afbc017ce8ab749fc545b24c94dab0696e805c47080a5226cac673db87f460ea577366e7b3c20ccb5a716feaeeeff6d19d4f612f20bdb595f5ed921e3a2f9d0bc704e60c564218e56213fd3396a28235c04dedd00f471c9e4dd1d19a7ea1c94dfcaa345976abf6b70e814f857c95d4cdc03aefc2fc569b9fb660c1becd43fb6e7b97f26f97633224cb657c444a08d2c613f02f6192e1c5d12af078f5444cb4b487d1e729533b928a58d0d400d733f2972481b676721e30adc443083948a8791c62c79754f1b08822c25d8c46f2b17c10217d62d090500d9c662ad768162bc3dfb48ca886cc064c01eee839eaefa87c259d2f0873395d55fcb0e8c85b87c059d6022d2491f6d1356d89bd77c9073fb8014fe090d4eefe16905e1e05eda94c2087197ff44d0fd30a02796aa3c7f1442421f42f3b566d6701af6e02472635b3556bdf3ba9a19d2157f3ab8bb254db933a5aff7a6b6f604844a2ca96aaf836a8c6f99076f21b6ad381b789ab698a7eb0e65ac74049e36e5e2c1b6bb78234cbabf42c7164064686fbceb2733208cd97b523a36685a21828e848aba88cad1cb294e7ec01eff189a75be3ba2142db9e8c465abf29089fdcd62f4e3fc2089c1c532a836ebf777f03fd5be63283fb93324be92602e0150492d793215664b78a93ab752490fc53e2ad6e4d7a854d20fd3ebac62084cf3496dd04eea0a85b2d601b88f105d110bacf512be33a02a0248ce9211011bb2e12e2643b77dd49a2e23f0c77e472a12ffe0e7d0cc7565bbc6a188bcef0b5ecae1d608c95bd619f8eb1703d4fd3ad489328daedac6915240e72310c6f762df341a1492394631cd5fb890c3d6cb3c6263401b3ff8bcdfec9a28b7a38ace0ba5ea608613015beca502fda7cf561607cd53962566ad9b1d8346cc182a19b6ee2a60d937b00cd61d936aa77205f7b55d9451d61c7d77b97f69d16d36e94143e9ac7941b70266ff2453207eab5bf5ae9258b65c4cbb8840a8e8902027f4cbbef003ff95293d8e5d68fc8bd828ddf0a243d4e1cf10a37fdfdd6b3cf29bd60255511ec3c99bc09b9ccf117e3980a04fec59ef6a6caca2a668dd4278e7b46ac41e9f499502a8771bb1cfb27dba2b7a36fbd8cf8789f6a093cc59d0610cf5b1de30e1abe03ac575e33e70cd62a57dadd7cb2ede8d7db03d976c02e938eac4b7ace952c9e4b0ba247f309a8a61b05ae30cceaf4c3a6e90acbbc13a416955c174d62e756ed5f0d428e333415b457f7f309c7a243bcf6e15906c2a5429e9b1d9cd1b4c16fe665d4fffd073ad4e4d3ffbe2fbf017dec195a9859f55e3f90eea206967059c9d8e66b114c7e0ea7e08a93d57d58626d1c279bcd21833ec20d616086e0ba7db6938136be934b356b979fbd73ac6030034cf10a45909255527f10205d3efc6bcea9ccb19ae880638cceeada65990bc86e1cec9c60a6e273eb37b26ef0c75859f5444ddc3f19e2a7e8d30c379273f3a8da0ffd9394000e67d20e5d8f7e8e7ae6030225e2a8253dda0ced3b46a6ec920c1e05de10dfb8abd758e2cb701be71d7bd3e47a023054a8616c51ac8c63afc1f2c6a668d70641670097aad1a51bfee35b10bf6cefd141f429607b4412ebd625d3358c65e06ed94de990be6dd0da71215c2f9af2b47beb797d021392ddf5de47057adbc44529055f85adfe2ddeaae6d7eb0a8c67b36bff4a5beeb895e0bf47b9176bf0154a94e25d4b07c44ca0b97e284c5ed67f40f6a0e0995d6808a3df76371e3151480877670c672bb6570bd51a3f861c23971479295d15033e248202a588a8ca2c9580fcc2e7bc650dd9e45373daa0d97546cc8c5497326aad6571fb516933000709b726828dbbb1b09d1ebe310f18876b2e1c58ee6c19b886cf330e52539de5f001b1bfa9ab33c9c3845e977d3474934241b6e0eaf5b9165ab522718c152014e0134cae0637d3b3d81339a67b64c21a8613e2e26649ecaa45b47dc66b224cdc0357fda4268c6cd9342063f2513f86adf3f48923707c9d2284a1e1fca100cab6778bbe89eb398804f2ba0f670406e1aef28a5cd05a988e9c518f2baf5f1920a0b2f0b65c8ade90a6407a8cda19b22509842148a815c77c99366f5e8175a0e13ad21d22f49ec996b01109ef39a9dcd80920695c8986e1073c2d7d31c6c8a748723c05f4a2887b34ef842c09d1a6c3df7c0a5af9785d12b8862083a4a2b9b5c7ca5ba915479dcf4b401474044c934050006894e9a9f0d0d17e7f1cce59c98d4560855e262937c84efa6a57c46f8f747b48fcfd9555b6d38d2593eccb45136852dc36112bc7658259452f326be11a1da6225858aa70d22914d2bcca6d7e05966991cb9e28a1f76acda5f96994d86b9ebf2efe704c72084c14da6ef2458545625841da519624b3117f7a786e9916e657aacc78d89cf9807522bf428ccd9e23462d60dd5843d01b80eecbc8d4456a58e0c52ff6cfd5fd77e63b241603ead5fc1d9324a0f2d646a0e1e1cf64adfda74b0821b8c97569209b4edb7cc406547f8475b2107f08c7aeb44227fc4a727815bc88e96cf7517d5504948be468d7c5ed49c16b513747da4daea5cd84275b69e5e0a952c81034c215ccd41c9c6a3a845b2a51af433591aed0a8ce85db452b96d802e1178b96bc83622d2a98c0a05c51b6e8a0dc3640e3f2f41e77e36cc71d96244e18bfbc3f234a9e876fa2075d3b3e076617467a6e30d042a074b9dec8e161bd8e5b954fb4bbfba030dbc15ef5e889ca5b8d314e6a934a08817cf9f3b6b26d918adb0ec90e0d2c260c0439c293f20c4c24805c7679ef97202b9826a21b55309a202f94116f0d954ccb757da83686a11220dea9a98336dad80c6943af0a55b7cd8febd35eddb38fec90f3466fa2002a5b4bbf0f6182e9cac9db58c957a08e653dcb46ebbd2097ece2ad131f326168b320022eb810afc81d68eeb45079faf474962c019ddf078d8b7e8a1814229fe20c7f63df3498a90e49f6bae96347cbe9b947f7442e1632ac6744e866b8798dbdcae3e955cb61bfb2cac48902d565f43a223ac9023b24ac6661638742a5c57303ef5d4271c12df595c3f2d7f62f36392cf45cd97265581018094149654dbd35e59f83fba2761df39872a3c5856578771a9fb9631905558bb1a5e96345a59f6ee8a117117fb3f7c592e3ea02f96879e754bd0e61881e74a4f3d7c5914594b92dee9423537febdc9dcfa67d1ed65c6e6b40500c59e2be2a101c07ff5692063da257d758186059d7b137b7aa1f9aacf6f039a298a2b86a10e12e9375a96e50f87d6795ccd69ece56a1f2033c7301a9b06386751cc6fd1873f7b47b8c1f19185166a4a949caa25b325de05cf49a8f3bd0f965c14641210254591182574ffb2f8a7c4c40e7b960e954a8bbe5a70f55f6a987049140711c87796b898e9c5449e90143b3f62b06cc1d3e6eb67af1a516f0b2e60f7273cb891e0a0e2aebc3f08b885dda9c0763730fc333e93ef7e9f902eacd3ecb98ffdcd5b6cbdf85ac4ccf9e500959a885c43b332af2de04c3333271a61ed6c2dcbe318f3c2bb691b037921837bcc96bd3e3f553ef71aba103afdaa565ba7c5ea6a015f2370db6ea93b3fe0d09c54650c3e3c4c5b06fa60453db464438a21d2496a5ee6e64599303ec0ddddbbbb6e54645e0c0d8ba928fa71bf56d4d3975af5167daa8d44c102dc8fe142854c51be5039713fb3980bc24c615aaf26dd01c82438691b77e3d41bef54ccb75d686c739d7e4a5f81c0807d1848205553ea3cce5d9e34d681b74ca0acd9b8c0d53e555bae360b3b05bf795d149eb3e76fe349f46e7b86113311c8eb8f6c136c190e88bbe66e60e0d0591b82454f1b6a52c55a98d9da6b972e7ab26b2c0ae24e9dff606c84309d2e1a37672511e5d88636dccc078674cfbcae085601b24e4e148931aee395f24992d7b1f5c94194b656f2a6ff72475e7f1661856c25935a912aa920ce62bed36641d0f850a9104f2a54dae07051bc735ffc754566e5794ce51b8bd5eb9395660d3a254b4859e80146af49362bad314ae27f6319cedac627a30b62c7fc1c3599288199163db4f8ed70e5b0531371727f0dfb35048a46e638314d051b61336857973a9a790f780ce5bc2323b209afdf608ee717bd7e97befd811b3f3bcc9b863d522b6144f2cbfcc47a1b996c5672c36116d78d28874c7129287afef9375c81704af012eb1df2b455b0ac0f743a17f963e9711a60d6a033a40b61f0cfae204db741a8d9e4c5dc82cb4f964e79aaa7a1d0451a38dba6bbf275a8c3ba70183930454f9b7af844bb07e74a41724f011b9b8ad18dc3b761baf5c04a6b056c7c76971cdf1df71c60b4318b25e2a1fe92d55d163b7eb8376246e43291b0dfff0c1859195d6f15d18989ae9ae25c13cb02b3fd05ed81e0915326b07f2f1b872220b6d37ef4d0a27c2ded194fdd8605d6203fa57bba6b74b1614965b3fb28effa3dfd0b039ecceec2d16cfec4ac3a72ee8ac303306007ee448b77c9eecfba5d7c617b3a46019b054e85319fb5734c6f78dd12d50ec63a991b147fb4116db4579e024fb7ae67db5b0ccbfa50322b1eaacf4e326bde69fafe29409b58044b644a0a5b6e68ab88bb6f26d72abb7316b4fb47adc363ce6ba61cb7b8527696d5472481182cffa25d1aee59aa131de5f6ee5575a7be130618a72f13ebd96e619c363bc082dbca43998e1e060988b6aefcb89aaea9f8cd1f2540d5561c472c303e5ae7881377eff72bfa9ecf05d5e35d2eded1e8f9d772c519d5c74a08f28fe34198c29735262b1f9889b02657a120473a90d4e8c3e240e3825e564a4549e90b58e558ec9e6251a01f6f1f452fbbf177e9283a13b1510c46b9beda4876b2daa882d5a94032677e85d2369bb75b628d5efb55f6b1cff88f56bd5a7e68f01af2f0ca0c33fa22bcd63401a48c9aca8e9930acc230b3fc668f60280ba7c6aabab5440fb0489baee0742e3d812f1e1a833436a157c111bd58d6be409434743dd61dfc43ad8fac877ce3163f65320d8dfcf41cd4bfa4bb8967c428f07188c279a32aa99f2795e29c376964609f6ae4829cc8f2817531d8a6140ec701b369f4b9eff9b61a6e4abd12340ae2c0cd575d5b64430394bfb10c6bd35f06ab2aa713fe1a1cbb43ffb949dfaf872fe0b196a1234142af9f1396e95b09baf5c33e3ec673b85e9064ce2fab6ba2cc7ef5fea5012da872247848aa0080218d45dd92caacec2ba990a69af74de8ee4e2c0ca1aa12b2504ca6df228fe64a8ad65f23a4b97996b839f642bb27e7089d33253e570ed4ca49b7b0b3e11d8d51a1763d1b96364ba3b38c168ae5360a141906e6f245f5818338c984e003642e685b368cc90a0d05099a46415dbce834413c556dcf35253ace410cb9f7681ace61c6a2440eb979b15d1691c5d81541ed0f54b1a63672b4882d5dcce82637a6d2cfcc3630dfd1097577491667ad0616a708a4d75617aa95443a6a9fbd9392af3fe57fff89ac6321d43c5614de728738aa8d5b71a46dffc3e703de58081b691ba5d1f557b146eb46b5249380daec7c63d1781db29e5d127a610905d70b3ed214a2d290f16c14e0a3d95cd4e03eedde1f3f9563d692fa3b1678959f24a79dfd1f3fb67d3ff4c8fb9655e3d15d7180d6debe4458a37328bad8cadf7def15085245be1cbeabf76977f5820a33d5b4f1087312b8ee70653012d73a39c5a6231fdf3da6cae0fa07f04d364f4c7b869a3c520ff8900e2079b3ff5f77d7bef634a3e84cd3830898411f31f849e9162973f441bf8de37d1ea9918b15b449283c7409e0287c8ed0bd1c34986abeac288066b02df4340f045a4fe63cde7bc680a84ec390b40fdcb56c987f3c438eb4cac6b4c6463fabcfa198f92b436d3bb12bd7f9414e71f27ad146f846678bc2b324e81e07feefe5a8fd6c7b6f6a3971e06c2dcc24b1dc9d24f91977cf5f0dc5bab7125b9c3638d9ae52f209fdf43de1ab36c9d4b0d2a0b5e9c544af6987b3f3c2c0dc99af0490e21f19e06048dbc9e0a08d2ebcb80234aba7943133b44af6795c191172da153df749f6a75e89d54ab26aa1c408bea833800d0e2c408c38b36a3832785a2c3befd00189027227bed7be5c6299693d3ac8a4372ffdab2a306508bade7c3332b72afeee999acb820323e39ba29b3cb285ae8fb1949ed73ec22951e9bbf1677f54e6803d8f3b2b5ccbc4d52d7d6168b1daba3b5f8e5d12bd7d87151bcda4e17185861b087321ee3bee2800e34a56bf17e1c61b349072efd698f75fcd46a6dac73501b9ab19746232c9b9ddae3b5472400a92c4d1514623e6cf85def16112c67422ad460aaaff951aa7c87f51fb50557e5ac92ef1bf0b0898a173685d8e6315d42f6154e8661609c7c8c8cbce030cd0bdf877ac53a50dfd4fed18971d473cde592fadbafdd992b7aaadef764515534b8a73af5f8fd2269f25ee808ff9a0c72c12cd8aa3333510f4471b05b66e8be30e74fe33e5740fe52e9c05e5485d91a6da0cbd4b4a4148eddc387ee9bc7eeeeef211de3cc835def3a3f0d0de071c342353163da505d25b55c75cd732e48f447616bf65047f00aeed54114def1eeb0b6616ad3cd80dba91d7f31d0a6b9ac6ecadc82c21f956db70a8985b6e646949be7dd361e5b940e160181e02c993386bca5c09d9e3c8ae68cb07e21f5e5e0e2fe765ccad2960e947fbb7c86a969ac796ca1ed917cc2f1c3e29088183a502e7a4178df1b15d583d1600687d1388b6e7b9bf035efad611374905118d58f1ee3e881ddee0647a34ba591dd6fc4749eba7faa867b3324b4229dfe287c19aaf0682d37ddd140d3fe9f2fb5a40278057ed91680c496795079686f1548d9980704c41c20ab08099d04bf0c4edab70790d6995dff9296935e13471a8f52e753fefa4f4502feb3b594f201f88f4586f6985f580a6b55ce2a84c38a26bb35a833b7fe577851b9b8c69971b97544cbc26e5468d8391dbe14e02ddac48e1dccfd2c93803259cfcab2612edc852ccc23f22bf74136f61ae8c59324fd8a0e7f1fbed2165c80a7b8eeb8d403fc9bd90b9fa88a6a042a4eada1266cf93f525deb44b4b2a40f96d429271552ead53eb8111bb8ada0647fc5f5bc55a671a317ee269ede21f0ffc1ef684db5c33b44af31875f9375e660909ddffbcb60ac5831ec247a7f364f9789c17a59aa0d329b1b49a10a4d9bc4cd54978cba146a00c6956a98009aeaf6eaf9650ce8a78f4c3f58632b7d57a65446b7269799b6b1ec135402f7488563650015461c09c1670f90af8849dfc26a0aef2f3f2b88e163a566cb7433252a6c64a382c9590eea0637d6de46251d60620a7b57e27aa444f06a762c87868169842e47b55a088d94148cd10b4bc3f19dd46a44a7fa1a0e3dda19f12263eebd022bc42027b3952fbb0490d94ec07d99d1dfc3b3e37aee42fbfbfe086bd7350c3b5b4e4ecbdf813e6c1fcc00aad44490c5d714ff1b1368fb5294f84e0b17c1038e7133f2be31a3f9fc60444abffc5beb2229e337c7601e0e73473aed8a531758e2b2a3b03829d9927009c6264fb9e88d9affd7136bc876b0175118a42b9fbe9e4a0172338696ca520f4f1362189287cc26656c8e3aa33ee90e010dce64750d2f7925af74f1a2d5c9e46bf5e34f79fceb38cfa6c88a96ccdbebfc175a6876a8c263d99738df1cc8f0e4c3d65b9ecc3b2df2d2ae2f26007cda8f845810586ac92887a565c6555db1de3c14c188ffc8304e7ea835e7bd4dc12fed302a02ac8007e5d95d2ea4c3bee5f0c4a1f9aee7c9280b37d0c9e3a697105f390a2b35e4f84556017fd87b31e185cbd7e7a282c9a39902012b56dffed0d62b2fb58288d94fac9ade714ed4f328c51e59562a2194020db2af7a520216b88d75eb0be953f5407af618e661915543e6318339d58a82d7bddc54a79a36455c8e4e955c0a9f939a9f61542a06dec6fa399cc7aeb278a6d495a979558b5325edccd84c03e9d24d2c27c82cbc4a2e20cbd7e412e36191ea39069694ed2f874766406b75fd6fee71539aff9e71c0dd21688f2e78dfef3a238946b06a7c45c6bfb19ccf1c7bdb4d8954fce7a90aa76055ada2e19f2b836f161f88cc68b1ffdf3880f8b5ac4e64aed502d2cd24dd32a0a5eefc84b3bd57a734049fdd063887cbd3f58a3a10e904b83ab7f2bc4f460abfcc63bf746eb6e80e1027fae3cfdaf1b7d4eeb5bd57585da2f2dc95687d6314f2eab3f2b8a21c8e24957518cfc07486519cedda6208ea9dc6120ff324cf284d58b395f626d1710f4392cb333e1c4e9440b12380f5d00ce857776858c13aa14083913885a64dfe28eb305ec7076baf68f90898104d4b639fa40babf5c52e3fb98872147756d84f1d36ae21c79cdd8cbfe7357389a22998d146fb3cc8c7c78c6c779ff23c5ebe00ab08178cb0c674b115d6d5ee5bc6d6101071785248e7cc16c660c04e9ad8450647dfbccd229f46688e7bcd079ee9e80c1fff8fbf3a61d8f91023ad09e8f29f8e0c3a05fa90e73b73fba6e0d32f57080e82384b8b3bbe4e9fd56cdc0f79e06277d0cb0ce0959dd0391444ff09efef03498153ce5624e755c6a7f36428f37f30868bb3e8c2100f8354f0ed226ba80d83d2a114eefb5268e156a948c11b7768e9ccac2f2edd6fa7778f5226961efcb89c66f144363b162f6ea8f902e99aed101c382d4d1db4c87601c6668c2d92da9f322f3be81921906f869c2aa4eb952faf93563becde732bf244e994c67e5c7700ce7708f052ce8dbfe37ef1a2ab823398e8bb4808caff60fecfc93227c3ce6fee1aaea338d201dcb341cdbeb3a7b8595f37bed2c35b729e7c3953b23fc334224ace6aecbc709da8852b2d2d0b0796da1a8f1b964591f775391eef67c15680b5c9fe560c1a918eb50cd711ff5f45cd125c712408afe4588b547363d4bfe39abbb4a93a409f8be41520cbdcde97b6c79e69f71ec9b3aa56ffa18f95ce157e93638a125f94c9ed35fa2dc0ed57bcd52702ef20109aa01c6b35ea91e92e3f409865565f3ee3e0a1a2e1d48daa400f8f1708e9890afaf68cefe2c3e112108f49b091e01e8b55cb197cbb1feb53cce3d2b1dbaafd453573609e324517d67d979cd03ef0ad3ebd91f39a4d053757b454aadcf6d076bf5080cf8fd104d767d5f0819d3c709aaccf0499f11f019361e94dc917b666969c35f51183570e709613972c1a07a7599c0db0a07870c4c84cd4b3ebc8e9d3e5a96983135452341d3dbdfe9965318b3daf3f15f9a82e18533d2ebc19ae42f2e74224b3f3c140fee590fbabf4d1a0744b2280da4506ac5240200a5a50ed7dbb04c0146bd021f66f0c3d9cd013310aa5b5dd7a18a89b6cc6944777c1287c9b9eed1d9aa9de140e96d3f672dded199150845c27e4563e7c19928d125f25e13bc960b4494449f3e5cd14c32ded8cb4f409b7a1be2c4e3951c1b8282e6779e5cd04d5355bada5c654c9bd0822ff79fee35f8daba01f997f0b585d40948b122f4b516a4860ca775384612a926ec0369e14c32b462cabdaaf48aea70ecb946dac2c149e097284f7c32b99af903a1dae17debc56204aaa6d99e9c22ace1abf10b9e6924306699d126e690b93a6bae79eefcec945e59aa5ed458f512d87372d53d780dc6e27d65653d37a7f7ffdfa8713789c35f680029b62b7e5e3e13d6604123086e1f9cf64acdb66ab209a0b92e2c514e51a7ab8689f9ce5e720daab02ddf97ee1f683399407c695fe6382ba2d12910dca65e20124facc05da1d8da62de2caac2c51bd5b8afd5fd0805ec150d7fcd876eb1899a2e95ccdd3a1d925ab82c8693ed2e5f9868ebf3e437c8680b08adf085041c586fba3ea5e22418102aac08679e3dd816b8bda8a63f25031548427cb9bbe05b6a1b28a3f2c0eaf9a78278890cf0c84b8c6da32dbf96f682911a8b72473cfb57dace60fa6ee64ffc3da46d9175e77982101787ae7716ba19b6d866d069f2224075307160a348324ee89b76961b62e95497fb2fb3c8cc3ada2a2f54894b5005fa5db1982cb207c2b64e5e20507b7ca532fbea0730703a3ef27732dadc790069af2d9f5579ad0f72fc581387f27f1a969cee314ce367feb7b34b9b7d0cde7797399fdeac08e621d75deb099956cd4c32a607198222f837aa2da6e70dcf9d8710f2b44cd94a46e6daa5d045c01ebea4310e7740e8cd97cb9ad015cb6af0540d0cc448ac346fcb520d2d2abb4f85060d41f781f0eef4829bd2ffb67e7732f075e7625358bf3d8c278afa13494ab4503cb35d4c42c1a62c864b52a545a92500850c548d795d473bcf50059470fec6d4f359c04e1ea03710ceefbed0bf22c89a1ebd51c673286858873e8549685ec99bc93b36c22a376176ccd61cf220a317ab636ea7b72c033f3e2bd2aa4ae762c5d378dd4aeed103c2997e0caa9cb4fa3de755692a7a1e4bfd33c199ff441fed3c354ddade12e39732ce60dbdcae769c09f3e8c46825677cf19c3d297226ef2d695cf4e49d09518bb8dd4330d209f88e5379dff42a86f12cb0f750ca26a32dadcc8fa6264a4e2a8528071bf0e33f8d934cb6c01b035ee7e25e7442631b63a5fd1d3773ba22c0402eb0722ce86d68cd60bee9752add40f8bc99fc1029d888e5980825c4a38ca5af478e5f5c9b80fe4a07a5364bdff4369b4a15502704f8f28bdfacd6dee294e815df74f7d6ef3e4a592f7ebc6ed1288d54354165da4d716c9dc42f4a67e48ef74f81e07fe6ea1545d6e2c1e26176a6b41ffe8dd5c145724a0f852b4bcf35d9a11726f54f234907bd6700f14863c070374fe2255266965c2b5949458db15c9307a1be094c495ebbc25ff22ab82719587b3c04132fe7a610db9951a063c5e4fd7ad834c90491926e7a2af64af821325880d2e2230570a839b9a9dc38af85ac00c1e8b66b2f74088f5d27e2b36f6b71d2fdb58316d78f27c424d043562cb1be7775b0728c7ffd4de0c21900e29f266189f65189693b6b71f6a6ccb9dfd8bb8a336e79e68ba88bef2e6b33d7b2407b400fd4c7297eec06a5b644a445758dfc82106c8eb90cef2e038b34e88592e96a4c86d006111e69416a01725ce0b6de386681aa35027a4c82358db3459bc8fe2bc76918ce5755c65f9b882f954d9a04a271d748e0b254cd76ccd8d315c55b0244ce596cb5b40602ae4e03f1bd106d27dc5cf6f7bec0e54b2511b1b37f709763c69c859f571c920dbb2e3d6ef1e0edbddc9656b0e253f8c026d6fc97be4fc0a8bccec8939a21daeaa7d5fe90b31de35951b30e8902decfd7ee977f13a11edd41a564c68f2eb6e7339b818dcbef33b700d63beaed964844087eec06c19ae5e4ea6058fd12b02cba0445a25b6862e0d7e2c8a6d701a0846cf4933dbbef8509b916f3c161c9576b637fdf720619d4adbb0f224abfb0b8f7292f2f8c4e3bffc7dc816f3967806adeeda4e6d23ff9becac0d348d89ee53f3add823264cff7bd733a4312fd4b9d1524bf74441dba85e72ebd5c898c51deb3b3f4fcdda72f6c7b67056d8a4e18f5b257a2fb4189484cc4ac379be2869152613ace94f15675a66d6d893346e71d6c85d78c27745eaebd58b72cb39f2019f52ac077b147125c6008b8f3d81fe5e7f3f73b7ba552d079108f22d9e1741ab7aec608b1a053c6312bc9b4866cd46ec0451a9c1e3e7b28d2b022042ac545c5b56c60ac3e04e9872e2fa7b866045c78f9058aa16def2c91e6513b4c5ecbc30bbb72c1ae4e4bfe2826c02a96fa8080a9aa91fdde55d8fc6b38ac59267cab61f97946bff6a1dd960343970de85739936b36e1340422530907bd0d346f918dd1de7374f53f0db38232ea61da70c30c9e8683b0cdda5b8c7b91378c1331c28a247cfc4e18fd13a4aec602ec1382c6e7635552c41ef6fc36cbc457fe44f0021eb6178141ea08b9f6112988e08b6a07cfea387c8a5a479cb7494138e4d256783f5cd0072c6ad512e2fa1d2b2ac432f515483fbed634931eccf3ee2e9e254124c1884a7e2a7034a2dfa696151f3fb07d7417a27d94526a00011c3379f4503ff28badc0cc2760c082b2c42000a9136340895552412111f807abe69e1dfdd24140892cc358091e854567ac408ade596a46d18129b2e05d6e93f06c825bed6baa90b4faccc33037c470395138723043eda6f6b8a196ac3ab65e2c997ae13a9db08fa8c439bfe79cf65df82e66694cf444137c98d13fa162c1cfe04532e87cf4fbccf4c7faec2db65ec31e22183b28d98b9fa6d0b3db89e98006a8aa4ba8bd29c52861e4e2a1ee82ba3773726915b403615fa5a551c58cd4385ef04b507649992fb5366fe26cba52953690c249890e398a234ea71b020f16204fd366ad583596514bafd6dc6767b732cf269d0cf942e8b105fd9905259b3bc2ba44ddf98fdc6cee11a5c1d3fc47c8b3c8b606f2e256b59b5f265c12f8ee46cc084cefc7478f027d0a27fc5e8814e427fbb68ec399e3c0c83401aba6a3899f5e5cb87166615dc49352742e3ff8633887e4ab549c8076990b6880b4278038a5f99d7be894f47036158282d1cb444d0f051c0d00d830af6c5fbe7f30b6677bdc69b94ea53cd96337877ffc0c9e7c7098d2411083643139562809e68442e7c25636452a2c4681020faccb6077b1022b80c55aced1447318b10c914b57cc1e6c53b95bab79332d976cecfd6a3683d32e922621f680b5364c947477c03c52a2d659fa87501b71a1793dba61786bdd13852748e73152daeefd91d5e4bb838e3b67a50c014d574f00d1c54b6734cec1f88f0fcab581610136df64dabb8841cc9d26a8b7f41bb26f90ab4015c4136dac0d395cba7d99dfb0e1b36ebe439817eefbd0b85f87d3c6a08e055b1311511da06ea10948c833910886778f55b46a96dda8e8ca7d3454d41a0ecb985eb0262cbdc3eeaa0fbb9f7a3972887d42b1a7bb7a08418a6e86ed32db3d7f5dc1b11d53efcd4324048a0a2c0f6fe3ebc3ffc2f23af3e7ca0557d974730ee5f704de8e8a114277062f3d4368d1ab38dab4391a4cf4907cb9c5da55cf20a51511fa8b73b4abd9fef7b7dfadaecbf3fc729e3d9111a84d64ee9a3a14b88d24f41fb615ece3a75763fa493eb7b712e91c585cdaca143a59e39a1e9b98c8a6200b823d2d6636aefb16a8f7c9736586863a8c17122544c6e4cf2ba39d748b766c455573b2d5677ffa782b8a805fd86d3a767ccf6a0d8292a761ad80da62a020c539dbbaf185fbf151bea2238dcf241b07ae3c8e3d1a4cd106f94b0861dde524ab78a8c816ccef00cb8ed0a91ce9ea69fcc393dc7aabdfe3fbf3f6edbc4db169df88490f66792d4bc5127d72234de60c12360dd9701965c2e730776857d2fd1c85f8f1e670a4b5ad6971eb28548b68abbaf39cfe66073f0304aea3b7e93564cbc7c1f010795429ca1f9c821033bb3d79162c3aa3c4d0a45960ac6a6baeeefa9e6e2b1031abf6f07c991c418a7b6cfec0b187238dfa8ab203b8ffedb59e567e32504b2e557e90b94929b2728af66ab05b31a7d5fbf50fd27d8327d586f6bab802e982b8af6e41927c581f73014eaed2893faf065e44c016365b94b702abcdddec053433e603f20422ab3024265ace2c8cd654a51e4b309823a77a10ca93e8218976e30c08d7a18dac74a70bf284acb39c90b49bfc3502fd75b650ff73ea232677b5649a3002d1f0b03dc49d8e9b98e4b4b8a0f486c79c1acdca845303496a041a05530f5801d3d5db6cf9d1c59bf080854c7e6adfe47d28d7c0bc1827183dd4c53f815b822b2db46c664445b6fdab1964c8ef9234c3477da80c384066bedd7c6519620a88dd5ea0f49d06742cf682054baf3a468594df2bc6b258b7648326d24dfe0c16130cea4074cf1075a53dd52b81ff17ee80674972ced02c062f9fa2fad428e15f3d3584a3d6f13514c12986bfcd1108a3fbbf541146ecb3b534a92ed3557e8ee21dfc1c69f18c98a1cacf142144dcfa0d2fb8328006e24e6f458e7c0c2ae07279d77b7e28a1564d42d69af51ffb35c180ebe7e49fac0ddb671d456446d3af81ea25ee2b721d8477388ec59b8aa4864a17c5e801faeb6333221fa29c7efc8766159be348ea1cdfb5a22f95b259defed84841b5b745045e7e71148bdea77092bc3a85bfb9f064f769d5adb570fab52d785fe5c418ca49c0515db0ff471ef78486ba7934a91333704553a9c2a8ed05cd6dd62e4cb837d95b6d171d43f3eb32cd2c8a7f8d76246e09551979991d620221aed9dc5430a51a7beee9eab511810f4f35dfeac47d6c07a93212e40948343da0e3918559f1f66b9a5ccefc24da3b550b0b40f557d999c3b167a2a236675147aaf51e12cd9c72186d1ead8bafd632ce4797360872ea2eeb45549db4cceb2dafd3e0ead68bdd8e9bb33e931c4c0430448e5a8a6e26dd493895364102489850b0e2752124965c9008e1b3447a5f5595a01f4b4ec7519f18055b4b7232229b6f3c67645325e95ec1b77c20391c8345fb00f31e9599aae90e752540f128e577824ed4819b29e5f085a893ceb531babd10196a4bb781606ec0563f2c0533a202760ab8e1d42f6ac85c546ab0ca9d94f98cc7d20875e80e76b7adce7e18f289fad7d94d0c9ab5eae599623da114bb830eaa7b2896905105683f34cd314c40495f8e3f106e98330108e5a079f71ed7049a94daaf8eaaefb0efc992ee340cb81aabb8cff802d852779a734d9ef9555fb2727a3500ba386cf01640b0697d6a320a4f3a131a53ca9ff570db4d90d442992c7947f89db2668f276897e4c828442725e587dcaab8822d656c7e53f96c54bde572e9d7dbcbe567df90bd0987672fd3f64a829f9ae0130ae8f91f642293e70d468bc59c6289eef2ca0d99f6876fcdcb33b9054f9b5173f96c964b8aa7ed3caf6d1f1738df60fbb3063c1ca022047af1b780f93838e5a9961e1c5f4857fcc447fd3c59cc6055f943763d0474fbe9f48184946477579ae26c8318902cbe8941709596bd466fae7e4bac79aa7b81419fe79d89b54eb3060eff54911d78bab5589f2d8d513397923ab76184616e3dc5c279c8e33b167d38538ae8099226ff0535f2596263d2945d922cdebdf0232fbb34fb7f6498a48a43852de9d93ec9ed3212a3e83ad26b1f79c33e6194abfb0ff569d8f7557e3dad735de23b980ab58534d63b68f8bc6e3d31da136117c123b76ad500ce59bef62989b7acceed64bde77fc522996ccab5899a84b5a573154e611e0b8317cd6f7a6121e81bb93d3ba37c20c9ccf49f5200b4adea4828d72ccd497446f7259ee6639bc053898f94d5246805c183b3f8cd929c2be10cd4ba8c650d16b39ed5c928c8f9b7dbb6ddc15f581f24503a8309449c3df2d030cd2b48f4e02229a2e3162c896d2697cd761d5692c6e8f7423323be77647a7410cdf8e8d262159fa5c4c19bb163d0bae61d558e753bb3197dd9f6cc44ce29674da4ac1ce57e86ecb628e191d5d156c6001af4a824ed9bc8f77920d59229517e4e6f77898f6b30e4128f688c1a828e4257af66ae1270277f600738bc209f225b46cac9616fc7c7c47bc7c8e1856730f5be8af81c4525ecc3032bcda3ca9feb59e3b5231ffe0fce5947e97c485a9f3cc03ee8a818e10d5f0c6874e6789ebaa33baec7ef407a59cc313b9aa2b1ccf6ef799b55aa957af82c05d42060b3ed5e827d40a69a75d319ebef48ab2f0833de3c048d1a67c618083505845f6e2c39abda898d384289d66def88a3c40cfbf02f8d08c69eb6b36b1beb3b63f24706bb6282de7a58341df7f1aa213c1fbf22bab38682971e70180d4bf2cd7f59dd2c06443cd93089ff21f88f5b1c63cac799a4f32f85bb89b6d3ba91855a6f342c35aede8e94390de6d75b319c99ba5cf0adcbd8079620904854adcb60256af23750ba3e1187a5bef7d8a55d9ab101ded70a8c71a615088cf9ec9ae75ae9c0a524ee55ef3296d173663957f613d938c5c4310be88b65f5d512f4d50fa90f6962ea539a4dc3ffc9f4136ae4251ae9acd07aed5ba0c39af61176a6c44f599e5fcf1ae5ab791d46f1a7c217a055ee7a59161cb7ae4c1d920e48c0fbb43b0ed22b0446d190a1be88eec7fd912d29cbf2adb6dcb01ff5989146b981cb6f86118b04265bc1db4e2eef373b9fc94d0a59e4b0c1215816072373dfb3bfd37de8e9d64fc72b9dd070dc5a2b0297c49aa7c9b7fb37d71f48c3a407cc2c2d6e6d5096cdb43e38b42ea8c075098c47464d1b347bd84f10b64f265abac9f0f7eaad16e4179fdc2850eaee10f7987b3e98930be9868310dd7be758210b938b256cbc507622deb22ad40ad1b2125baa7dc0257a40f73aaa04e9512e2b38db7eefb68fc4cf52adc17a78a2d4ee58c49fca4b2cb1c771c49826d17f8a549dbbc6907c31a6a311d5ee039d834c13ce56922407bfe28f86e0644a881e1a8d25b7d9d3fe8be5a8ad9924c52d073eb8a1dd5f764c054b2a9e0f0bcc673bd055341277997bf180fab4c4d5ba37c790a7aadbcb7abc2b721f29820ecc309e9bfce911322efc218c998f60f23e423599dc944efdd5b71642cdf549e9aa9174757d6aab8322d1dc7fe6ac455e6489ebdb7c0c8a1d4464c86001fa962e3ad3e6b4fcfecf6fbdd6846873abba97c45af173c662ef260c1891dd5c589af27d3159a5d14f39216568188906e504e0530e9fe3486e77f56f87e19aabc57cc8e2aad02a1790a6bb1f666e151e9c9f4ab4b573b41b6c6464a1096bcfbd88b4c0787b790d8366a0f905bd79439596ff216896b3dddb453b1875060ccb9592c86dc2594cd542589d87cb2932fa9245e358a79831a860b1845f2be7517db3007c93c231231e07198b3ddc957eb3d32c8d78a8b4b8758d31e20db0c9db299fc6e35c7b3615ef5ee113308ac77849ff59b429404c861bec03def08bf8f34c59a1d816e5a9c87a33aeb9ee8333f91d60f14b7fa22af76bd95aeed6c7071be73405d475dc1c88238dcca0429f89e36bfe945d0febbb1138ea070f4937ea691848373350b3e4fac6f1b8db97c0ece9d487924b8041cbc48af73f9778894357a73fdd6aeef39d0f2e4424c2af951142d0f84836813f93cd3202af75c210fe70156b3ba152136af39ae35d1205710888da76fcb2658f82972fcfb5c43a1a5181dc1f212d4ee7e2f4e7ccd734e15bc48031de78d90dd0ce032ac31f1054cba0e55b626046137e0ecbbf1e9ca6de3231230045d9ab22077db37320a007ca5517eccda3c307f81d78863ee1fd23fb88009a71ef35a2a466a2e04238f78aeabff0b5bb942befeee03f86546cf61eedb8cf1d477083a995bf71adf3d423dec7dfb5fc0730b6e1b7170105776c4e505818a8b7c507e66d6c4f965f55c1176b46a054c0defc4ac056549565ce25defb8add72d38bcd510a870016777320b84ed065155a53a44c6daa78a58a54e904d742ab8d32190724bffbf8f9110ddb3ebd3ef38cbebd601e0b584da6453e7167af8c04e98e8ae8affe70513449b36b6928669cfcca912479d8dfd13ef072f177f1ef2ed3c0c7db95f2f609cc338e4f24a155d0b80359899f81897a2fb1879b60d965a6de39f4e3cbec4b1c44cfa6a419d5fab579b29085b6cfd81f8b59d00210ebb7676ccfa62543dc93399fd2bd50fa0e88b852c573411a7e078d919f1563f2e4d7b59d8a72cea046cc94ae4245078a74f195bf7f175996c0d1cf9652ce2c676a74e1c142598022a4a6303d64a522b9364006ceacc9c63abd738648ae3f7a907148a2dabaa8b811cdc58a408554b92db766fcf17277825cf0e9544269fd8c21bb740dfd312e68bc9402bfa581a18cc1770b2a36d08fe7206e23a6117845f365d630b84e2f741de4ab8c82c547c33409d7f9b581ccffb5b7f980e43489d9ded77d7dfbd5bdb85cfd201e140feba3cbc04aacd858cce2125eebbcf7f0617ef84b011bed5ebf147ad4b0b319b9cabebf1fee1459dbbbffaaeaabea3da8520cede1874c5dec0916413fa704fad6dbbb21164995e9ff659a3342e9f2bb5736f5a8ed6a644a7ad60eb707b91739200d4bb6b2541bc1604cbad577888e513e761a079828e7b6f1e553391abdd408cd41ffcff597f26768cc2530ebd3bc597c35e2c4fba43b2541a9bd6381788c065570be8f10b8dc509f7c0481c12565869c0ad1d548c8e58e680e7a792071411dc0a389e16135ef2fb158145702f3ad5d0bb43d81cda1066d047c7f220e45f8d09b560dccf0c62ce08df6b17be84557ef654a21254c2f782d8a55e4bbff41712ea3340ae630651bf2d295c119cb46b727c6e6a6cd2ac56171c1e4946808564566a428e5a736ee20bb73ef358dea5a74762046c1e6fc73a7c26be91f21e983db0dccdfb151ec9fb47f527e71f8d9feff0a33d2bb978dba6cb1599a8546ff40f8b9ebc9e6c31bb4600e85a6db82aa6e63a1ac8ea8ecbfe66e58ecc4519e9bfb9a7fa6b5e293ea5015c1818a88ce75a1e00848a7f62f5bd1925d9c401f7198b1ccf24fe4aac8c1270ede8cee567cc10a0195694093953d2e0d8b69f47c03af7917bca55aad2f0286b1272aed3cf8dd11182291ee935a7909961b0747885646d93fcb4ccb384a0e08d78b42f1b528657414fd70890c8d02719e1e0e72ece4da7c022e9335c02b89d6124f3aa7ac9900070a40152c25e2500cfb64013d648d5e294822b758f919d50c9f1dd62e3f902fbbc1325d822896bd8a4dd90a79a3ed6893f7f2bce669d66121be0f2a340b35cb36eb82a237e1b148bbd92f3d55944520a6baab356839a9ca3c341b98e175f7df0ee9e1836514c3b71862f0c9d30102b8e7a06a33c9597627c89d09184593410b854348bc6dc82bc3b7894b3b5354c475d56649a2821ed85fe753b7dc1db6a6b3dff57371cf5f35543714f166d8a8768b10c74e22cef3d120ff84202baf8060e4e12e7cf2adca51d5ccd58a6ddba3b09f10181d4bb934fbb35944dcd195722c6e285299d127a63bb331c15e3363ec356b33c9b3cdf3a8aea310785f2ca3139286e00e1201f977ecd6dc11cd06c1c836245e3dd46c2e4fcb4a60606323c481f0818e1f8c376ac28fd964ea3d5cdf290a3aa5677318bf84f7cf509bfd0dbd8220b1c3be17d9096f1764db006e3af7098cf4c8737fab6bce02151078fe06d8b4582b9209d1569847a6c94f14639d5129136127b872ebc51ac6d3ee35c47ec0111d3dc54462b4623cafaa3869c3845f96f95ad07d0c00103b6cd5ae400d6b44eafb88706a6d942bca22711a2bb64fa99ea85fc16397d56e0e5ec5c50c9573217a4d8d05c28badc26b76302b693b16184f36503494ef68e3b96a90b4078d2e1ac723c3b3eae0cf810154b7ed290975d8380f2cf25402edd09cc42ac895d1606a20d875d802fa70ba82ecdf33b15c2d8a0389d3e521f2842a8b141a9126f14cd1bcd7499a70d24551e31adedd41ec18f5664a047b1decd8273c1c396f6004592a46262718dda1d3268e8d2219e4af515163492ec7ec7fb65a34326041a1648cb944d3ce781d09c9e6f17a0325f59079a034066124e9f2c78efcbe67f8fe8810262657e7b06384ae429bdf91aa530524adc6077a5403b8976a083791f8858367709feb6acaa69cdef11d4b0b6da162a9f9a05db23f44e8255aad833a2ed7821444b94161e3bd09a74f338fc608af19fbbab62b0abe55e6a8064e800ca18a327dee164a792e961a8c6b279c046e51499d73f72ae2e1be3f5f61c3d13b205da4c5b514df85b644853e03a79aabc70a9b0922718d8ce9d20fecaea384503c44f9a1c06fb336de4b17b37d5d064a1d0a4960d2b41e7cf5554aa079e7e933647c8c788d93d297b3d72628d965ea6fd1034cf7b9623612321063418a13b65b49a61ea87defa8a15760d55ad443d70fc46d805a776bb6","link":"/Spring-Boot-02.html"},{"title":"计算机网络入门教程","text":"内容概要： 计算机网络概述 物理层 数据链路层 网络层 传输层 应用层 网络安全 音频和视频 无线网络 计算机网络概述计算机网络作用随着网络的发展，我国的 网民和互联网普及率 逐年上升，如下图： 提个小问题： 请想象一下，如果突然失去了网络，我们的生活会发生什么变化呢？ 计算机网络在信息时代的作用： 1、21世纪的一些重要特征就是数字化、网络化和信息化，它是一个以网络为核心的信息时代。 2、网络现已成为信息社会的命脉和发展知识经济的重要基础。 3、网络是指“三网”，即电信网络、有线电视网络和计算机网络。 4、发展最快的并起到核心作用的是计算机网络。 因特网概述因特网（Internet） 是一组全球信息资源的总汇。有一种粗略的说法，认为 INTERNET 是由于许多小的网络（子网）互联而成的一个逻辑网，每个子网中连接着若干台计算机（主机）。Internet 以相互交流信息资源为目的，基于一些共同的协议 ，并通过许多路由器和公共互联网而成，它是一个信息资源和资源共享的集合。 因特网的 三个发展阶段 ，如下图： 因特网的组成 计算机网络的类别 计算机网络性能 计算机网络体系结构 物理层 物理层的基本概念数据通信的基本知识物理层下面的传输媒体信道复用技术频分复用时分复用统计时分复用码分复用数字传输系统宽带接入技术数据链路层基本概念和基本问题以太局域网(以太网)扩展以太网高速以太网网络层网络层提供的两种服务在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是 网络 还是 端系统 ？ 网际协议 IP划分子网和构造超网网际控制报文协议 ICMP因特网的路由选择协议IP 多播虚拟专用网 VPN 和网络地址转换 NAT","link":"/computerNetwork.html"},{"title":"从 0 开始搭建 Hexo 博客","text":"前言：本教程使用的是 Windows 操作系统，所使用的编辑软件是 notepad++，不要使用记事本或者 Editplus 等编辑软件，会导致乱码从而报错。本博客使用的主题是 icarus，所以主要针对这个主题进行美化。先学会配置这一个主题，然后你再自己去配置自己喜欢的主题。代码顶部左边是代码所处文件的位置，代码的右上角有个小图标，点击即可复制。后期我会把博客版本打包分享给大家，或者推送到 GitHub 分享。 第一阶段：Blog 的环境搭建下载 NodeJs 软件访问官网：www.nodejs.org 选择 LTS 版本即可，如下图所示： 安装 NodeJs安装后 cmd 查看版本，如下图所示: 1234//查看node版本 node -v//查看npm版本 npm -v 安装淘宝镜像回到命令行下，把以下代码复制到命令行中即可安装淘宝镜像。 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完成后，查看 cnpm 版本,截图如下： 1cnpm -v 安装 hexo 并验证安装 hexo 命令如下： 1cnpm install -g hexo-cli 验证 hexo 是否安装成功,截图如下： 1hexo -v 创建 Blog 目录在自己的任何一个盘符上创建一个文件夹，名字随意，建议为 Blog，这个目录必须为空，不要安装或者添加其他的文件，否则会报错。在以后的操作中，都是基于这个目录操作的。如果其间出现问题，都可以把这个目录下的所有文件删除掉，再重新来过。至此，第一阶段结束。以下是我的 Blog 目录演示： 到此为止，博客的环境搭建就完成了。接下来请阅读：第二阶段：Blog 的初始化和 Git 部署。 第二阶段：初始化和 Git 部署Git 的下载安装访问官网：www.git-scm.com/download/ 选择相应操作系统下载安装即可。安装完成之后，点击鼠标右键会出现 Git GUI Here 和 Git Bash Here，如下图所示： 打开 Git 窗口进入到 Blog 目录，点击鼠标右键，选择 Git Bash Here，如下图所示： 初始化博客初始化命令如下： 12# 初始化命令hexo init 初始化完成之后截图如下： 启动博客初始化完成之后就可以启动博客了，启动命令为 “hexo s” ，默认访问地址是:localhost:4000/，如下图所示： 以下是博客的默认主题 landscape，界面如下： Github 注册登录 Github 官网，点击右上角 Sign up，然后出现如下注册界面： 填写完用户名、邮箱和密码之后，然后验证，再点击蓝色的创建按钮即可，如下图： 注册完成后，下图选择左边的 0 元 后面有一些题目，跳过即可，然后你的邮箱会收到 GitHub 的验证消息，然后验证，你就有了Github 账号。示例如下： 创建 Github 仓库新建一个 GitHub 仓库，点击右上角“+”号，然后 New repository，如下图： 非常非常重要的一点，仓库的名字是固定的。格式必须为：GitHub昵称.github.io，填完仓库名点击绿色按钮即可，示例如下： 安装 GitHub 部署插件这一步要先进入到 Blog 目录下，然后点击鼠标右键 Git Bash Here，然后使用以下命令安装插件： 1cnpm install --save hexo-deployer-git 完成之后如下图所示： 配置关键信息，使用 notepad++ 打开 Blog 目录下的 _config.yml 配置文件，按以下配置进行修改： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/guoshizhangsz/guoshizhangsz.github.io.git branch: master 上面的 repo 地址就是你的 GitHub 仓库的地址，打开 GitHub，进入到你的博客仓库，选择 HTTPS，如下图所示： 修改完成之后，保存即可。 把博客部署到 GitHub此时确保在 Blog 目录下，然后使用以下命令： 1hexo d 【期间可能遇到填写邮箱和用户名或者密码等问题】此时要输入 GitHub 账号，如下图所示； 然后输入 GitHub 密码：如下图所示： 部署到 GitHub 成功的标志，如下图： 访问自己的博客在浏览器地址栏中输入 Github昵称.github.io 即可访问，示例如下图： 到此为止，整个博客的搭建以及部署已经完成了。如果需要更换自己的博客主题，或者添加各种插件美化自己的博客，那就请往下阅读：第三阶段：Blog 的基本美化。 第三阶段：Blog 的基本美化配置 icarus 主题第一步，在 Blog 目录下打开 Git Bash Here,然后复制以下命令，粘贴到 Git 窗口： 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 完成之后，如下图所示： 使用 notepad++，把 Blog 目录下的配置文件 _config.yml 打开，然后划到此文件最底部，找到 theme 这个单词，把它的值改为 icarus 即可，如下图命令所示：（以后你换其他的主题，都是这样。） Blog/_config.yml12345678910# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/guoshizhangsz/guoshizhangsz.github.io.git branch: master 第二步，修改完成后保存，回到 Git 窗口按顺序执行以下三个命令： 123456# 把原先编译的文件清理hexo clean# 把配置的信息内容生成hexo g# 启动hexohexo s 打开浏览器访问 4000 端口，如看到以下界面，则代表主题配置成功。 设置主题语言为中文打开 blog 目录下的配置文件 _config.yml，在最顶部 language 那里，把 en 修改为 zh-CN 即可，如下命令所示： Blog/_config.yml123456789101112# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Guo-Blogsubtitle: ''description: '这是我的hexo博客'keywords:author: guoshizhangszlanguage: zh-CNtimezone: '' 修改完成之后保存，hexo g,hexo s 即可。若看到以下蓝色框部分是中文，那么语言修改成功了。如图所示： 第二步，修改顶部红色框标记的那些英文。进入到 Blog 目录，然后进入 themes 目录，然后进入 icarus 目录，打开配置文件 _config.yml，找到 navbar，修改如下所示： Blog/themes/icarus/_config.yml1234567891011121314navbar: # Navigation bar menu links menu: 主页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about # Navigation bar links to be shown on the right links: Download on GitHub: icon: fab fa-github url: 'https://github.com/ppoffice/hexo-theme-icarus'# Footer section link settings 修改完成之后保存，hexo g,hexo s即可。若结果和下图一样，那么修改成功！ 第三步，修改下图的左侧部分： 仍然打开 themes / icarus 下的配置文件，修改如下： Blog/themes/icarus/_config.yml123456789101112131415161718192021widgets: - # Widget name type: profile # Where should the widget be placed, left or right position: left # Author name to be shown in the profile widget author: 情迷法兰西 # Title of the author to be shown in the profile widget author_title: 何以得世间大自在 # Author's current location to be shown in the profile widget location: 普罗旺斯 # Path or URL to the avatar to be shown in the profile widget avatar: # Email address for the Gravatar to be shown in the profile widget gravatar: # Whether to show avatar image rounded or square avatar_rounded: true # Path or URL for the follow button follow_link: 'https://github.com/guoshizhangsz' # Links to be shown on the bottom of the profile widget 把自己的名字、标题和位置修改就行了。还有一项，把这个配置文件的115行和120行修改为 true。建议把它修改为 true。不修改的话，左右两边侧栏会随着页面的滚动而滚动。到这里为止，icarus 主题的基本美化就搞定了。最终效果如下图： 设置网站底部第一步，在网站底部配置运行时间和总访问量。打开 footer.ejs 这个文件，把里面的内容清空，再把以下代码复制进去。 Blog/themes/icarus/layout/common/footer.ejs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;footer class=&quot;footer&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;level&quot;&gt; &lt;div class=&quot;level-start has-text-centered-mobile&quot;&gt; &lt;a class=&quot;footer-logo is-block has-mb-6&quot; href=&quot;&lt;%- url_for('/') %&gt;&quot;&gt; &lt;% if (has_config('logo.text') &amp;&amp; get_config('logo.text')) { %&gt; &lt;%= get_config('logo.text') %&gt; &lt;% } else { %&gt; &lt;img src=&quot;&lt;%- url_for(get_config('logo')) %&gt;&quot; alt=&quot;&lt;%= get_config('title') %&gt;&quot; height=&quot;28&quot;&gt; &lt;% } %&gt; &lt;/a&gt; &lt;p class=&quot;is-size-7&quot;&gt; &amp;copy; &lt;%= date(new Date(), 'YYYY') %&gt; &lt;%= get_config('author') || get_config('title') %&gt;&amp;nbsp; Powered &amp;#10084; ShiZhan·Guo &lt;/p&gt; &lt;/div&gt; &lt;script&gt; (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s); })(); &lt;/script&gt; &lt;div class=&quot;level-end&quot;&gt; &lt;% if (has_config('footer.links')) { %&gt; &lt;div class=&quot;field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle&quot;&gt; &lt;% let links = get_config('footer.links'); %&gt; &lt;% for (let name in links) { let link = links[name]; %&gt; &lt;p class=&quot;control&quot;&gt; &lt;a class=&quot;button is-white &lt;%= typeof(link) !== 'string' ? 'is-large' : '' %&gt;&quot; target=&quot;_blank&quot; title=&quot;&lt;%= name %&gt;&quot; href=&quot;&lt;%= url_for(typeof(link) === 'string' ? link : link.url) %&gt;&quot;&gt; &lt;% if (typeof(link) === 'string') { %&gt; &lt;%= name %&gt; &lt;% } else { %&gt; &lt;i class=&quot;&lt;%= link.icon %&gt;&quot;&gt;&lt;/i&gt; &lt;% } %&gt; &lt;/a&gt; &lt;/p&gt; &lt;% } %&gt; &lt;/div&gt; &lt;% } %&gt; &lt;/div&gt; &lt;div align=&quot;center&quot;&gt; &lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt; &lt;script&gt; var now = new Date(); function createtime() { var grt= new Date(&quot;12/17/2019 12:49:00&quot;);//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 ){hnum = &quot;0&quot; + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = &quot;0&quot; + mnum;} seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 ){snum = &quot;0&quot; + snum;} document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; } setInterval(&quot;createtime()&quot;,250); &lt;/script&gt; &lt;div align=&quot;center&quot;&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot; class=&quot;theme-info&quot;&gt;本站总访问量- &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; -次 &lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot; class=&quot;theme-info&quot;&gt;您是第- &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt; &lt;/span&gt; -位小伙伴 &lt;/span&gt; &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;/div&gt; &lt;/div&gt; &lt;span&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/2.js?i=0xetp0d4rdh&amp;m=7&amp;s=100&amp;c=ff0000&amp;t=1&quot; async=&quot;async&quot;&gt;&lt;/script&gt; &lt;/span&gt; &lt;script&gt; (function(){ var bp = document.createElement('script'); bp.src = '//push.zhanzhang.baidu.com/push.js'; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s); })(); &lt;/script&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;/footer&gt; 复制完成之后保存，回到 git 窗口，使用 pwd 目录查看当前所处的目录，如果不是在 Blog 目录下，请切换到这个目录，然后 hexo g,hexo s。最终效果如图： 动态背景和点击特效把以下代码复制到 icarus / layout / layout.ejs 里面 </body> 上一行即可。 themes/icarus/layout/layout.ejs1234567&lt;!--落花的特效--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/sakura.js&quot;&gt;&lt;/script&gt; &lt;!--鼠标点击效果--&gt; &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/fireworks.js&quot;&gt;&lt;/script&gt; 然后去 js 文件夹下建一个 fireworks.js 文件，名字必须是 fireworks.js。点击右上角复制代码，粘贴到 fireworks.js 里面即可： themes/icarus/source/js/fireworks.js1\"use strict\";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:\"linear\",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(\".fireworks\");if(canvasEl){var ctx=canvasEl.getContext(\"2d\"),numberOfParticules=30,pointerX=0,pointerY=0,tap=\"mousedown\",colors=[\"#FF1461\",\"#18FF92\",\"#5A87FF\",\"#FBF38C\"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+\"px\",canvasEl.style.height=window.innerHeight+\"px\",canvasEl.getContext(\"2d\").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){\"sidebar\"!==e.target.id&amp;&amp;\"toggle-sidebar\"!==e.target.id&amp;&amp;\"A\"!==e.target.nodeName&amp;&amp;\"IMG\"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(\"resize\",setCanvasSize,!1)}\"use strict\";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:\"linear\",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(\".fireworks\");if(canvasEl){var ctx=canvasEl.getContext(\"2d\"),numberOfParticules=30,pointerX=0,pointerY=0,tap=\"mousedown\",colors=[\"#FF1461\",\"#18FF92\",\"#5A87FF\",\"#FBF38C\"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+\"px\",canvasEl.style.height=window.innerHeight+\"px\",canvasEl.getContext(\"2d\").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){\"sidebar\"!==e.target.id&amp;&amp;\"toggle-sidebar\"!==e.target.id&amp;&amp;\"A\"!==e.target.nodeName&amp;&amp;\"IMG\"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(\"resize\",setCanvasSize,!1)}; 然后 hexo clean,hexo g,hexo s 即可。若具有点击效果和落花背景，那么你已经成功了。如下图： 背景图和头像打开 style.styl 文件，照着以下修改； themes/icarus/source/css/style.styl12345body background-image:url(/images/background01.jpg) //设置背景图不随网页的滚动而滚动 background-attachment:fixed background-repeat: no-repeat background01.jpg是themes/icarus/source/images文件夹下的图片，自己在这个文件夹添加自己的背景图片即可，图片名字随意。然后把avatar.png图片删掉，换一个你自己喜欢的头像，但名字仍然要是avatar.png,这样就修改好了博客头像。当然可以去其他地方进行配置，这就自己去研究了。然后hexo clean,hexo g,hexo s。最终效果如下图： 最后顺便说一下，这只是 hexo 里面的一个主题而已，如果你想要配置其他主题，那么请访问 hexo 的官网自行进行选择：https://hexo.io/themes/，配置可能不一样，但也相似。到这里，Blog 的基本美化就结束了。如需更高级配置，请阅读第四阶段：blog 高级美化，添加评论插件，看板娘配置，网易云音乐配置，分享配置，打赏配置等！ 第四阶段：Blog 的高级美化新建文章在 blog 目录下打开 Git 窗口，使用以下命令新建文章： 1hexo n &quot;My-First-Blog&quot; 如下图所示： 文章目录在Blog/source/_posts下，这个时候只有一个My-First-Blog.md文件，如下图： 编辑这个文件，使用 markdown 语法即可。写完之后就是你的第一篇博客文章了。 安装文章插件文章插件的作用就是生成文章的同时还带有一个文件夹，把图片放在这个文件夹里，这样保证在浏览博客文章时图片不显示的问题。安装命令如下： 1cnpm install https://github.com/CodeFalling/hexo-asset-image --save 如图所示： 如果使用以下命令安装，那么可能报错或者没有效果。【主要原因是下载慢，网速可以的话应该是没问题的】如图所示： 1npm install https://github.com/CodeFalling/hexo-asset-image --save 安装完成之后去blog目录下的配置文件中修改 post_asset_folder，把它的值改为 true，然后保存。回到 Git 窗口，重新使用新建文章命令，如图所示： 然后到Blog/source/_posts目录下，你可以看到有一个和文章同名的文件夹生成，如图所示： 阅读全文配置写博客时想把文章的多少内容显示出来，就在那个地方加以下代码： 1&lt;!--more--&gt; 或者在主题配置文件最后加入以下代码： Blog/_config.yml123auto_excerpt: enable: true length: 150 接下来的就是自己写博客发博客了。至于怎么写博客，这里就不在多赘述了。有问题在评论区留言哦！ 添加音乐插件博客如果只有文字和图片，是不是太单调了点呀，那么就来点 Music 吧。至于怎么添加音乐插件以及如何去使用音乐插件，这里就不过多介绍了。按这个链接照做就是了。https://blog.csdn.net/hushhw/article/details/88092728 ，成功后如本博客一样。在这里顺便提一下如何设置页面字体。就是打开 themes/icarus/source/css/style.styl 文件，复制以下代码，把原来的替换即可。 themes/icarus/source/css/style.styl12body, button, input, select, textarea font-family: \"SimHei\", \"Ubuntu\", \"Roboto\", \"Open Sans\", \"Microsoft YaHei\", \"sans-serif\",\"family-sans\" 添加看板娘插件在 blog 目录下打开 Git 窗口，输入以下命令： 1cnpm install --save hexo-helper-live2d 如图所示： 然后到 Blog 下的配置文件 _config.yml 中末尾加入以下代码： Blog/_config.yml1234567891011121314151617# 看板娘插件live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-z16 display: position: left width: 150 height: 300 mobile: show: true 然后保存。回到 Git 窗口，这里要注意：上图橙色框部分要和下面 install 后面的模型要一致，否则没有效果。现在使用以下命令来安装看板娘模型： 1cnpm install live2d-widget-model-z16 如图所示： 最后生成启动 hexo g,hexo s。安装成功后，如下图所示： 配置打赏功能在没有设置打赏之前，页面是这样的： 设置之后是这样的： 其实设置特别简单。打开 themes/icarus/_config.yml 文件，按以下方式进行修改： Blog/themes/icarus/_config.yml1234567891011121314151617181920212223donate: - # Donation entry name type: alipay # Qrcode image URL qrcode: '/images/wechat.png' - # Donation entry name type: wechat # Qrcode image URL qrcode: '/images/wechat.png'# - # Donation entry name #type: paypal # Paypal business ID or email address #business: '' # Currency code #currency_code: USD# - # Donation entry name #type: patreon # URL to the Patreon page #url: ''e 就是把你的微信或支付宝收款码放到 icarus/source/images 目录下，上述图片路径就是这个路径。其他的打赏方式注释或者删除掉就可以了。若要保留，给它们配置图片即可。好了，打赏功能就配置好了。 配置评论功能评论功能和打赏功能是一样的。 把以下代码覆盖 themes/icarus/_config.yml 文件下的 comment 那一部分即可： Blog/themes/icarus/_config.yml1234567891011comment: # Name of the comment plugin type: valine app_id: UNAzhXrv3JomW84YwQoP0rPM-gzGzoHsz app_key: p4TeNM70w95O5YbrAsz381v7 shortname: 不能为空 notify: true verify: false palceholder: Say something... guest_info: nick,mail,link pagesize: 10 这里要说明一下，app_id 和 app_key 是需要自己去注册获取的，我这个应用 ID 可能以后会删除。这是注册应用的地址：https://leancloud.cn/dashboard/login.html#/signin ,具体的使用方法就自己百度一下了，我就不在这里过多的阐述。 然后保存，运行之后的效果如下图： 双栏布局首页有左右侧边栏，其他页面只有左边侧边栏，这样可以在阅读文章的时候更舒服。 1234567891011121314151617181920212223242526272829303132333435363738394041424344+++ includes / helpers / layout.jshexo.extend.helper.register('column_count', function () { let columns = 1;+ if (this.page.__post === true || this.page.__page === true) {+ return 2;+ } const hasColumn = hexo.extend.helper.get('has_column').bind(this); columns += hasColumn('left') ? 1 : 0; columns += hasColumn('right') ? 1 : 0; return columns; });+++ layout / common / widget.ejs&lt;div class=\"column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;\"&gt; &lt;% get_widgets(position).forEach(widget =&gt; {%&gt; &lt;%- _partial('widget/' + widget.type, { widget }) %&gt; &lt;% }) %&gt; &lt;% if (position === 'left') { %&gt;- &lt;div class=\"column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;\"&gt;+ &lt;div class=\"column-right-shadow &lt;%= (page.__page !== true &amp;&amp; page.__post !== true) ? 'is-hidden-widescreen' : '' %&gt; &lt;%= sticky_class('right') %&gt;\"&gt; &lt;% get_widgets('right').forEach(widget =&gt; {%&gt; &lt;%- _partial('widget/' + widget.type, { widget }) %&gt; &lt;% }) %&gt; &lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;% } %&gt;+++ b/layout/layout.ejs &lt;section class=\"section\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"columns\"&gt; &lt;div class=\"column &lt;%= main_column_class() %&gt; has-order-2 column-main\"&gt;&lt;%- body %&gt;&lt;/div&gt; &lt;%- _partial('common/widget', { position: 'left' }) %&gt;+ &lt;% if (page.__page !== true &amp;&amp; page.__post !== true) { %&gt; &lt;%- partial('common/widget', { position: 'right' }) %&gt;+ &lt;% } %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; 文章区域放宽：这个文章内容区域是 12 格布局，可以修改 source / css / style.styl 文件中的 @media screen 样式如下： 1234567891011121314151617+++ css / style.styl@media screen and (min-width: screen-widescreen) .is-1-column .container .is-2-column .container- max-width: screen-desktop - 2 * gap+ max-width: screen-widescreen - 2 * gap- width: screen-desktop - 2 * gap+ width: screen-widescreen - 2 * gap@media screen and (min-width: screen-fullhd) .is-2-column .container- max-width: screen-widescreen - 2 * gap+ max-width: screen-fullhd - 2 * gap- width: screen-widescreen - 2 * gap+ width: screen-fullhd - 2 * gap .is-1-column .container max-width: screen-desktop - 2 * gap width: screen-desktop - 2 * gap 再修改 layout / layout.ejs 和 layout / common / widget.ejs 的文件内容如下： 12345678910111213141516171819202122232425+++ layout / layout.ejs &lt;% function main_column_class() { switch (column_count()) { case 1: return 'is-12'; case 2: return 'is-8-tablet is-9-desktop is-9-widescreen'; case 3: return 'is-8-tablet is-8-desktop is-6-widescreen' } return ''; } %&gt;+++ layout / common / widget.ejs&lt;% function side_column_class() { switch (column_count()) { case 2: return 'is-4-tablet is-3-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } return '';} %&gt; 实现之后的效果就如本博客所示了，首页三栏展示，文章和菜单页两栏展示。以下是我参考的两篇文章：推荐文章地址01：https://dp2px.com/2019/06/04/icarus-theme/推荐文章地址02：https://www.alphalxy.com/2019/03/customize-icarus/ 到这里，博客的基本效果就有了，基本功能也实现了。如果还需要更加高级的配置，可以在评论区留言一起探讨，欢迎大家在评论区留言哦！","link":"/blog-setup.html"},{"title":"歌曲白狐故事","text":"故事背景 故事背景： 西汉 黄昏 郊外 瓢泼的大雨。急急的雨幕里，一只浑身雪白的狐狸正拼命狂奔，躲避身后追赶着它的一群铁骑。年轻的樵夫林生正着急地往家赶，忽然感到身后的背蒌内猛地一沉，忙回头看：只见一只白狐在那里蜷缩一团，浑身瑟瑟发抖，两只眼睛求助似地望着他，黑黑的眸中，分明有泪光在闪烁—-林生只这一看，心中便“倏”地抽搐了一下：多么美丽的白狐呀，多么动人的眼睛！ “喂，小子，可曾看见一只白狐从这儿经过，我们王爷找了它好几天了，要是见了咱们有大赏，可顶你砍好多天柴呢！”“哦，没…。看见了，往南方跑了，快去追吧！”铁骑飞奔而去，留下一路尘泥飞扬。 林生把白狐带回家中，看护了一夜，在第二天霁雨初晴的清晨，把它放归了山林：“去吧，别让坏人又看到了你。”那只白狐飞快地朝林中奔去，在入林深处的刹那，忽地回头，用它那一双似通人性的眼睛深深地望了望林生，便又回头而去了…… 时至北宋时光荏苒，转眼已过千年。深夜，京城一座普通的民居里依然泛着点点的烛光，书生林云鹤了为考取功名正在寒窗苦读，前几次失第让他心急如焚，因为家境的贫寒已无力让他接二连三的名落孙山。 “唉”，读到头疼处，云鹤不由地长叹一声，走出屋门去透透气。呼吸着外面夜里清凉的空气，云鹤心中舒服了许多。忽然，他听到了哭声，而且是一位姑娘在哭，是谁家的女子深夜在此啼哭呢？他循声追去，只见一位一袭雪白的女子立在树荫下正掩面而泣。 “请问小姐，因何在此啼哭，小生可曾帮得上忙？”“公子见谅，小女子打扰了，只因家中忽遭贼人，父母双亡，逃及至此，心中悲愤难当，故此啼哭，不想惊扰了公子，还请莫怪。”说完，便盈盈地拜了下去。云鹤赶忙上前搀扶，双目对视间，云鹤心中猛地一振：多么美丽的姑娘呀，白裙飘飘，长发如云，而这一双眼神，竟又是那么地熟悉，分明在哪里见过！ 小女子名唤潇湘，有一个不请之情，公子之处可否容小女暂避几日，收纳之恩，来日携草衔环，定当重报！”“姑娘如不嬚小生之处贫寒与不便，小生将荣幸之至。”云鹤也不知怎地想也没想，此话就脱口而出——以他堂堂相貌，虽说出身微寒了些，但对他倾心的姑娘也不在少数，共中也不乏有动人姿容者，但他从来就没有动过心—–今天，面对这样一位萍水相逢的女子，竟有种怦然心动的感觉……自此，林云鹤的屋中就少了一份空蓼无人的寂寞，多了一份红袖添香的诗意。 云鹤欣喜地发现，潇湘不仅心灵手巧，而且通读诗文，自她来后，屋里不仅收拾得井井有条，而且给了他很多在诗文写作方面的指正，解开了他心中好多以往不解的迷惑。到了晚上，两个人看书读累时，就拔亮灯芯，联对诗词，望着烛光下有着沉鱼落雁之貌的潇湘，云鹤有时会把持不住地意乱情迷，但一看到潇湘那双夺人心魄的黑黑的大眼睛，多么熟悉呀，似故友重逢，所有的杂念便倾刻间烟消云散了：这是一位多好的姑娘呀，闭月羞花，冰雪聪明，我一定要好好读取功名来迎取她，让她做我名正言顺的妻子。 南海莲花池“潇湘，你可想好了，林云鹤此生无考取功名之命，你又何必苦苦相求呢？”端坐在莲花座上的观士音缓缓地说。 “不，请求大师成全他吧，考取功名，比他的生命还重要呀，潇湘是他千百前放生的白狐，我寻他千年，等待千年，其中的不易艰辛只有潇湘自己知道，如能达公子所愿，小女子为此愿付出一切代价，无怨无悔”“唉，这又是何苦，你知道你将付出何种代价吗？”“知道，我已修身千年幻化为人形，他若考取功名，潇湘会失去五百年的功力，而随时会有不测，但，我愿意。 ”望着满脸泪光和满脸虔诚的潇湘，观士音无奈地摇了摇头：人间自是有情痴，此事无关风和月。“去吧，只要你无怨无悔，他会成功的。”“小女子谢大师成全之恩！”“莫要谢我，这是用你自己半生的仙力换取的。 ” 四“潇湘，我考中了！我考中了！”看榜回来的云鹤,人还未踩进家门，就迫不及待地欢呼着向他的潇湘报告喜讯。可是，潇湘却没象往常一样随声飘出，他急急地进屋一看：哪有姑娘的影子？只见一只浑身雪白的狐正蜷缩在地上瑟瑟发抖，只这一看，林云鹤便昏了过去……不知过了多久，云鹤从昏迷中醒来，朦胧中，他的潇湘正立在床边伤心落泪呢。 “潇湘，快告诉我，你刚才去哪儿了，我们家怎么来了一只白狐……咦，那只白狐去哪儿了呢？”云鹤急急地起床去寻找，被潇湘一把拉住了……“云鹤，莫找，先听我给你讲一个故事好吗？” 缓缓中，潇湘娓娓道来：“千年前，一只白狐被一群王室人员追赶，被一只年轻的樵夫所救，悉心照料，放归山林，才得以修炼千年，成为人形，而那个年轻的樵夫，也经过了千年的轮回，成为了一戒相貌堂堂的书生，为了报答他千百年前的放生之恩，变为人形，前来报恩，那个书生名唤云—鹤，白狐名为潇—-湘，为了公子能榜上有名，潇湘牺牲了五百年的功力，所以一时体力不支，晕倒在地，惊吓了公子，还望公子不要害怕……”这一番话，真正让云鹤傻了，痴了，他终于明白了为什么潇湘为什么会忽然深夜来访，终于明白了为什么他一见到潇湘就感到似曾相识，终于明白了为什么他和潇湘为什么会那么心有灵犀一点通，原来他们之间，是有着千年的缘啊……“潇湘，我不怕，倒更增加了我们要在一起的信心和勇气，因为我们两个是千百年的缘，这是多么不易啊，我们一定要珍惜，我们不要错过，今晚，我带你去一个地方。 ”“什么地方？”“不要问，你去了就知道了。”深深夜色中，潇湘被林云鹤牵着手来到了一个新落成的的庭院前，红红的灯笼映亮了整个院落，整个院内，翠竹亭亭，梅花飘香，再加上红红的烛光，犹如在梦中一般。 “美吗？喜欢吗？云鹤从背后轻轻拥住潇湘，这是我专门为你建造的，我知道你喜欢梅和竹，你就是以后这里的女主人”云鹤喃喃地说。“不会是我的，也不可能是我，”不知为什么，潇湘竟然说出了这样的话。“为什么不可能？不许你这么说！告诉我，我能加科举这几天，想我了吗？”“不想，我才不想呢！”潇湘一脸娇羞。 立在花荫下，潇湘一袭白衣，长发飘飘，云鹤看傻了，看痴了，他紧紧地、紧紧地抱住了这个让他魂牵梦萦了千年的女子，再也不肯放开……忽然，他昏倒在地，任凭潇湘怎么呼唤，也不能醒来…… 南海莲花池“潇湘，云鹤此次得的是不治之症，恐怕性命难保。 “观士音掐指一算，忧心地说。“不，我不信，他不会死的，仁慈的观士菩萨，您一定还有办法的！“潇湘泪流满面。“办法倒是有一个，不过……”“您说，不论何种办法，只要我能做到的，只要能让他起死回生，我愿意……”“潇湘，你可知，他此次金榜高中，被公主一眼相中了么？皇帝有意要招收他为东床驸马，俗话说，天命不可违，皇帝是天子，只要他成为了驸马，皇帝自为倾心给他看病，那时他才有救，而为了他的病能成功治好，你必须让他彻底忘记你！“我，我怎么才能让他彻底忘掉我……？”“用尽你后五百年的功力，功力散尽后，仍为一只白狐，若要幻化人形，必须再修炼千年！，你可要想好了，潇湘……观士音的话，每一字每一句都犹如钢针，针针都刺在潇湘的心尖上，痛得流血，痛得令她无法呼吸……“快点想呀潇湘，时间不等人呀”“我，我，我–愿—意……，观音大师您施法吧。 ”潇湘泪如雨下，他好后，我能看他最后一眼再消失吗？？”观士音看着这位美丽的狐仙，心痛地点了点头。 hdsf公主成婚大典，全国同庆。 林云鹤成为了全宋国人的焦点：金榜提名，东床驸马，一个人生的大喜全都降落在了他一人身上，但他就是高兴不起来，潇湘梦中的一番话令他心如刀绞：“云鹤，我走了，为了你的功名利禄，为了你的健康一生，请忘记潇湘，善待公主，我是你千百年前放生的白狐，今生无缘，来生再聚”…… 金鸾殿内，喜气洋洋，歌舞升平，云鹤呆呆地望着，心中一片空白。 “下面，特邀著名舞女潇湘为公主和驸马舞一曲《梅竹舞》！”云鹤心中猛地一振，睁大了双眼：但见在缓缓的音乐声中，他看到他的潇湘一身红衫红裙飘然入场，红色，吉祥的颜色；红色，祝福的颜色，多么良苦的用心，哦，潇湘，你让我无法呼吸！！记得以前她问他，我穿其它颜色的衣服你满意吗？“只要是你的，我都喜欢。 ”他清楚的记的自己的回答。看惯了白色，没想到她穿红色竟然是那么娇艳动人，夺人魂魄。“能不能为你再跳一支舞我是你千百年前放生的白狐你看衣袂飘飘衣袂飘飘海誓山盟都化成虚无……云鹤傻傻地痴痴地望着眼前这个用心而舞的女子，这个令他魂牵梦萦的女子—–曲终人散，潇湘当众深深一鞠，率先离场，匆匆飘然而去。 在经过大厅将要离去的瞬间，她蓦然回首，深深地望了云鹤一眼，四目相对，流露着多少爱恋与相思，诉说着多少悲愤与无奈：“潇湘，不要离开我，不要离开我，我不要金榜提名，不要洞房花烛，我只要你！！”云鹤在心里嘶鸣着。 “云鹤，忘了我，公主是位好姑娘，是她救了你，一定要好好善待她，善待自己，否则，你就辜负了我的一片苦心，辜负我为你等待千年的情缘，你知道吗，你懂吗？？今生无缘与你结伴走明天，来生化作鸳鸯共婵娟，七金榜提名时洞房花烛夜立在窗外的潇湘看着这一切已哭成了泪人儿，但天意至此，为了她心爱的云鹤能金榜提名，她愿放弃半年的功力；为了他健康一生，她愿意放弃本应属于她的洞房花烛……再见了，云鹤，三生之中我最爱的人，请忘记我，原你一生幸福！！千年之后，如果有缘，让我们再见，到时，还请记得你千百年前放生的白狐，还请记得你金榜提名时烟消云散万劫不复的潇湘……”我爱你时你正一贫如洗寒窗苦读离开你时你正金榜提名洞房花烛我爱你时你是一只修行千年的狐离开你时你已烟消云散万劫不复……每到月圆之夜，云鹤总会却那个他为潇湘新买的庭院静立一个时辰，因为在那亭亭的翠竹中，在那淡痰的梅香里，他总能看到潇湘那美丽的身影：潇湘，我听你的话，善待公主，做一个好驸马，为国为民，但，我却无法做到忘记你，我真的做不到，潇湘，那种思念的味道好苦，好涩，你知道吗？？那种才下眉头，却上心头的感觉你知道吗？我不能让自己有一刻的空闲，因为稍微一刻的空闲我都不能控制自己发疯般的想你，潇湘，你好残忍，你让我日不能安，夜不能寝，你知道吗？？云鹤泪流满面，依稀的泪光中，他似乎又依稀听见潇湘含笑对他说：云鹤，让我再为你跳一支舞，好吗？朦胧的月色中，潇湘裙袂飞扬，长发飘飘，如诗如画，梦幻般的歌舞中，云鹤情不自禁轻轻地着节拍和着： 123456789101112131415161718192021222324252627282930313233343536373839404142434445潇湘：我是一只修行千年的狐 千年修行 千年孤独 夜深人静时 可有人听见我在哭 灯火阑珊处 可有人看见我跳舞云鹤：我是一介书生独醉江湖 十年寒窗 十年苦读 金榜题名时功名利碌光宗耀祖 洞房花烛后阴阳相隔人鬼殊途潇湘：我爱你时 你正一贫如洗寒窗苦读 离开你时 你正金榜题名洞房花烛 能不能为你再跳一支舞 你是我千百年前放生的白狐 你看衣袂飘飘 衣袂飘飘 海誓山盟都化做虚无云鹤：能不能为我再跳一支舞 只为你永别时的那一次回眸 你听仙乐飘飘 仙乐飘飘 今生今世却只能虚度云鹤：我是一介书生独醉江湖 十年寒窗 十年苦读 金榜题名时功名利碌光宗耀祖 洞房花烛后阴阳相隔人鬼殊途 我爱你时 你是一只千年修行的狐 失去你时 你以烟消云散万劫不复潇湘：能不能为你再跳一支舞 我是你千百年前放生的白狐 你看衣袂飘飘 衣袂飘飘 海誓山盟都化做虚无 云鹤：能不能为我再跳一支舞 只为你永别时的那一次回眸 你听仙乐飘飘 仙乐飘飘 今生今世却只能虚度合：能不能为我再跳一支舞你是我千百年前放生的白狐你听仙乐飘飘衣袂飘飘今生今世却只能虚度能不能为我再跳一支舞只为你永别时的那一次回眸你听仙乐飘飘 衣袂飘飘今生今世却只能虚度能不能为我再跳一支舞你是我千百年前放生的白狐你听仙乐飘飘衣袂飘飘今生今世却只能虚度。 人生三重境界看山是山，看水是水bai 从字面意思上解释就du是，看见zhi山就认dao为是山，看见水就认为是水。我们在来到世界的最初都是处于这种境界，是人性最本真的时刻。 所谓的人之初，性本善，便是说的此时。处于这个境界的人一般是还不谙世事的少年，没有经过大风大浪，没有经历难以言说的痛楚，没有体会到生命中有些无法改变的无奈。 没有被人欺骗，没有被人下套，没有领略到社会的黑暗面，没有理由的选择相信，认为怀疑是对别人的不尊重。 我们看过很多的偶像剧，其中赞扬的女主角一般都是处于这个境界，虽然是假的，但却将这一时刻的性格诠释的很好。如《海豚湾恋人》中的易天边，在海边成长，一心追求自己的音乐梦想，一心等待童年时的达达回来。如《天国的阶梯》中的陶艾青，依然相信许愿，喜欢动物，对人毫不设防。 二、看山不是山，看水不是水 从字面上解释就是，看见山觉得山不是山，看见水觉得水不是水。这是一般人在经历一些事后对待人生的一个态度。 被人骗后，选择了不再相信，戴着有色眼镜看待身边的人，看待社会，不愿但又觉得必须怀疑。受伤害后选择了自卫心理，不会大声说出自己的想法。将自己的真性情隐藏在面具之下。有些时候宁愿忍着泪滴看着自己珍视的东西渐渐失去，也不愿意说出自己原来在意，不愿意让人看见自己的脆弱。 这个时候的人最可悲，原本对世界充满爱，对人热情的心，渐渐被冷漠填充，不再相信，不在善良，不愿再去付出。认为一切与人的交集都是功利化的，没有人之初的善良，也没有原本对梦想天真的执著。 三、看山还是山，看水还是水 一般处于这个境界的人都是经历过很多事情后，看穿世事的人。 古代的隐士，如采菊东篱下，悠然见南山的陶渊明，以及一曲高山流水觅知音的伯牙，不屑于权势的梅妻鹤子。 处在这种状态的人看透了人生的各种无奈，了解了其中的辛苦，却能够脱离其中的苦楚，好似出淤泥而不染的莲花，他们脱离了世俗的苦海，寻找到了自己人生的快乐。 菩提本无树，明镜亦非台。本来无一物，何处惹尘埃。 这句佛语怕是他们淡然心态的最好写照。一切毫不在意，万事放下，不为世俗所苦，真正得到超脱。","link":"/fox-story.html"},{"title":"Java 常用 API","text":"内容概要： Object-类 Date-类 DateFormat-类 Calendar-类 System-类 StringBuilder-类 包装类 Object 类Object 概述java.lang.Object 类是 Java 语言中的根类，即所有类的父类。其中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是 Object 类。如果一个类没有特别指定父类，那么默认则继承自 Object 类。例如： 123456789// 以下 MyClass 默认继承 Object 类，所以可写可不写public class MyClass extends Object { // ...}// 不写 extend Object 也可以public class MyClass { // ...} 根据 JDK 源代码及 Object 类的 API 文档，Object 类当中包含的方法有 11 个。我们主要学习其中的 3 个，其他的方法可以自己查阅编程手册去掌握使用。有些方法要在特定的地方使用，以后的教程中会使用到的。 public String toString() ：返回该对象的字符串表示。 public boolean equals(Object obj) ：指示其他某个对象是否与此对象“相等”。 public int hashCode() ：返回该对象的哈希码值。默认情况下，该方法会根据对象的地址来计算。 toString 方法toString 方法返回该对象的字符串表示，其实该字符串内容就是 对象的类型 + @ + 内存地址值 。由于 toString 方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。如果不希望使用 toString 方法的默认行为，则可以对它进行覆盖重写。例如自定义的 Person 类： 1234567891011public class Person { private String name; private int age; @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } // 省略构造器与 Getter Setter ，自行加上即可。} ToString 方法默认是打印地址值，如果不打印，那么说明该类重写了 ToString 方法。以后自己定义类，一般都会重写 ToString 方法。 在 IDEA 中，可以点击菜单栏 Code 中的 Generate.. ，也可以使用快捷键 alt + insert ，点击 toString() 选项来生成此方法。选择相关的成员变量。在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其 toString() 方法。 具体效果如下： 12345678910111213141516public static void main(String[] args) { // 创建一个数组对象 int[] arr = new int[5]; // 使用空参构造创建一个 Person 对象 Person person = new Person(); System.out.println(arr); // 没有重写 ToString() ，所以结果是地址值：[I@12f7a8d System.out.println(person); // 重写了 ToString() ，结果就是重写后的格式：Person{name='null', age=0}}// 输出结果：[I@12f7a8dPerson{name='null', age=0}Process finished with exit code 0 equals 方法public boolean equals(Object obj) ：指示其他某个对象是否与此对象“相等”。调用成员方法 equals 并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。 默认地址比较如果没有覆盖重写 equals 方法，那么 Object 类中默认进行 == 运算符的对象地址比较，只要不是同一个对象，结果必然为 false。 对象内容比较如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写 equals 方法。例如： 12345678910111213141516class Person { private String name; private int age; @Override public boolean equals(Object o) { // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); }} 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数 IDE 都可以自动生成 equals 方法的代码内容。 在 IDEA 中，可以点击菜单栏 Code 中的 Generate.. ，也可以使用快捷键 alt + insert ，并选择 equals() and hashCode() 进行自动代码生成。 代码实践及结果如下： 12345678910111213141516// Person 类在上面创建过了，这里就不创建了public static void main(String[] args) { Person p1 = new Person(\"jack\",23); Person p2 = new Person(\"jack\",23); Person p3 = new Person(\"lisa\",23); System.out.println(\"p1 和 p2 是否相等：\" + p1.equals(p2)); System.out.println(\"p1 和 p3 是否相等：\" + p1.equals(p3));}// 没有重写 equals 方法的结果p1 和 p2 是否相等：falsep1 和 p3 是否相等：false// 重写了 equals 方法后的结果p1 和 p2 是否相等：truep1 和 p3 是否相等：false == 和 equals 的区别：== 是比较运算符，如果比较基本数据类型，那么比较的是他们的数值；如果是引用数据类型，那么比较的是两个对象的地址值。equals 方法在没有重写之前，它和 == 是没有区别的，都是比较地址值。如果重写了 equals 方法，那么 equals 比较的是两个对象的内容，内容一样那么结果就是 true 。 Objects 类了解在刚才 IDEA 自动重写 equals 方法的代码中，使用到了 java.util.Objects 类，那么这个类是什么呢？如果对这个类感兴趣的话，可以参考： https://blog.csdn.net/hj7jay/article/details/55045045 hashCode 方法此方法会返回对象的哈希码值。默认情况下，该方法会根据对象的地址来计算。不同对象的 hashCode() 的值一般是不相同。但是，同一个对象的 hashCode() 值肯定相同。代码演示如下： 123456789101112131415161718public static void main(String[] args) { // 同一对象 hashCode 值相同，不同对象则 hashCode 值不同 Person p1 = new Person(\"jack\",23); Person p2 = new Person(\"lisa\",23); System.out.println(p1.hashCode()); System.out.println(p1.hashCode()); System.out.println(p2.hashCode()); System.out.println(p2.hashCode());}// 输出结果：100882393100882393102982829102982829 Date 类Date 类概述java.util.Date 类表示特定的瞬间，精确到毫秒。查阅 Date 类的描述，发现 Date 类很多方法都已经过时了，如下图： tips: 由于我们处于东八区，所以我们的基准时间为 1970年1月1日8时0分0秒 。 常用方法Date 类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值。 public Date()：空参构造，分配 Date 对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：有参构造，分配 Date 对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 上述两种构造方法简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定 long 类型的构造参数，可以自定义毫秒时刻。代码演示及结果例如： 1234567891011121314151617public static void main(String[] args) { // 创建日期对象，获取当前的时间 Date date = new Date(); System.out.println(date); // 把日期对象转换成对应的时间毫秒值 long time = date.getTime(); System.out.println(time); // 创建日期对象，把当前的毫秒值转成日期对象 System.out.println(new Date(0L)); // 结果：Thu Jan 01 08:00:00 CST 1970}// 输出结果：Sun Apr 05 16:51:35 CST 20201586076695202Thu Jan 01 08:00:00 CST 1970 tips： 在使用 println 方法时，会自动调用 Date 类中的 toString 方法。Date 类对 Object 类中的 toString 方法进行了覆盖重写，所以结果为指定格式的字符串。 DateFormat 类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在 Date 对象与 String 对象之间进行来回转换。 格式化：按照指定的格式，从 Date 对象转换为 String 对象。 解析：按照指定的格式，从 String 对象转换为 Date 对象。 构造方法由于 DateFormat 为抽象类，不能直接使用，所以需要常用的子类 java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。参数 pattern 是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考 SimpleDateFormat 类的 API 文档。 常用方法DateFormat类的常用方法有： public String format(Date date)：将 Date 对象格式化为字符串。 public Date parse(String source)：将字符串解析为 Date 对象。 相关演示代码如下： 1234567891011121314151617public static void main(String[] args) throws Exception { // 01-把 Date 转化成 String：format 方法 Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-@-MM-@-dd HH:mm:ss\"); // 使用 fortmat 方法把日期转化为字符串 String format = simpleDateFormat.format(date); System.out.println(format); // 02-把 String 转化成 Date：parse 方法，对应的日期格式如：2020年12月12日 DateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = \"2020年12月12日\"; // 使用 parse 方法把字符串转化为日期 Date parse = sdf.parse(str); System.out.println(parse);} DateFormat 练习请使用日期时间相关的 API，计算出一个人已经出生了多少天。 解题思路： 获取当前时间对应的毫秒值 获取自己出生日期对应的毫秒值 两个时间相减（当前时间– 出生日期） 具体的代码实现如下： 123456789101112131415161718192021public static void function() throws Exception { System.out.println(\"请输入出生日期 格式 YYYY-MM-dd\"); // 获取出生日期,键盘输入 String birthdayString = new Scanner(System.in).next(); // 将字符串日期,转成Date对象 // 创建SimpleDateFormat对象,写日期模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); // 调用方法parse,字符串转成日期对象 Date birthdayDate = sdf.parse(birthdayString); // 获取今天的日期对象 Date todayDate = new Date(); // 将两个日期转成毫秒值,Date类的方法getTime long birthdaySecond = birthdayDate.getTime(); long todaySecond = todayDate.getTime(); long secone = todaySecond - birthdaySecond; if (secone &lt; 0){ System.out.println(\"还没出生呢\"); } else { System.out.println(secone / 1000 / 60 / 60 / 24); }} Calendar 类Calendar 类概念java.util.Calendar 是日历类，在 Date 后出现，替换掉了许多 Date 的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。 对象创建Calendar 为抽象类，由于语言敏感性，Calendar 类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法：public static Calendar getInstance()：使用默认时区和语言环境获得一个日历。例如： 123public static void main(String[] args) { Calendar cal = Calendar.getInstance();} 常用方法根据 Calendar 类的 API 文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此 Calendar 时间值（从历元到现在的毫秒偏移量）的 Date 对象。 Calendar 类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） 代码实例演示： 1234567891011121314151617/** * java.util.Calendar类:日历类 * Calendar类是一个抽象类,里边提供了很多操作日历字段的方法(YEAR、MONTH、DAY_OF_MONTH、HOUR ) * Calendar类无法直接创建对象使用,里边有一个静态方法叫getInstance(),该方法返回了Calendar类的子类对象 * static Calendar getInstance() 使用默认时区和语言环境获得一个日历。 */public static void main(String[] args) { // 创建 Calendar 对象 Calendar cal = Calendar.getInstance(); // 获取年份 int year = cal.get(Calendar.YEAR); // 获取月份，西方是 0--11月，所以要 + 1 int month = cal.get(Calendar.MONTH) + 1; // 获取天数 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\");} 方法：public int get(int field)：返回给定日历字段的值。参数:传递指定的日历字段(YEAR,MONTH…)返回值:日历字段代表的具体的值 12345678910111213141516public static void main(String[] args) { // 使用 getInstance 方法获取 Calendar 对象 Calendar cal = Calendar.getInstance(); // 获取年份 int year = cal.get(Calendar.YEAR); System.out.println(year); // 获取月份 int month = cal.get(Calendar.MONTH); System.out.println(month); // 西方的月份 0-11 东方: 1-12 // 获取天数 int date = cal.get(Calendar.DATE); System.out.println(date);} 方法：public void set(int field, int value)：将给定的日历字段设置为给定值。参数：int field:传递指定的日历字段(YEAR,MONTH…)参数：int value:给指定字段设置的值 1234567891011121314151617181920212223public static void main(String[] args) { // 使用 getInstance 方法获取 Calendar 对象 Calendar c = Calendar.getInstance(); // 设置年为 9999 c.set(Calendar.YEAR,9999); // 设置月为 9 月 c.set(Calendar.MONTH,9); // 设置日 9 日 c.set(Calendar.DATE,9); // 同时设置年月日,可以使用 set 的重载方法 c.set(8888,8,8); int year = c.get(Calendar.YEAR); System.out.println(year); int month = c.get(Calendar.MONTH); System.out.println(month); // 西方的月份 0-11 东方: 1-12 int date = c.get(Calendar.DATE); System.out.println(date);} 方法：public abstract void add(int field, int amount)：把指定的字段增加/减少指定的值参数：int field:传递指定的日历字段(YEAR,MONTH…)参数：int amount:增加/减少指定的值。正数: 增加 ，负数: 减少 1234567891011121314151617181920public static void main(String[] args) { // 使用 getInstance 方法获取 Calendar 对象 Calendar cal = Calendar.getInstance(); // 把年增加 2 年 cal.add(Calendar.YEAR,2); // 把月份减少 3 个月 cal.add(Calendar.MONTH,-3); // 把天数减少 2 天 cal.add(Calendar.DATE,-2); int year = cal.get(Calendar.YEAR); System.out.println(year); int month = cal.get(Calendar.MONTH); System.out.println(month); int date = cal.get(Calendar.DATE); System.out.println(date);} 方法：public Date getTime()：返回一个表示此 Calendar 时间值（从历元到现在的毫秒偏移量）的 Date 对象。作用：把日历对象,转换为日期对象 1234567public static void main(String[] args) { // 使用 getInstance 方法获取 Calendar 对象 Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date);} 西方星期的开始为周日，中国为周一。在 Calendar 类中，月份的表示是以 0-11 代表 1-12 月。日期是有大小关系的，时间靠后，时间越大。 System 类System 类概述java.lang.System 类中提供了大量的静态方法，可以获取与系统相关的信息或系统级的操作，System 类常用的方法有：① public static long currentTimeMillis()：返回以毫秒为单位的当前时间。② public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 currentTimeMillis 方法实际上，currentTimeMillis 方法就是获取当前系统时间与 1970年01月01日 00:00 点之间的毫秒差值。 1234567891011public static void main(String[] args) { // 获取当前时间毫秒值 Long curr = System.currentTimeMillis(); Long sec = curr / 1000; Long min = sec / 60; Long hour = min / 60; Long day = hour / 24; Long year = day / 365; day = day % 365; System.out.println(\"从1970年1月1日0时0分距今：\" + year + \"年\" + day + \"天\");} currentTimeMillis 练习验证for循环打印数字 1-99999 所需要使用的时间（毫秒）。 12345678public static void main(String[] args) { long start = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) { System.out.println(i); } long end = System.currentTimeMillis(); System.out.println(\"共耗时：\" + (end - start) / 1000 + \"秒\" + (end - start) % 1000 + \"毫秒。\");} arraycopy 方法public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) ：将数组中指定的数据拷贝到另一个数组中。数组的拷贝动作是系统级的，性能很高。System.arraycopy 方法具有5个参数，含义分别为： 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 arraycopy 练习将 src 数组中前3个元素，复制到 dest 数组的前3个位置上复制元素前：src 数组元素 [1,2,3,4,5]，dest 数组元素 [6,7,8,9,10] 复制元素后：src 数组元素[1,2,3,4,5]，dest 数组元素[1,2,3,9,10] 12345678910111213public static void main(String[] args) { int[] src = new int[]{1, 2, 3, 4, 5}; int[] dest = new int[]{6, 7, 8, 9, 10}; System.arraycopy( src, 0, dest, 0, 3);// System.out.println(Arrays.toString(dest)); for (int i = 0; i &lt; dest.length; i++) { System.out.print(dest[i] + \" \"); } } // 运行结果：1 2 3 9 10 StringBuilder 类字符串拼接问题由于 String 类的对象内容不可改变【此类被 final 修饰】，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如： 1234567public class StringDemo { public static void main(String[] args) { String s = \"Hello\"; s += \"World\"; System.out.println(s); }} 在 API 中对 String 类有这样的描述：字符串是常量，它们的值在创建后不能被更改。根据这句话分析我们的代码，其实总共产生了三个字符串，即 &quot;Hello&quot; 、&quot;World&quot; 和 &quot;HelloWorld&quot; 。引用变量 s 首先指向 Hello 对象，最终指向拼接出来的新字符串对象，即 HelloWord 。由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的 String 对象，既耗时，又浪费空间。为了解决这一问题，可以使用 java.lang.StringBuilder 类。 StringBuilder 概述查阅 java.lang.StringBuilder 的 API ，StringBuilder 又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder 会自动维护数组的扩容。(默认16字符空间，超过自动扩充) 构造方法根据 StringBuilder 的 API 文档，常用构造方法有2个： public StringBuilder()：构造一个空的 StringBuilder 容器。public StringBuilder(String str)：构造一个 StringBuilder 容器，并将字符串添加进去。 123456789public static void main(String[] args) { // 无参构造 StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // 空白 // 使用带参构造 StringBuilder sb2 = new StringBuilder(\"jgsu\"); System.out.println(sb2); // jgsu} 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。public String toString()：将当前 StringBuilder 对象转换为 String 对象。 append方法 append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到 StringBuilder 中。例如： 123456789101112131415161718192021222324public static void main(String[] args) { // 创建对象 StringBuilder builder = new StringBuilder(); // public StringBuilder append(任意类型) StringBuilder builder2 = builder.append(\"hello\"); //对比一下 System.out.println(\"builder:\" + builder); System.out.println(\"builder2:\" + builder2); System.out.println(builder == builder2); // true // 可以添加 任何类型 builder.append(\"hello\"); builder.append(\"world\"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如 append 方法一样，代码如下： // 链式编程 builder.append(\"hello\").append(\"world\").append(true).append(100); System.out.println(\"builder:\" + builder);} 备注：StringBuilder 已经覆盖重写了 Object 当中的 toString 方法。 toString方法 通过 toString 方法，StringBuilder 对象将会转换为不可变的 String 对象。如： 123456789public static void main(String[] args) { // 链式创建 StringBuild 对象 StringBuilder sb = new StringBuilder(\"Hello-\").append(\"World-\").append(\"Java\"); // 调用方法 String str = sb.toString(); System.out.println(str); // Hello-World-Java} 相关知识点：可变字符序列其实还有一个类 StringBuffer ，这个类构造方法和常用方法和 StringBuilder 都一样。不同之处在于 StringBuffer 是线程安全的，所以效率低一点，而 StringBuilder 是线程不安全的，性能更高。所以，StringBuffer 适用于用多线程的场景，如果是单线程场合 StringBuilder 更适合。 包装类包装类概述Java提供了两个类型系统，基本类型 与 引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 装箱和拆箱基本类型与对应的包装类对象之间，来回转换的过程称为 装箱 与 拆箱 。 装箱：从基本类型转换为对应的包装类对象。拆箱：从包装类对象转换为对应的基本类型。 用 Integer 与 int 为例【基本数值 &lt;===&gt; 包装对象】： 12345678910public static void main(String[] args) { // 装箱：基本数值 –&gt; 包装对象 Integer a = new Integer(10); // 使用构造函数函数 Integer b = Integer.valueOf(10); // 使用包装类中的valueOf方法 System.out.println(a + b); // 拆箱：包装对象 —&gt; 基本数值 int num = a.intValue(); System.out.println(num);} 自动装箱和自动拆箱由于我们经常要做基本类型与包装类之间的转换，从 Java 5（JDK 1.5） 开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 12345public static void main(String[] args) { Integer i = 10; // 自动装箱：相当于 Integer i = Integer.valueOf(4) i = i + 25; // 等号右边：将 i 对象转成基本数值(自动拆箱) i.intValue() + 5; 加法运算完成后，再次装箱，把基本数值转成对象。 System.out.println(i);} 相互转换基本类型转换为 String 12345基本类型转换 String 有以下几种方式： 1、toString ，先把基本数据类型装箱，再用对象的 toString() 方法 2、String 类的 valueOf() 方法 ，这是一个静态方法，几乎可以把各种类型转换为字符串 3、基本类型直接与 \"\" 相连接即可；如：34 + \"\" 4、如果是数组的话，通过构造方法可以直接把数组转换为字符串 代码演示： 1234567891011121314151617181920public static void main(String[] args) { // 1、toString() 方法 Integer i = 34; System.out.println(i.toString() + 16); // 2、String类的valueOf() 方法 Integer a = 23; System.out.println(String.valueOf(a) + 56); //System.out.println(new String().valueOf(a) + 56); // 3、使用 '+' 连字符与 \" \" 相连 Integer b = 78; System.out.println(b + \"\" + 23); /**最终结果： *3416 *2356 *7823 */ } String 转换成对应的基本类型 除了 Character 类之外，其他所有包装类都具有 parseXxx 静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 代码实例（仅以 Integer 类的静态方法 parseXxx 为例）如： 1234567891011public static void main(String[] args) { byte by = Byte.parseByte(\"4\"); System.out.println(by); int num = Integer.parseInt(\"100\"); System.out.println(num); // 如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出 **`java.lang.NumberFormatException`** 异常 int i = Integer.parseInt(\"100w\"); System.out.println(i);} 上述代码异常如下： 12345674100Exception in thread \"main\" java.lang.NumberFormatException: For input string: \"100w\" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Integer.parseInt(Integer.java:580) at java.lang.Integer.parseInt(Integer.java:615) at edu.jgsu.domain.User.main(User.java:17) 本文已结束，以后还会对不足之处进行改进，将进行持续更新。限于博主水平，有错误之处请评论区告知，我会马上修正。谢谢阅读！❤❤❤","link":"/frequently-API.html"},{"title":"html 入门教程","text":"F:\\00-BLOG-HOME\\source\\gallery\\Front-End 认识网页网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。 &lt;img src=”../gallery/Front-End/mi.png”alt=””&gt; 思考： 网页是如何形成的呢? 常见浏览器介绍1浏览器是网页运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。我们平时称为五大浏览器。 查看浏览器占有的市场份额（知晓）查看网站： http://tongji.baidu.com/data/browser 浏览器内核（理解）12345浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。渲染引擎 它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。JS 引擎 则是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个 ACID 来测试引擎的兼容性和性能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。 （1）Trident(IE内核) 国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。 代表： IE、傲游、世界之窗浏览器、Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。 Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。 （2）Gecko(firefox) Gecko(Firefox 内核)： Mozilla FireFox(火狐浏览器) 采用该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。 可惜这几年已经没落了， 比如 打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。 （3） webkit(Safari) Safari 是苹果公司开发的浏览器，所用浏览器内核的名称是大名鼎鼎的 WebKit。 现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了），苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。 代表浏览器：傲游浏览器3、 Apple Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器， （4） Chromium/Bink(chrome) 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。 ​ 大部分国产浏览器最新版都采用Blink内核。 （5） Presto(Opera) Presto 是挪威产浏览器 opera 的 “前任” 内核，为何说是 “前任”，因为最新的 opera 浏览器早已将之抛弃从而投入到了谷歌怀抱了。 1了解一点： 移动端的浏览器内核主要说的是系统内置浏览器的内核。 目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。 Web标准（重点）通过以上浏览器的内核不同，我们知道他们工作原理、解析肯定不同，显示就会有差别。 1问： 哪个语言再全国基本都可以听得懂？ Web 标准的好处1、让Web的发展前景更广阔2、内容能被更广泛的设备访问3、更容易被搜寻引擎搜索4、降低网站流量费用5、使网站更易于维护6、提高页面浏览速度 Web 标准构成 Web标准不是某一个标准，而是由W3C和其他标准化组织制定的一系列标准的集合。主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。 123结构标准：结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分。样式标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。行为标准：行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分 理想状态我们的源码： .HTML .css .js 1专业的人，写专业的代码 直观感受： 总结WEB标准： 结构标准： 决定你是否有个好天然身体 样式标准： 决定你是否打扮的美丽外观 行为标准： 决定你是否有吸引人的行为 HTML 初识一般先学习HTML+CSS， 这里我们先定一个小目标，先学HTML,后学习CSS。 HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”，主要是通过HTML标签对网页中的文本、图片、声音等内容进行描述。 1&lt;strong&gt; 我是加粗的字体 &lt;/strong&gt; 注意： 体会 文本 标签 语言 几个词语 HTML骨架格式日常生活的书信，我们要遵循共同的约定。 同理：HTML 有自己的语言语法骨架格式： 1234567&lt;HTML&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/HTML&gt; 课堂练习1： 书写我们的第一个HTML 页面！ 新建一个demo 的 TXT 文件。 里面写入刚才的HTML 骨架。 把后缀名改为 .HTML。 右击–谷歌浏览器打开。 1234567891011121314151617181920211 HTML标签：作用所有HTML中标签的一个根节点。2 head标签：作用：用于存放：title,meta,base,style,script,link注意在head标签中我们必须要设置的标签是title3.title标签：作用：让页面拥有一个属于自己的标题。4.body标签：作用：页面在的主体部分，用于存放所有的HTML标签：p,h,a,b,u,i,s,em,del,ins,strong,img 为了便于记忆，我们请出刚才要辞职回家养猪的二师兄来帮忙， 我称之为 猪八戒记忆法 HTML标签分类 在HTML页面中，带有“&lt; &gt;”符号的元素被称为HTML标签，如上面提到的 &lt;HTML&gt;、&lt;head&gt;、&lt;body&gt;都是HTML标签。所谓标签就是放在“&lt; &gt;” 标签符中表示某个功能的编码命令，也称为HTML标签或 HTML元素 1.双标签 1&lt;标签名&gt; 内容 &lt;/标签名&gt; 该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;/标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。和开始标签相比，结束标签只是在前面加了一个关闭符“/”。 1比如 &lt;body&gt;我是文字 &lt;/body&gt; 2.单标签 1&lt;标签名 /&gt; 单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。 1比如 &lt;br /&gt; HTML标签关系标签的相互关系就分为两种： 1.嵌套关系 1&lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; 2.并列关系 12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 测试题： 1请问下列哪个标签是错误的？ 1A &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 1B &lt;strong&gt;&lt;div&gt;&lt;/div&gt;&lt;/strong&gt; 1C &lt;head&gt;&lt;title&gt;&lt;/head&gt;&lt;/title&gt; 1D &lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt; 倡议： 如果两个标签之间的关系是嵌套关系，子元素最好缩进一个tab键的身位。如果是并列关系，最好上下对齐。 开发工具 这些工具你认识几个？ 普通青年 Dreamweaver 文艺青年 sublime 高手和傻子 用记事本 其实。。。。 sublime 一些常用快捷键 点我查看 1234再页面中输入 以下2个单词1. html: 5 2. ! 在sublime里面然后按下tab键盘即可生成HTML骨架 文档类型&lt;!DOCTYPE&gt;1&lt;!DOCTYPE html&gt; 这句话就是告诉我们使用哪个html版本？ 我们使用的是 html 5 的版本。 html有很多版本，那我们应该告诉用户和浏览器我们使用的版本号。 标签位于文档的最前面，用于向浏览器说明当前文档使用哪种 HTML 或 XHTML 标准规范，必需在开头处使用&lt;!DOCTYPE&gt;标签为所有的XHTML文档指定XHTML版本和类型，只有这样浏览器才能按指定的文档类型进行解析。 注意： 一些老网站可能用的还是老版本的文档类型比如 XHTML之类的，但是我们学的是HTML5,而且HTML5的文档类型兼容很好(向下兼容的原则)，所以大家放心的使用HTML5的文档类型就好了。 字符集 utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。 gb2312 简单中文 包括6763个汉字 BIG5 繁体中文 港澳台等用 GBK包含全部中文字符 是GB2312的扩展，加入对繁体字的支持，兼容GB2312 UTF-8则包含全世界所有国家需要用到的字符 1记住一点，以后我们统统使用UTF-8 字符集, 这样就避免出现字符集不统一而引起乱码的情况了。 HTML标签的语义化白话： 所谓标签语义化，就是指标签的含义。 为什么要有语义化标签 方便代码的阅读和维护 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化 核心：合适的地方给一个最为合理的标签。 语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。 不管是谁都能看懂这块内容是什么。 遵循的原则：先确定语义的HTML ，再选合适的CSS。 HTML标签 首先 HTML和CSS是两种完全不同的语言，我们学的是结构，就只写HTML标签，认识标签就可以了。 不会再给结构标签指定样式了。 HTML标签有很多，这里我们学习最为常用的，后面有些较少用的，我们可以查下手册就可以了。 排版标签排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。 标题标签 (熟记) 单词缩写： head 头部. 标题 为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即 、、、、和 1标题标签语义： 作为标题使用，并且依据重要性递减 其基本语法格式如下： 1&lt;hn&gt; 标题文本 &lt;/hn&gt; 注意： h1 标签因为重要，尽量少用，不要动不动就向你扔了一个h1。 一般h1 都是给logo使用。 段落标签( 熟记)单词缩写： paragraph 段落 在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是 1&lt;p&gt; 文本内容 &lt;/p&gt; 是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 水平线标签(认识)单词缩写： horizontal 横线 在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，就是创建横跨网页水平线的标签。其基本语法格式如下： 1&lt;hr /&gt;是单标签 在网页中显示默认样式的水平线。 课堂练习2： 新闻页面 换行标签(熟记)单词缩写： break 打断 ,换行 在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 1&lt;br /&gt; 这时如果还像在word中直接敲回车键换行就不起作用了。 div span标签(重点)div span 是没有语义的 是我们网页布局主要的2个盒子 div 就是 division 的缩写 分割， 分区的意思 其实有很多div 来组合网页。 span, 跨度，跨距；范围 语法格式： 1&lt;div&gt; 这是头部 &lt;/div&gt; &lt;span&gt;今日价格&lt;/span&gt; 文本格式化标签(熟记)在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。 b i s u 只有使用 没有 强调的意思 strong em del ins 语义更强烈 标签属性 属性就是特性 比如 手机的颜色 手机的尺寸 ，总结就是手机的。。 使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下： 1&lt;标签名 属性1=\"属性值1\" 属性2=\"属性值2\" …&gt; 内容 &lt;/标签名&gt; 在上面的语法中， 1.标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。 2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 3.任何标签的属性都有默认值，省略该属性则取默认值。 采取 键值对 的格式 key=”value” 的格式 比如: 1&lt;hr width=\"400\" /&gt; 属性 是 宽度 值 是 400 提倡： 尽量不使用 样式属性。 图像标签img (重点)单词缩写： image 图像 HTML网页中任何元素的实现都要依靠HTML标签，要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签以及和他相关的属性。其基本语法格式如下： 该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。 1&lt;img src=\"图像URL\" /&gt; 链接标签(重点)单词缩写： anchor 的缩写 。基本解释 锚, 铁锚 的 在HTML中创建超链接非常简单，只需用标签环绕需要被链接的对象即可，其基本语法格式如下： 1&lt;a href=\"跳转目标\" target=\"目标窗口的弹出方式\"&gt;文本或图像&lt;/a&gt; href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。 Hypertext Reference的缩写。意思是超文本引用 target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。 注意： 1.外部链接 需要添加 http:// www.baidu.com 2.内部链接 直接链接内部页面名称即可 比如 &lt; a href=”index.html”&gt; 首页 3.如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=”#”)，表示该链接暂时为一个空链接。 4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 锚点定位 （难点）通过创建锚点链接，用户能够快速定位到目标内容。创建锚点链接分为两步： 1231.使用“a href=”#id名&gt;“链接文本\"&lt;/a&gt;创建链接文本。2.使用相应的id名标注跳转目标的位置。 base 标签base 可以设置整体链接的打开状态 base 写到 之间 特殊字符标签 （理解） 注释标签在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。其基本语法格式如下：​ 1&lt;!-- 注释语句 --&gt; 注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。 注释重要性： 路径(重点、难点) 实际工作中，通常新建一个文件夹专门用于存放图像文件，这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。 路径可以分为： 相对路径和绝对路径 相对路径 图像文件和HTML文件位于同一文件夹：只需输入图像文件的名称即可，如&lt;img src=”logo.gif” /&gt;。 图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如&lt;img src=”img/img01/logo.gif” /&gt;。 图像文件位于HTML文件的上一级文件夹：在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，如&lt;img src=”../logo.gif” /&gt;。 绝对路径绝对路径 “D:\\web\\img\\logo.gif”，或完整的网络地址，例如“http://www.itcast.cn/images/logo.gif”。 列表标签什么是列表？ 把…制成表,以表显示 容器里面装载着文字或图表的一种形式，叫列表。 列表最大的特点就是 整齐 、整洁、 有序 无序列表 ul （重点）无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下： 123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt; 比如下面这些，新闻是没有顺序的，不用排队，先到先得，后发布先显示。 脚下留心： 1231. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。2. &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。3. 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！ 有序列表 ol （了解） 有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下： 123456&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ol&gt; 所有特性基本与ul 一致。 但是实际工作中， 较少用 ol ，因此我们用一句话来总结下 ol： 自定义列表（理解）定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下： 12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...&lt;/dl&gt; 用的还可以： 总结 每一天都有一个主题 我们HTML第一天的主题就是 &lt;认识标签&gt; 学HTML 之前 觉得 很神秘 等你学完之后忽然发现 总结今天的思路贯穿线： 表格 table(会使用) 存在即是合理的。 表格的现在还是较为常用的一种标签，但不是用来布局，常见处理、显示表格式数据。 ps: 这些地方用表格，你会觉得生活还是那么美好。。。。忍不住想说 PPAP i hava a pen 创建表格在HTML网页中，要想创建表格，就需要使用表格相关的标签。创建表格的基本语法格式如下： 1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; 在上面的语法中包含三对HTML标签，分别为 &lt;table&gt;&lt;/table&gt;、&lt;tr&gt;&lt;/tr&gt;、&lt;td&gt;&lt;/td&gt;，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释 123451.table用于定义一个表格。2.tr 用于定义表格中的一行，必须嵌套在 table标签中，在 table中包含几对 tr，就有几行表格。3.td /td：用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;/tr&gt;标签中，一对 &lt;tr&gt; &lt;/tr&gt;中包含几对&lt;td&gt;&lt;/td&gt;，就表示该行中有多少列（或多少个单元格）。 注意： 11. &lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt; 12. &lt;td&gt;&lt;/td&gt;标签，他就像一个容器，可以容纳所有的元素 表格属性 表头标签表头一般位于表格的第一行或第一列，其文本加粗居中，如下图所示，即为设置了表头的表格。设置表头非常简单，只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。 表格结构（了解）12345678910在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，我们不在赘述），具体 如下所示：&lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。必须位于&lt;table&gt;&lt;/table&gt; 标签中，一般包含网页的logo和导航等头部信息。&lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体。位于&lt;table&gt;&lt;/table&gt;标签中，一般包含网页中除头部和底部之外的其他内容。 表格标题表格的标题： caption 定义和用法 caption 元素定义表格标题。 123&lt;table&gt; &lt;caption&gt;我是表格标题&lt;/caption&gt;&lt;/table&gt; caption 标签必须紧随 table 标签之后。您只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。 合并单元格(难点)跨行合并：rowspan 跨列合并：colspan 合并单元格的思想： ​ 将多个内容合并的时候，就会有多余的东西，把它删除。 例如 把 3个 td 合并成一个， 那就多余了2个，需要删除。 ​ 公式： 删除的个数 = 合并的个数 - 1 合并的顺序 先上 先左 总结表格 表格提供了HTML 中定义表格式数据的方法。 表格中由行中的单元格组成。 表格中没有列元素，列的个数取决于行的单元格个数。 表格不要纠结于外观，那是CSS 的作用。 ​ 表格的学习要求： 能手写表格结构，并且能合并单元格。 表单标签(掌握)现实中的表单，类似我们去银行办理信用卡填写的单子。 如下图 目的是为了收集用户信息。 在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。 在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 表单控件： ​ 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息： ​ 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域： ​ 他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 input 控件(重点)在上面的语法中，&lt;input /&gt;标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。除了type属性之外，&lt;input /&gt;标签还可以定义很多其他的属性，其常用属性如下表所示。 label标签(理解)label 标签为 input 元素定义标注（标签）。 作用： 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点 如何绑定元素呢？ for 属性规定 label 与哪个表单元素绑定。 12&lt;label for=\"male\"&gt;Male&lt;/label&gt;&lt;input type=\"radio\" name=\"sex\" id=\"male\" value=\"male\"&gt; textarea控件(文本域)如果需要输入大量的信息，就需要用到&lt;textarea&gt;&lt;/textarea&gt;标签。通过textarea控件可以轻松地创建多行文本输入框，其基本语法格式如下： 123&lt;textarea cols=\"每行中的字符数\" rows=\"显示的行数\"&gt; 文本内容&lt;/textarea&gt; 下拉菜单使用select控件定义下拉菜单的基本语法格式如下 123456&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...&lt;/select&gt; 注意： &lt;select&gt;&lt;/select&gt;中至少应包含一对&lt;option&gt;&lt;/option&gt;。 在option 中定义selected =” selected “时，当前项即为默认选中项。 表单域在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。创建表单的基本语法格式如下： 123&lt;form action=\"url地址\" method=\"提交方式\" name=\"表单名称\"&gt; 各种表单控件&lt;/form&gt; 常用属性： Action在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。 method用于设置表单数据的提交方式，其取值为get或post。 name用于指定表单的名称，以区分同一个页面中的多个表单。 注意： 每个表单都应该有自己表单域。 HTML5新标签与特性 文档类型设定 document HTML: sublime 输入 html:4s XHTML: sublime 输入 html:xt HTML5 sublime 输入 html:5 字符设定 ：HTML与XHTML中建议这样去写 ：HTML5的标签中建议这样去写 常用新标签 w3c 手册中文官网 : http://w3school.com.cn/ header：定义文档的页眉 头部 nav：定义导航链接的部分 footer：定义文档或节的页脚 底部 article：定义文章。 section：定义文档中的节（section、区段） aside：定义其所处内容之外的内容 侧边 123456&lt;header&gt; 语义 :定义页面的头部 页眉&lt;/header&gt;&lt;nav&gt; 语义 :定义导航栏 &lt;/nav&gt; &lt;footer&gt; 语义: 定义 页面底部 页脚&lt;/footer&gt;&lt;article&gt; 语义: 定义文章&lt;/article&gt;&lt;section&gt; 语义： 定义区域&lt;/section&gt;&lt;aside&gt; 语义： 定义其所处内容之外的内容 侧边&lt;/aside&gt; ​ datalist 标签定义选项列表。请与 input 元素配合使用该元素 123456789&lt;input type=\"text\" value=\"输入明星\" list=\"star\"/&gt; &lt;!-- input里面用 list --&gt;&lt;datalist id=\"star\"&gt; &lt;!-- datalist 里面用 id 来实现和 input 链接 --&gt; &lt;option&gt;刘德华&lt;/option&gt; &lt;option&gt;刘若英&lt;/option&gt; &lt;option&gt;刘晓庆&lt;/option&gt; &lt;option&gt;郭富城&lt;/option&gt; &lt;option&gt;张学友&lt;/option&gt; &lt;option&gt;郭郭&lt;/option&gt;&lt;/datalist&gt; ​ fieldset 元素可将表单内的相关元素分组，打包 legend 搭配使用 12345&lt;fieldset&gt; &lt;legend&gt;用户登录&lt;/legend&gt; 标题 用户名: &lt;input type=\"text\"&gt;&lt;br /&gt;&lt;br /&gt; 密 码: &lt;input type=\"password\"&gt;&lt;/fieldset&gt; ​ 新增的input type属性值： 类型**** 使用示例**** 含义**** email**** 输入邮箱格式 tel**** 输入手机号码格式 url**** 输入url格式 number**** 输入数字格式 search**** 搜索框（体现语义化） range**** 自由拖动滑块 time**** 小时分钟 date**** 年月日 datetime**** 时间 month**** 月年 week**** 星期 年 常用新属性 属性**** 用法**** 含义**** placeholder**** 占位符 当用户输入的时候 里面的文字消失 删除所有文字，自动返回 autofocus**** 规定当页面加载时 input 元素应该自动获得焦点 multiple**** 多文件上传 autocomplete**** 规定表单是否应该启用自动完成功能 有2个值，一个是on 一个是off on 代表记录已经输入的值 1.autocomplete 首先需要提交按钮 2.这个表单您必须给他名字 required**** 必填项 内容不能为空 accesskey**** 规定激活（使元素获得焦点）元素的快捷键 采用 alt + s的形式 综合案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;form action=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;学生档案&lt;/legend&gt; &lt;label for=\"userName\"&gt;姓名:&lt;/label&gt; &lt;input type=\"text\" name=\"userName\" id=\"userName\" placeholder=\"请输入用户名\"&gt; &lt;br&gt; &lt;label for=\"userPhone\"&gt;手机号码:&lt;/label&gt; &lt;input type=\"tel\" name=\"userPhone\" id=\"userPhone\" pattern=\"^1\\d{10}$\"&gt;&lt;br&gt; &lt;label for=\"email\"&gt;邮箱地址:&lt;/label&gt; &lt;input type=\"email\" required name=\"email\" id=\"email\"&gt;&lt;br&gt; &lt;label for=\"collage\"&gt;所属学院:&lt;/label&gt; &lt;input type=\"text\" name=\"collage\" id=\"collage\" list=\"cList\" placeholder=\"请选择\"&gt;&lt;br&gt; &lt;datalist id=\"cList\"&gt; &lt;option value=\"前端与移动开发学院\"&gt;&lt;/option&gt; &lt;option value=\"java学院\"&gt;&lt;/option&gt; &lt;option value=\"c++学院\"&gt;&lt;/option&gt; &lt;/datalist&gt;&lt;br&gt; &lt;label for=\"score\"&gt;入学成绩:&lt;/label&gt; &lt;input type=\"number\" max=\"100\" min=\"0\" value=\"0\" id=\"score\"&gt;&lt;br&gt; &lt;form action=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;学生档案思密达&lt;/legend&gt; &lt;label&gt;姓名: &lt;input type=\"text\" placeholder=\"请输入学生名字\"/&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;手机号: &lt;input type=\"tel\" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;邮箱: &lt;input type=\"email\" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;所属学院: &lt;input type=\"text\" placeholder=\"请选择学院\" list=\"xueyuan\"/&gt; &lt;datalist id=\"xueyuan\"&gt; &lt;option&gt;java学院&lt;/option&gt; &lt;option&gt;前端学院&lt;/option&gt; &lt;option&gt;php学院&lt;/option&gt; &lt;option&gt;设计学院&lt;/option&gt; &lt;/datalist&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;出生日期: &lt;input type=\"date\" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;成绩: &lt;input type=\"number\" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;毕业时间: &lt;input type=\"date\" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;input type=\"submit\" /&gt; &lt;input type=\"reset\" /&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;label for=\"inTime\"&gt;入学日期:&lt;/label&gt; &lt;input type=\"date\" id=\"inTime\" name=\"inTime\"&gt;&lt;br&gt; &lt;label for=\"leaveTime\"&gt;毕业日期:&lt;/label&gt; &lt;input type=\"date\" id=\"leaveTime\" name=\"leaveTime\"&gt;&lt;br&gt; &lt;input type=\"submit\"&gt; &lt;/fieldset&gt;&lt;/form&gt; 多媒体标签 embed：标签定义嵌入的内容 audio：播放音频 video：播放视频 多媒体 embed（会使用）embed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等。url为音频或视频文件及其路径，可以是相对路径或绝对路径。 因为兼容性问题，我们这里只讲解 插入网络视频， 后面H5会讲解 audio 和video 视频多媒体。 1&lt;embed src=\"http://player.youku.com/player.php/sid/XMTI4MzM2MDIwOA==/v.swf\" allowFullScreen=\"true\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowScriptAccess=\"always\" type=\"application/x-shockwave-flash\"&gt;&lt;/embed&gt; ​ 优酷，土豆，爱奇艺，腾讯、乐视等等 先上传 在分享 多媒体 audioHTML5通过标签来解决音频播放的问题。 使用相当简单，如下图所示 并且可以通过附加属性可以更友好控制音频的播放，如： autoplay 自动播放 controls 是否显不默认播放控件 loop 循环播放 loop = 2 就是循环2次 loop 或者 loop = “-1” 无限循环 由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考 多浏览器支持的方案，如下图 多媒体 videoHTML5通过标签来解决音频播放的问题。 同音频播放一样，使用也相当简单，如下图 同样，通过附加属性可以更友好的控制视频的播放 autoplay 自动播放 controls 是否显示默认播放控件 loop 循环播放 width 设置播放窗口宽度 height 设置播放窗口的高度 由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考 多浏览器支持的方案，如下图**** 总结 HTML 第二天的主题： 熟悉列表— 会使用表格 — 掌握常用表单","link":"/front-html.html"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hello-world.html"},{"title":"Oracle 出现 not logged on","text":"由于好久没有使用 Oracle 数据库，导致密码正确，但出现了 not logged on 这种问题，甚是头疼。于是就写下了这篇教程，希望能够帮助他人解决问题。 解决办法关于 Oracle 数据库 PL/SQL Developer 出现 not logged on 的解决办法如下： 第一步首先正确安装 Oracle 和 plsql 工具，检测是否正确安装 Oracle：在 cmd 命令窗口查看，如下： 第二步打开 plsql 登陆界面，输入用户名 system，密码是你的安装时候的口令（我的为 root），若出现以下界面： 那么此时不要慌，这个时候以 管理员的身份 打开 dos 窗口，然后输入以下命令： 1sqlplus system/root as sysdba; 第三步若连接成功，那么就可以登陆PLSQL了，看左上角标记部分，表示已经登陆成功！如下图： PL/SQL 软件注册码 键 值 Product Code 4t46t6vydkvsxekkvf3fjnpzy5wbuhphqz serial Number 601769 password xs374ca","link":"/oracle-logon.html"},{"title":"Vue 的入门教程","text":"初识 Vue 先修知识： 1、熟悉 HTML2、熟悉 CSS3、熟悉 JavaScript Vue 概述Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的 渐进式 JavaScript 框架 （渐进式就是逐步实现新特性的意思） 。与其它大型框架不同的是，Vue 被设计为可以 自底向上 逐层应用。Vue 的核心库只关注视图层 ，方便与第三方库（vue-router ，vue-resource ，vuex）或既有项目整合。【————百度百科】 Vue 的官方教程： https://cn.vuejs.org/v2/guide/ ，建议在官方教程学习。截图如下： Vue 的官方网站： https://cn.vuejs.org/ ，截图如下： 后面会常用到的 Vue 组件库 ElementUI ， https://element.eleme.cn/#/zh-CN/component/installation ，截图如下： 第一个 Vue 程序我使用的是 IDEA 编写 Vue 程序，只要在 IDEA 安装 Vue.js 插件即可 。建议使用 VSCode 和 WebStorm 等前端 IDE 。第一个 Vue 程序只是看一下效果，具体的语法和其他相关知识下一章节讲解。个人还是建议参照官网教程学习 。程序代码如下： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue01&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 01-view 层，即视图层 --&gt; &lt;div id=\"app\"&gt; {{message}} &lt;/div&gt; &lt;!-- 02-导入 vue.js --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"&gt;&lt;/script&gt; &lt;!-- 03-编写 Vue 对象 --&gt; &lt;script&gt; var vm = new Vue({ /* 绑定 id 为 app 的元素 */ el: \"#app\", // Model：数据 data: { message: \"Hello , Vue !!!\" } }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 第一个 Vue 程序的展示效果如下： 预先了解一下 MVVM 模型 中的 VM ，如下图： Vue 基本语法v-bind 指令前面已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符模板非常类似，但是 Vue 在背后做了大量的工作。现在数据和 DOM 已经建立了关联，所有的东西都是响应式的。我们在控制台操作对象属性，界面可以实时更新。接下来介绍 v-bind 指令，用于绑定元素特性。代码如下： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-bind=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue01&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 01-view 层，即视图层 --&gt; &lt;div id=\"app\"&gt; &lt;span v-bind:title=\"message\"&gt;鼠标悬停，查看提示信息！&lt;/span&gt; &lt;/div&gt; &lt;!-- 02-导入 vue.js --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"&gt;&lt;/script&gt; &lt;!-- 03-编写 Vue 对象 --&gt; &lt;script&gt; var vm = new Vue({ /* 绑定 id 为 app 的元素 */ el: '#app', // Model：数据 data: { message: 'Hello , Vue !!!' } }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; v-bind 指令展示效果如下： TIPS： 在上述代码中，你看到的 v-bind 被称为 指令 。在 Vue 中，指令带有前缀 v- ，用于表示它们是 Vue 提供的特殊特性。它们会在渲染的 DOM 上应用特殊的响应式行为。具体效果如上图。 v-if 和 v-else 指令v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true 值的时候被渲染。因为 v-if 是一个指令，所以必须将它添加到一个元素上 。你可以使用 v-else 指令来 表示 v-if 的 else 块 。具体代码如下： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-bind=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue01&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 01-view 层，即视图层 --&gt; &lt;div id=\"app\"&gt; &lt;h1 v-if=\"num === 1\"&gt;1&lt;/h1&gt; &lt;h1 v-else-if=\"num === 2\"&gt;2&lt;/h1&gt; &lt;h1 v-else&gt;其他数字&lt;/h1&gt; &lt;/div&gt; &lt;!-- 02-导入 vue.js --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"&gt;&lt;/script&gt; &lt;!-- 03-编写 Vue 对象 --&gt; &lt;script&gt; var vm = new Vue({ /* 绑定 id 为 app 的元素 */ el: '#app', // Model：数据 data: { num: 1 } }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; v-if 和 v-else 的效果展示如下： v-for 指令我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组 ，而 item 则是被迭代的 数组元素的别名 。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-bind=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue01&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 01-view 层，即视图层 --&gt; &lt;div id=\"app\"&gt; &lt;!-- 不打印索引 --&gt; &lt;li v-for=\"item in items\"&gt; {{item.message}} &lt;/li&gt; &lt;hr/&gt; &lt;!-- 打印索引 --&gt; &lt;li v-for=\"(item,index) in items\"&gt; {{item.message}} --&gt; {{index}} &lt;/li&gt; &lt;/div&gt; &lt;!-- 02-导入 vue.js --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"&gt;&lt;/script&gt; &lt;!-- 03-编写 Vue 对象 --&gt; &lt;script&gt; var vm = new Vue({ /* 绑定 id 为 app 的元素 */ el: '#app', // Model：数据 data: { items: [ {message: \"从入门到精通\"}, {message: \"从入门到放弃\"}, {message: \"从入门到入狱\"}, {message: \"从删库到跑路\"}, {message: \"从看懂到看开\"} ] } }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; v-for 指令展示效果如下： v-on 指令v-on 指令用于 监听 DOM 事件 ，并在触发时运行一些 JavaScript 代码。代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue01&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 01-view 层，即视图层 --&gt; &lt;div id=\"app\"&gt; &lt;button v-on:click=\"sayHi\"&gt;点击我，有惊喜！！！&lt;/button&gt; &lt;/div&gt; &lt;!-- 02-导入 vue.js --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"&gt;&lt;/script&gt; &lt;!-- 03-编写 Vue 对象 --&gt; &lt;script&gt; var vm = new Vue({ /* 绑定 id 为 app 的元素 */ el: '#app', // Model：数据 data: { message: 'Hello , Vue !!! ' }, // 方法必须定义在 Vue 的 methods 对象中 methods: { sayHi: function () { alert(this.message); } } }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; v-on 指令展示效果如下： 双向数据绑定Vue 是一个 MVVM 框架，即 数据双向绑定 。当数据发生变化的时候，视图也就发生变化。当视图发生变化时，数据也会跟着同步变化。数据双向绑定需要使用 v-model 指令，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue01&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 01-view 层，即视图层 --&gt; &lt;div id=\"app\"&gt; 输入的文本：&lt;input type=\"text\" v-model=\"message\"&gt;&lt;br/&gt; {{message}} &lt;hr/&gt; 性别：&lt;input type=\"radio\" name=\"sex\" value=\"男\" v-model=\"checked\"&gt; 男 &lt;input type=\"radio\" name=\"sex\" value=\"女\" v-model=\"checked\" checked&gt; 女 &lt;br/&gt; 选中的性别：{{checked}} &lt;hr/&gt; 下拉菜单： &lt;select v-model=\"selected\"&gt; &lt;option value=\"\" disabled&gt;---请选择---&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;span&gt; value: {{selected}}&lt;/span&gt; &lt;/div&gt; &lt;!-- 02-导入 vue.js --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"&gt;&lt;/script&gt; &lt;!-- 03-编写 Vue 对象 --&gt; &lt;script&gt; var vm = new Vue({ /* 绑定 id 为 app 的元素 */ el: '#app', // Model：数据 data: { message: \"123\", checked: \"女\", selected: '' } }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 数据双向绑定展示效果如下： Vue 组件什么是组件组件是可复用的 Vue 实例，是一组可重用的模板。详细介绍参考官网：组件基础 组件组织图如下： 基本实例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-bind=\"\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue01&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 01-view 层，即视图层 --&gt; &lt;div id=\"app\"&gt; &lt;!-- 使用自定义组件 My-Component --&gt; &lt;!-- v-bind 中的 guo 是来自于下面 props 属性的值，v-bind:guo=\"item\" 意思是遍历出来的 item 与 guo 进行绑定 --&gt; &lt;guoshizhan v-for=\"item in items\" v-bind:guo=\"item\"&gt;&lt;/guoshizhan&gt; &lt;/div&gt; &lt;!-- 02-导入 vue.js --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"&gt;&lt;/script&gt; &lt;!-- 03-编写 Vue 对象 --&gt; &lt;script&gt; // 定义一个组件，名字为 My-Component 。组件可以理解为自定标签 Vue.component('guoshizhan', { // 此处的 guo 已经与上述 item 绑定，所以取出来的 guo 的值就是 遍历出来的 item 的值 props: ['guo'], template: '&lt;li&gt;{{guo}}&lt;/li&gt;' }) var vm = new Vue({ /* 绑定 id 为 app 的元素 */ el: '#app', data: { items: ['Java', 'Vue', 'HTML'] } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Axios 异步通信 Axios 官网： http://www.axios-js.com 什么是 AxiosAxios 是一个开源的可以用在浏览器端和 NodeJs 的异步通信框架。它的主要作用就是 实现 AJAX 异步通信 。其特性如下： 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF TIPS： Axios 是基于 ES6 规范的，所以使用 ES5 会报错，无法使用。查看 JavaScript 版本 ：settings –&gt; Languages &amp; Frameworks –&gt; JavaScript 第一个 Axios 应用程序Vue 为什么需要使用 Axios 呢？ 由于 Vue 是一个视图层框架，并不包含 AJAX 的通信功能。所以需要使用 Axios 。 由于开发的接口大部分 采用 JSON 格式 ，所以先在根目录下创建一个名为 data.json 的文件，内容如下： 1234567891011{ \"date\": \"2019.12.27\", \"src\": \"https://guoshizhan.github.io/avatar.gif\", \"name\": \"何年の再遇见\", \"desc\": \"愿你走出半生，归来仍是少年\", \"url\": \"https://guoshizhan.github.io\", \"address\": { \"street\": \"学苑路\", \"city\": \"吉安\" }} 在这里提前了解一下 Vue 的生命周期 。以下只提供图片，详情参考 官网教程 。图片如下： 接下来开始写代码。Axios 通过异步请求读取 JSON 数据 。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-bind=\"\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue01&lt;/title&gt; &lt;!-- 解决闪烁问题，让其在网速慢的时候显示白屏，而不会显示未解析的表达式 --&gt; &lt;style&gt; [v-block]{ display: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 01-view 层，即视图层 --&gt; &lt;div id=\"app\" v-clock&gt; &lt;div&gt;{{info.name}}&lt;/div&gt; &lt;div&gt;{{info.src}}&lt;/div&gt; &lt;div&gt;{{info.date}}&lt;/div&gt; &lt;div&gt;{{info.desc}}&lt;/div&gt; &lt;a v-bind:href=\"info.url\"&gt;我的博客&lt;/a&gt; &lt;/div&gt; &lt;!-- 02-导入 vue.js 和 axios.js --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.19.2/axios.min.js\"&gt;&lt;/script&gt; &lt;!-- 03-编写 Vue 对象 --&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#app', data(){ return { // 请求返回的参数必须和 json 字符串一样 info: { date: null, src: null, name: null, desc: null, url: null, } } }, mounted(){ // 钩子函数 链式编程 ES6新特性 。钩子函数在程序执行的时候可以插入到程序中执行 axios.get('./data.json').then(response=&gt;(this.info=response.data)); } }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上述代码展示效果如下： 计算属性模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。所以这个时候就要用到 计算属性 了。详情参考 官网教程 。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-bind=\"\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue01&lt;/title&gt; &lt;!-- 解决闪烁问题，让其在网速慢的时候显示白屏，而不会显示未解析的表达式 --&gt; &lt;style&gt; [v-block]{ display: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 01-view 层，即视图层 --&gt; &lt;div id=\"app\" v-clock&gt; &lt;!-- curTime 是 methods 里面的方法，所以 curTime 后面要加括号 --&gt; &lt;div&gt;curTime : {{curTime()}}&lt;/div&gt; &lt;!-- curTimeComputed 是 computed 里面的方法，所以 curTime 后面不需要加括号 --&gt; &lt;div&gt;curTimeComputed : {{curTimeComputed}}&lt;/div&gt; &lt;/div&gt; &lt;!-- 02-导入 vue.js --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"&gt;&lt;/script&gt; &lt;!-- 03-编写 Vue 对象 --&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#app', data: { message: \"Hello , Vue !!!\" }, methods: { curTime: function () { return Date.now(); // 返回一个时间戳 } }, // 计算属性：methods 和 computed 里面的方法名不能重名。如果重名，只会调用 methods 里面的方法 // 计算属性作用就是将不经常变化的计算结果进行缓存，以节约系统开销 computed: { curTimeComputed: function () { this.message; return Date.now(); // 返回一个时间戳 } } }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 计算属性 页面展示如下： 插槽 slot插槽 这部分有点不好理解，只能举个通俗的例子来解释一下。我们的笔记本有很多接口，有 USB 接口，有 VGA 接口等等。这些* 预留的位置* 就和 Vue 中的插槽类似。更多详情请参考 官网教程 。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-bind=\"\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue01&lt;/title&gt; &lt;!-- 解决闪烁问题，让其在网速慢的时候显示白屏，而不会显示未解析的表达式 --&gt; &lt;style&gt; [v-block]{ display: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 01-view 层，即视图层 --&gt; &lt;div id=\"app\" v-clock&gt; &lt;!-- 使用自己定义的插槽 todo todo-title todo-items --&gt; &lt;todo&gt; &lt;todo-title slot=\"todo-title\" :title=\"title\"&gt;&lt;/todo-title&gt; &lt;todo-items slot=\"todo-items\" v-for=\"item in Items\" :item=\"item\"&gt;&lt;/todo-items&gt; &lt;/todo&gt; &lt;/div&gt; &lt;!-- 02-导入 vue.js --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"&gt;&lt;/script&gt; &lt;!-- 03-编写 Vue 对象 --&gt; &lt;script type=\"text/javascript\"&gt; // 01-定义插槽 todo Vue.component(\"todo\", { template: '&lt;div&gt;' + // 绑定 todo-title 插槽 '&lt;slot name=\"todo-title\"&gt;&lt;/slot&gt;' + '&lt;ul&gt;' + // 绑定 todo-items 插槽 '&lt;slot name=\"todo-items\"&gt;&lt;/slot&gt;' + '&lt;/ul&gt;' + '&lt;/div&gt;' }); // 02-定义插槽 todo-title Vue.component(\"todo-title\",{ props: [\"title\"], template: '&lt;h1&gt;{{title}}&lt;/h1&gt;' }); // 03-定义插槽 todo-items Vue.component(\"todo-items\",{ props: [\"item\"], template: '&lt;li&gt;{{item}}&lt;/li&gt;' }); var vm = new Vue({ el: '#app', data: { title: \"何年の再遇见\", Items: [\"Java\", \"html\", \"Linux\", \"python\"] } }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 插槽的展示效果如下： 自定义事件这部分有点难，请参考 官网教程 。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-bind=\"\" xmlns:v-on=\"\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue01&lt;/title&gt; &lt;!-- 解决闪烁问题，让其在网速慢的时候显示白屏，而不会显示未解析的表达式 --&gt; &lt;style&gt; [v-block]{ display: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 01-view 层，即视图层 --&gt; &lt;div id=\"app\" v-clock&gt; &lt;!-- 使用自己定义的插槽 todo todo-title todo-items --&gt; &lt;todo&gt; &lt;todo-title slot=\"todo-title\" :title=\"title\"&gt;&lt;/todo-title&gt; &lt;todo-items slot=\"todo-items\" v-for=\"(item,index) in Items\" :item=\"item\" :index=\"index\" v-on:remove=\"removeItems\" :key=\"index\"&gt;&lt;/todo-items&gt; &lt;/todo&gt; &lt;/div&gt; &lt;!-- 02-导入 vue.js --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"&gt;&lt;/script&gt; &lt;!-- 03-编写 Vue 对象 --&gt; &lt;script type=\"text/javascript\"&gt; // 01-定义插槽 todo Vue.component('todo', { template: '&lt;div&gt;' + // 绑定 todo-title 插槽 '&lt;slot name=\"todo-title\"&gt;&lt;/slot&gt;' + '&lt;ul&gt;' + // 绑定 todo-items 插槽 '&lt;slot name=\"todo-items\"&gt;&lt;/slot&gt;' + '&lt;/ul&gt;' + '&lt;/div&gt;' }) // 02-定义插槽 todo-title Vue.component('todo-title',{ props: ['title'], template: '&lt;h1&gt;{{title}}&lt;/h1&gt;' }) // 03-定义插槽 todo-items Vue.component('todo-items',{ props: ['item', 'index'], template: '&lt;li&gt;{{item}}--{{index}} &lt;button @click=\"remove\"&gt;删除&lt;/button&gt;&lt;/li&gt;', methods: { remove: function (index) { this.$emit('remove', index); } } }) var vm = new Vue({ el: '#app', data: { title: '何年の再遇见', Items: ['Java', 'html', 'Linux', 'python'] }, methods: { removeItems: function (index) { console.log('删除了 ' + this.Items[index] + ' OK!') this.Items.splice(index, 1) } } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 自定义事件展示效果如下： Vue 正式开始什么是 vue-clivue-cli 官方提供的一个脚手架，用于快速构建一个 vue 的项目模板 。vue-cli 和 Maven 是非常相似的，可以类比学习。vue-cli 的主要功能如下 ： vue-cli 的主要功能： 1、统一目录结构 2、本地调试 3、热部署 4、单元测试 5、集成打包上线 vue-cli 需要的环境： 1、Node.js 2、Git TIPS： 1、Node.js 必须安装好，Git 可以不安装。2、安装教程： https://guoshizhan.club/blog-setup.html#more ，到 安装 hexo 验证 那里就可以了。 第一个 vue-cli 程序附件1 什么是 webpacknpm install webpack -g npm install webpack-cli -g webpack 安装","link":"/vue.html"},{"title":"windows教程","text":"内容概要： CMD 命令大全 Windows 问题解答 装机记录 CMD 命令大全最常用的 CMD 命令 CMD 命令 打开的程序或功能 cmd 进入 DOS 系统 appwiz.cpl 程序和功能（用来查看安装的程序或者卸载程序） calc 计算器 control 控制面板 mspaint 画图板 msconfig 系统配置（常规、引导、服务、启动、工具） sysdm.cpl 系统属性（可用来配置环境变量的） control.exe system 系统（可用来查看计算机的基本信息：版本、是否激活等等） dxdiag DirectX诊断工具 msinfo32 系统信息（硬件资源、组件、软件环境）（win7以上版本） services.msc 本地服务设置 regedt32 注册表 slmgr.vbs -xpr 是否激活windows 偶尔使用的 CMD 命令 CMD命令 打开的程序或功能 write 写字板 notepad 记事本 netplwiz 用户账户（修改开机密码） charmap 字符映射表 devmgmt.msc 设备管理器 psr 步骤记录器 winver windows版本 eventvwr 事件查看器 mmc windows控制台 dcomcnfg 系统组件服务 winmsd 系统信息（XP系统的，win10不适用） main.cpl 鼠标设置 几乎不用的 CMD 命令 CMD命令 打开的程序或功能 osk 屏幕键盘 dialer 打电话 joy.cpl 游戏控制器 iexpress 木马捆绑工具 cliconfg SQL客户端网络实用工具 fxscover 传真封面编辑器 intl.cpl 管理时间 certmgr.msc 证书管理实用程序 narrator 讲述人 mstsc 远程桌面连接 mmsys.cpl 声音设置 DOS 内部命令 DOS 内部命令 打开的程序或功能 ping DOS内部命令（测试网络是否连通）（ping + 域名） net DOS内部命令（管理网络的命令，具体用法百度一下） cls DOS内部命令（清除屏幕） driverquery DOS内部命令（关于驱动的命令，具体用法百度一下） tasklist DOS内部命令（列出运行的任务，具体用法百度一下） tree DOS内部命令（查看目录结构） color DOS内部命令（a，字体颜色为绿色） help DOS内部命令（帮助命令，获取相关的帮助） ipconfig /all DOS内部命令（获取所有的网络配置） ipconfig DOS内部命令（查看本机IP地址，如果这条语句没有用，那么去系统环境变量Path处添加ipconfig的地址，其地址可以在系统盘搜到，搜索ipconfig即可） shutdown -s -t DOS内部命令（设置关机时间，shutdown -s -t 10，10秒后关机） exit 退出DOS系统 windows 问题解答 问题 解决办法 如果电脑连不上网的话 1—cmd—&gt;ipconfig/flushdns（亲测可行）。2—cmd—&gt;netsh winsock reset（比第一种更加高级,但是不建议使用） cmd 激活 Windows10 slmgr /ipk VK7JG-NPHTM-C97JM-9MPGT-3V66T。 slmgr /skms kms.xspace.in。 slmgr /ato 第一次无法开机，第二次才能正常开机 打开powershell（管理员）window+r–&gt;powershell。 输入powercfg -h off。 再输入powercfg -h on。 然后立即重启系统（不要关机，是重启） 装机记录 装机记录： 1、重装系统后只有三个软件，Microsoft Onedrive，NVIDIA图形驱动程序，Update for windows 102、两个 MicroSoft VisualC++ 2015Redisattributable 是由于安装 VMware 带来的3、安装东西有时候要以管理员身份打开，这样能才够安装在自己想安装的盘符下4、新增了两个不知道何时安装的软件：insyde Airplane Mode HID mini-Driver，Realtek High Definition Audio Driver5、重装系统如果出现无法在此电脑安装 Windows 之类的问题，修改一下启动方式，将 UEFI 改为 legacy。如果无法修改，那么使用命令转换格式。具体可以百度到，我也有离线文件可参阅。 U 盘重装系统必须为 NTFS 格式。csdn 解决 windows 无法安装到这个磁盘。选中的磁盘具有mbr分区表。 windows 工具下载：https://www.microsoft.com/zh-cn/software-download/windows10以管理员身份打开某应用： 选择此应用，右键点击属性，然后选择兼容，然后勾选以管理员身份运行","link":"/windows.html"},{"title":"算法入门","text":"内容概要： 算法初识 排序算法 查找算法 常用的算法 其他算法小案例 算法初识算法的度量 时间频度基本介绍时间频度： 一个算法花费的时间与算法中语句的执行次数成正比例 ，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为 语句频度或时间频度 。记为 T(n) 。 时间频度举例比如 计算 1-100 所有数字之和 ， 我们设计了 两种算法 ： 123456789// 01-第一种算法时间频度： T(n) = n + 1int total = 0;int end = 100;for(int i = 1; i &lt; end; i++){ total += i;}// 02-第二种算法时间频度： T(n) = 1total = (1 + end) * end / 2; 注意事项第一： 常数项能够被忽略 ，如下图： 第二： 低次项能够被忽略 ，如下图： 第三： 系数能够被忽略 ，如下图： 时间复杂度基本概念一般情况下，算法中的基本操作 语句的重复执行次数是问题规模 n 的某个函数 ，用 T(n) 表示，若有某个辅助函数 f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n) 是 T(n) 的同数量级函数。记作 T(n) = Ｏ(f(n)) ，称 Ｏ(f(n)) 为算法的 渐进时间复杂度 ，简称 时间复杂度 。 TIPS： T(n) 不同，但时间复杂度可能相同 。 如：T(n) = n² + 7n + 6 与 T(n) = 3n² + 2n + 2 它们的 T(n) 不同，但时间复杂度相同，都为 O(n²) 。 计算方法 用常数 1 代替运行时间中的所有加法常数： T(n) = 3n²+7n+6 =&gt; T(n) = 3n²+7n+1 修改后的运行次数函数中，只保留最高阶项： T(n)=3n²+7n+1 =&gt; T(n) = 3n² 去除最高阶项的系数： T(n) = 3n² =&gt; T(n) = n² =&gt; O(n²) 常见的时间复杂度常见的时间复杂度 如下图： 常数阶 举例： 对数阶 举例： 线性阶 举例： 线性对数阶 举例： 平方阶 举例： 平均 / 最坏时间复杂度平均时间复杂度 和 最坏时间复杂度 的解释都在图中： 空间复杂度 排序算法先看一张图，了解 排序算法 ： 以下是 十大排序算法 ，每种算法都分析了 平均时间复杂度 、最好情况 、最坏情况 、空间复杂度 、排序方式和稳定性 。详情参考下图： 冒泡排序基本介绍在一个数组中，相邻两个元素进行对比，小的放在前，大的放在后，第一轮比完就找到了最大的数并且放在最后。依此类推，直到排序完成。 冒泡排序图解静态图解： 动态图解： 代码实现标准版12345678910111213141516171819202122public class Main { public static void bubbleSort(int[] arr) { if (arr == null || arr.length &lt; 2) { return; } for (int e = arr.length - 1; e &gt; 0; e--) { for (int i = 0; i &lt; e; i++) { if (arr[i] &gt; arr[i + 1]) { swap(arr, i, i + 1); } } } } public static void swap(int[] arr, int i, int j) { arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; }} 代码实现升级版12345678910111213141516171819202122232425262728293031public static void bubbleSort(int[] arr) { // 01-定义一个标志，判断数组相邻位置是否发生交换 boolean flag = false; // 02-对数组进行判断 if (arr == null || arr.length &lt; 2) { return; } // 03-冒泡排序开始 for (int i = arr.length - 1; i &gt; 0; i--) { for (int j = 0; j &lt; i; j++) { if (arr[j] &gt; arr[j + 1]) { // 04-进入 if 判断，说明数组相邻位置发生了交换，将 flag 置为 true flag = true; arr[j] = arr[j] ^ arr[j + 1]; arr[j + 1] = arr[j] ^ arr[j + 1]; arr[j] = arr[j] ^ arr[j + 1]; } } System.out.println(\"第\" + (arr.length - i) + \"趟排序\"); System.out.println(Arrays.toString(arr)); // 05-如果 flag != true ，说明没有进入 if 判断语句，即相邻位置没有发生交换，那么数组已经排好序了，那么 break 跳出循环。 if(flag){ flag = false; } else { break; } }} 算法测试1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void main(String[] args) { // 创建一个数组，并给数组赋随机值 int[] arr = new int[100000]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = (int)(Math.random() * 1000 + 1); } long start = System.currentTimeMillis(); bubbleSort(arr); long end = System.currentTimeMillis(); System.out.println(\"排序 10 万个数据需要 \" + (end - start) / 1000 + \" 秒！\");}public static void bubbleSort(int[] arr) { // 01-定义一个标志，判断数组相邻位置是否发生交换 boolean flag = false; // 02-对数组进行判断 if (arr == null || arr.length &lt; 2) { return; } // 03-冒泡排序开始 for (int i = arr.length - 1; i &gt; 0; i--) { for (int j = 0; j &lt; i; j++) { if (arr[j] &gt; arr[j + 1]) { // 04-进入 if 判断，说明数组相邻位置发生了交换，将 flag 置为 true flag = true; arr[j] = arr[j] ^ arr[j + 1]; arr[j + 1] = arr[j] ^ arr[j + 1]; arr[j] = arr[j] ^ arr[j + 1]; } } //System.out.println(\"第\" + (arr.length - i) + \"趟排序\"); //System.out.println(Arrays.toString(arr)); // 05-如果 flag != true ，说明没有进入 if 判断语句，即相邻位置没有发生交换，那么数组已经排好序了，那么 break 跳出循环。 if(flag){ flag = false; } else { break; } }} 冒泡排序总结：标准版是最好的代码，后面的升级版只适用于数据量比较小的情况，如果数据量比较大，比如算法测试的 10 万个数据，标准版代码 23 秒左右，而升级版是 25 秒左右，慢了几秒钟。原因是大量的判断浪费了时间！！！ 选择排序基本介绍选择排序就是在未排序的数组中，第一个元素和它以后的每一个元素进行比较，若第一个元素大于第 i 个元素，那么两元素交换位置。然后第一个元素继续和第 i + 1 个元素比较，直到结束。第一次比较后的结果找到了最小的数并放在数组第一个位置。后面从第二个数开始和它以后的数比较，以此类推，直到排序完成。 选择排序图解 代码实现标准版123456789101112public static void selectSort(int[] arr) { for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = i + 1; j &lt; arr.length; j++) { if (arr[i] &gt; arr[j]) { int temp; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } }} 代码测试版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;//选择排序public class SelectSort { public static void main(String[] args) { //int [] arr = {101, 34, 119, 1, -1, 90, 123}; //创建要给80000个的随机的数组 int[] arr = new int[80000]; for (int i = 0; i &lt; 80000; i++) { arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数 } System.out.println(\"排序前\"); //System.out.println(Arrays.toString(arr)); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String date1Str = simpleDateFormat.format(data1); System.out.println(\"排序前的时间是=\" + date1Str); selectSort(arr); Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println(\"排序前的时间是=\" + date2Str); //System.out.println(\"排序后\"); //System.out.println(Arrays.toString(arr)); } //选择排序 public static void selectSort(int[] arr) { //在推导的过程，我们发现了规律，因此，可以使用for来解决 //选择排序时间复杂度是 O(n^2) for (int i = 0; i &lt; arr.length - 1; i++) { int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) { if (min &gt; arr[j]) { // 说明假定的最小值，并不是最小 min = arr[j]; // 重置min minIndex = j; // 重置minIndex } } // 将最小值，放在arr[0], 即交换 if (minIndex != i) { arr[minIndex] = arr[i]; arr[i] = min; } //System.out.println(\"第\"+(i+1)+\"轮后~~\"); //System.out.println(Arrays.toString(arr));// 1, 34, 119, 101 } }} 总结：经过综合测试，选择排序的效率比冒泡的效率高。 插入排序基本介绍 插入排序图解 代码实现1234567891011121314public static void insertSort(int[] arr){ for (int i = 1; i &lt; arr.length; i++) { // 01-定义待插入的数 int insertValue = arr[i]; // 02-定义 insertValue 前一个数的索引 int insertIndex = i - 1; while (insertIndex &gt;= 0 &amp;&amp; insertValue &lt; arr[insertIndex]){ arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; } // 03-当退出 while 循环，代表 insertValue &gt; arr[insertIndex] ，所以应该把插入值放到 arr[insertIndex + 1] 的位置 arr[insertIndex + 1] = insertValue; }} 总结：三种排序的效率： 插入排序 &gt; 选择排序 &gt; 冒泡排序 。 希尔排序问题引入 基本介绍 希尔排序图解静态图解： 动态图解： 代码实现采用 交换法 实现希尔排序： 1234567891011121314public static void shellSort(int[] arr){ int temp; for(int gap = arr.length / 2; gap &gt; 0; gap /= 2) { for(int i = gap; i &lt; arr.length; i++){ for(int j = i - gap; j &gt;= 0; j -= gap){ if(arr[j] &gt; arr[j + gap]){ temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; } } } }} 采用 移动法 实现希尔排序： 123456789101112131415public static void shellSort2(int[] arr){ for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) { for (int i = gap; i &lt; arr.length; i++) { int j = i; int temp = arr[j]; if(arr[j] &lt; arr[j - gap]){ while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) { arr[j] = arr[j - gap]; j -= gap; } arr[j] = temp; } } }} 总结一下：交换法实现的希尔排序表插入排序还慢，并且慢好多。然后，重点来了，移动法实现的希尔排序那牛的一批，排序速度非常非常非常快。用数据说话：8万个 数据插入排序 2 ~ 3 秒，800万 数据十多分钟；希尔排序 8万 个数据 10多毫秒，800万 个数据 2 ~ 3 秒。我服了！！！ 快速排序基本介绍 快速排序图解 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static void quickSort(int[] arr, int left, int right) { // 左边下标 int lt = left; // 右边下标 int rt = right; // 中轴值 int pivot = arr[(left + right) / 2]; // 定义临时变量 int temp; // while 循环目的：让比 pivot 小的数在其左边，大的数在其右边 while (lt &lt; rt){ // 在 pivot 左边一直找，找到比 pivot 大就退出 while 循环 while (arr[lt] &lt; pivot){ lt += 1; } // 在 pivot 右边一直找，找到比 pivot 小就退出 while 循环 while (arr[rt] &gt; pivot){ rt -= 1; } if(lt &gt;= rt){ break; } temp = arr[lt]; arr[lt] = arr[rt]; arr[rt] = temp; if(arr[lt] == pivot){ rt--; } if(arr[rt] == pivot){ lt++; } } if(lt == rt){ lt++; rt--; } // 向左递归 if(left &lt; rt){ quickSort(arr, left, rt); } // 向右递归 if(right &gt; lt){ quickSort(arr, lt, right); }} 归并排序基本介绍归并排序（MERGE-SORT） 是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分( divide )成一些小的问题然后递归求解，而治( conquer )的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 归并排序图解静态图解： 动态图解： 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static void main(String[] args) { int[] arr = new int[30]; int[] temp = new int[arr.length]; for (int i = 0; i &lt; 30; i++) { arr[i] = (int) (Math.random() * 70 + 10); } mergeSort(arr, 0, arr.length - 1, temp); System.out.println(Arrays.toString(arr));}public static void mergeSort(int[] arr, int left, int right, int[] temp) { if (left &lt; right) { int mid = (left + right) / 2; // Left recursion(左递归) mergeSort(arr, left, mid, temp); // right recursion(右递归) mergeSort(arr, mid + 1, right, temp); // merge(合并) mergeSort(arr, left, mid, right, temp); }}// 归并排序之合并过程public static void mergeSort(int[] arr, int left, int mid, int right, int[] temp) { int i = left; int j = mid + 1; int t = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) { if (arr[i] &lt;= arr[j]) { temp[t] = arr[i]; t++; i++; } else { temp[t] = arr[j]; t++; j++; } } while (i &lt;= mid) { temp[t] = arr[i]; t++; i++; } while (j &lt;= right) { temp[t] = arr[j]; t++; j++; } t = 0; int tempLeft = left; while (tempLeft &lt;= right) { arr[tempLeft] = temp[t]; t++; tempLeft++; }} 基数排序基本介绍 基数排序图解静态图解： 动态图解： 代码实现12345678910111213141516171819202122232425262728293031323334353637public static void redixSort(int[] arr) { // 00-得到数组中最大的数的位数 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) { if (arr[i] &gt; max) { max = arr[i]; } } int maxLength = (max + \"\").length(); // 得到最大位数是几位数 // 01-定义一个二位数组 代表桶 int[][] bucket = new int[10][arr.length]; // 02-定义一个数组 记录桶中数据个数 int[] counts = new int[10]; for (int i = 0, n = 1; i &lt; maxLength; i++, n *= 10) { for (int j = 0; j &lt; arr.length; j++) { int element = arr[j] / n % 10; bucket[element][counts[element]] = arr[j]; counts[element]++; } int index = 0; // 03-遍历每一个桶，并把桶中的数据放回到原数组 for (int k = 0; k &lt; bucket.length; k++) { // 04-如果桶中有数据，我们才放入到原数组 if (counts[k] != 0) { for (int m = 0; m &lt; counts[k]; m++) { arr[index++] = bucket[k][m]; } } counts[k] = 0; } }} 基数排序说明 堆排序基本介绍堆排序 是一种选择排序 ，是利用 堆 这种数据结构而设计的一种排序算法。具体介绍如下图： 堆排序图解 代码实现堆排序 的代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @Author: guoshizhan * @Create: 2020/7/4 22:53 * @Description: 堆排序 */public class HeapSort { public static void main(String[] args) { // 要求堆数组进行升序排序 int[] arr = {4, 6, 8, 5, 9}; heapSort(arr); } // 编写一个堆排序方法 public static void heapSort(int[] arr) { int temp = 0; System.out.println(\"堆排序！\"); // 将无序序列构成堆 for (int i = arr.length / 2 - 1; i &gt;= 0; i--) { adjustHeap(arr, i, arr.length); } for (int j = arr.length - 1; j &gt; 0; j--) { temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); } System.out.println(Arrays.toString(arr)); // [4, 5, 6, 8, 9] } /** * 将一个数组（二叉树）调整成大顶堆 * * @param arr 代表待调整数组 * @param i 代表非叶子节点再数组中的索引 * @param length 表示堆多少个数组继续调整，length 是逐渐减少的 */ public static void adjustHeap(int[] arr, int i, int length) { int temp = arr[i]; // 取出当前元素的值，保存于 temp 中 // 开始调整。k 是 i 节点的左子节点 for (int k = 2 * i + 1; k &lt; length; k = k * 2 + 1) { if ((k + 1) &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) { // 说明左子节点小于右子节点 k++; } if (arr[k] &gt; temp) { // 如果子节点大于父节点 arr[i] = arr[k]; // 把较大的值赋给当前节点 i = k; // i 指向 k ，继续比较 } else { break; } } // 当 for 循环结束后，我们已经将以 i 为父节点的树的最大值放到了最顶（局部，还不一定是大顶堆） arr[i] = temp; }} 排序算法性能测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317public static void main(String[] args) { // 创建一个 80000 个的随机的数组 int[] arr = new int[80000]; int[] temp = new int[arr.length]; for (int i = 0; i &lt; 80000; i++) { arr[i] = (int) (Math.random() * 8000 + 1); // 生成一个[0, 8000] 数 } long start = System.currentTimeMillis(); //bubbleSort(arr); // 排序 8万数据 需要的时间 = 11 秒 600 毫秒左右 //selectSort(arr); // 排序 8万数据 需要的时间 = 2 秒 700 毫秒左右 //insertSort(arr); // 排序 8万数据 需要的时间 = 1 秒 800 毫秒左右 //shellSort(arr); // 排序 8万数据 需要的时间 = 6 秒 800 毫秒左右 //shellSort2(arr); // 排序 8万数据 需要的时间 = 0 秒 16 毫秒左右 //quickSort(arr, 0, arr.length - 1); // 排序 8万数据 需要的时间 = 0 秒 13 毫秒左右 //mergeSort(arr, 0, arr.length - 1, temp); // 排序 8万数据 需要的时间 = 0 秒 13 毫秒左右 //redixSort(arr); // 排序 8万数据 需要的时间 = 0 秒 10 毫秒 //heapSort(arr); // 排序 8万数据 需要的时间 = 0 秒 10 毫秒 long end = System.currentTimeMillis(); System.out.println(\"排序 8万数据 需要的时间 = \" + (end - start) / 1000 + \" 秒 \" + (end - start) % 1000 + \" 毫秒\");}// 01-冒泡排序public static void bubbleSort(int[] arr) { for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - i - 1; j++) { if (arr[j] &gt; arr[j + 1]) { int temp; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } }}// 02-选择排序public static void selectSort(int[] arr) { //在推导的过程，我们发现了规律，因此，可以使用for来解决 //选择排序时间复杂度是 O(n^2) for (int i = 0; i &lt; arr.length - 1; i++) { int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) { if (min &gt; arr[j]) { // 说明假定的最小值，并不是最小 min = arr[j]; // 重置min minIndex = j; // 重置minIndex } } // 将最小值，放在arr[0], 即交换 if (minIndex != i) { arr[minIndex] = arr[i]; arr[i] = min; } //System.out.println(\"第\"+(i+1)+\"轮后~~\"); //System.out.println(Arrays.toString(arr));// 1, 34, 119, 101 }}// 03-插入排序public static void insertSort(int[] arr){ for (int i = 1; i &lt; arr.length; i++) { // 01-定义待插入的数 int insertValue = arr[i]; // 02-定义 insertValue 前一个数的索引 int insertIndex = i - 1; while (insertIndex &gt;= 0 &amp;&amp; insertValue &lt; arr[insertIndex]){ // 03-如果插入值比它前一个数大，那就没有必要再比较了，直接进入下一轮比较【自己加的代码】 if(insertValue &gt; arr[insertIndex]){ break; } arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; } arr[insertIndex + 1] = insertValue; }}// 04-希尔排序public static void shellSort(int[] arr){ int temp; for(int gap = arr.length / 2; gap &gt; 0; gap /= 2) { for(int i = gap; i &lt; arr.length; i++){ for(int j = i - gap; j &gt;= 0; j -= gap){ if(arr[j] &gt; arr[j + gap]){ temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; } } } }}// 04-希尔排序移位版public static void shellSort2(int[] arr){ for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) { for (int i = gap; i &lt; arr.length; i++) { int j = i; int temp = arr[j]; if(arr[j] &lt; arr[j - gap]){ while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) { arr[j] = arr[j - gap]; j -= gap; } arr[j] = temp; } } }}// 05-快速排序public static void quickSort(int[] arr, int left, int right) { // 左边下标 int lt = left; // 右边下标 int rt = right; // 中轴值 int pivot = arr[(left + right) / 2]; // 定义临时变量 int temp; // while 循环目的：让比 pivot 小的数在其左边，大的数在其右边 while (lt &lt; rt){ // 在 pivot 左边一直找，找到比 pivot 大就退出 while 循环 while (arr[lt] &lt; pivot){ lt += 1; } // 在 pivot 右边一直找，找到比 pivot 小就退出 while 循环 while (arr[rt] &gt; pivot){ rt -= 1; } if(lt &gt;= rt){ break; } temp = arr[lt]; arr[lt] = arr[rt]; arr[rt] = temp; if(arr[lt] == pivot){ rt--; } if(arr[rt] == pivot){ lt++; } } if(lt == rt){ lt++; rt--; } // 向左递归 if(left &lt; rt){ quickSort(arr, left, rt); } // 向右递归 if(right &gt; lt){ quickSort(arr, lt, right); }}// 06-归并排序public static void mergeSort(int[] arr, int left, int right, int[] temp) { if (left &lt; right) { int mid = (left + right) / 2; // Left recursion(左递归) mergeSort(arr, left, mid, temp); // right recursion(右递归) mergeSort(arr, mid + 1, right, temp); // merge(合并) mergeSort(arr, left, mid, right, temp); }}// 归并排序之合并过程public static void mergeSort(int[] arr, int left, int mid, int right, int[] temp) { int i = left; int j = mid + 1; int t = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) { if (arr[i] &lt;= arr[j]) { temp[t] = arr[i]; t++; i++; } else { temp[t] = arr[j]; t++; j++; } } while (i &lt;= mid) { temp[t] = arr[i]; t++; i++; } while (j &lt;= right) { temp[t] = arr[j]; t++; j++; } t = 0; int tempLeft = left; while (tempLeft &lt;= right) { arr[tempLeft] = temp[t]; t++; tempLeft++; }}// 07-基数排序public static void redixSort(int[] arr) { // 00-得到数组中最大的数的位数 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) { if (arr[i] &gt; max) { max = arr[i]; } } int maxLength = (max + \"\").length(); // 得到最大位数是几位数 // 01-定义一个二位数组 代表桶 int[][] bucket = new int[10][arr.length]; // 02-定义一个数组 记录桶中数据个数 int[] counts = new int[10]; for (int i = 0, n = 1; i &lt; maxLength; i++, n *= 10) { for (int j = 0; j &lt; arr.length; j++) { int element = arr[j] / n % 10; bucket[element][counts[element]] = arr[j]; counts[element]++; } int index = 0; // 03-遍历每一个桶，并把桶中的数据放回到原数组 for (int k = 0; k &lt; bucket.length; k++) { // 04-如果桶中有数据，我们才放入到原数组 if (counts[k] != 0) { for (int m = 0; m &lt; counts[k]; m++) { arr[index++] = bucket[k][m]; } } counts[k] = 0; } }}// 08-堆排序// 编写一个堆排序方法public static void heapSort(int[] arr) { int temp = 0; System.out.println(\"堆排序！\"); // 将无序序列构成堆 for (int i = arr.length / 2 - 1; i &gt;= 0; i--) { adjustHeap(arr, i, arr.length); } for (int j = arr.length - 1; j &gt; 0; j--) { temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); } System.out.println(Arrays.toString(arr)); // [4, 5, 6, 8, 9]}/** * 将一个数组（二叉树）调整成大顶堆 * * @param arr 代表待调整数组 * @param i 代表非叶子节点再数组中的索引 * @param length 表示堆多少个数组继续调整，length 是逐渐减少的 */public static void adjustHeap(int[] arr, int i, int length) { int temp = arr[i]; // 取出当前元素的值，保存于 temp 中 // 开始调整。k 是 i 节点的左子节点 for (int k = 2 * i + 1; k &lt; length; k = k * 2 + 1) { if ((k + 1) &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) { // 说明左子节点小于右子节点 k++; } if (arr[k] &gt; temp) { // 如果子节点大于父节点 arr[i] = arr[k]; // 把较大的值赋给当前节点 i = k; // i 指向 k ，继续比较 } else { break; } } // 当 for 循环结束后，我们已经将以 i 为父节点的树的最大值放到了最顶（局部，还不一定是大顶堆） arr[i] = temp;} 查找算法查找 是在大量的信息中寻找一个特定的信息元素。在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。【————百度百科】本文简单介绍了 常见的五种查找算法 ，线性查找 、二分查找 、插值查找 、斐波那契查找 和 哈希查找 。 线性查找线性查找 也称为 顺序查找 ，查找过程为 ：从表中的 最后一个/第一个记录开始 ，逐个进行记录的关键字与给定值进行比较，若某个记录的关键字与给定值相等，则查找成功，找到所查的记录；反之，若 直到第一个/最后一个 记录，其关键字和给定值比较都不相等，则表明表中没有所查的记录，查找失败。 查找一个值查找结果只有一个值 的情况，详情看代码： 12345678910111213141516171819202122232425262728293031public static void main(String[] args) { int[] arr = {-3, 5, 10, 13, 10, 10, 17, 10, 34, 54, 10, 60}; int index = linearSearchOne(arr, 17); if (index == -1) { System.out.println(\"没有查到哦~~~\"); } else { System.out.println(\"找到了，下标为：\" + index); }}// 线性查找（单个值）public static int linearSearchOne(int[] arr, int target) { if (arr == null) { return -1; } // 线性查找是逐一比对，发现有相同值，就返回下标，没找到，返回 -1 for (int i = 0; i &lt; arr.length; i++) { if (target == arr[i]) { return i; } } return -1;} 查找多个值查找结果有多个值 的情况，详情看代码： 1234567891011121314151617181920212223242526272829public static void main(String[] args) { int[] arr = {-3, 5, 10, 13, 10, 10, 17, 10, 34, 54, 10, 60}; List&lt;Integer&gt; list = linearSearchMore(arr, 10); System.out.println(list);}// 线性查找（多个值）public static List&lt;Integer&gt; linearSearchMore(int[] arr, int target) { // 创建集合存储索引 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (arr == null) { return list; } // 线性查找是逐一比对，发现有相同值，就把下标加入到集合里 for (int i = 0; i &lt; arr.length; i++) { if (target == arr[i]) { list.add(i); } } return list;} 二分查找二分查找 也称 折半查找（Binary Search） ，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。【————百度百科】二分查找优点： 比较次数少，查找速度快，平均性能好。 二分查找缺点： 要求待查表为有序表，且插入删除困难。 适用范围： 适用于不经常变动而查找频繁的有序列表 。 算法复杂度： 假设其数组长度为 n ，其算法复杂度为 O（log（n）） 。 算法思想： 首先，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 二分查找-递归二分查找递归图解： 二分查找-递归（只查找一个值） 代码实现： 12345678910111213141516171819202122232425262728public static void main(String[] args) { int[] arr = {10, 20, 30, 40, 50, 60, 70, 80, 90}; int res = binarySearchOne(arr, 0, arr.length - 1, 10); System.out.println(res);}// 二分查找，折半查找算法（只有一个值）public static int binarySearchOne(int[] arr, int left, int right, int target) { // 当数组为空或 left &gt; right 时，说明递归整个数组，但是没有找到，返回 -1 if (arr == null || left &gt; right) { return -1; } int mid = (left + right) / 2; int midVal = arr[mid]; if (target &gt; midVal) { // 向右递归 return binarySearchOne(arr, mid + 1, right, target); } else if (target &lt; midVal) { // 向左递归 return binarySearchOne(arr, left, mid - 1, target); } else { return mid; }} 二分查找-递归（查找多个值） 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static void main(String[] args) { int[] arr = {10, 20, 30, 30, 30, 30, 40, 50, 60, 70, 80, 90}; List&lt;Integer&gt; list = binarySearchMore(arr, 0, arr.length - 1, 30); System.out.println(list);}// 二分查找（有多个值）public static List&lt;Integer&gt; binarySearchMore(int[] arr, int left, int right, int findVal) { //System.out.println(\"hello~\"); // 当数组为空或 left &gt; right 时，说明递归整个数组，但是没有找到 if (arr == null || left &gt; right) { return new ArrayList&lt;&gt;(); } int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal &gt; midVal) { // 向右递归 return binarySearch(arr, mid + 1, right, findVal); } else if (findVal &lt; midVal) { // 向左递归 return binarySearch(arr, left, mid - 1, findVal); } else { // 思路分析： // 1、在找到 mid 索引值，不要马上返回 // 2、向 mid 索引值的左边扫描，将所有满足 findVal 的元素的下标，加入到集合 ArrayList // 3、向 mid 索引值的右边扫描，将所有满足 findVal 的元素的下标，加入到集合 ArrayList // 4、将 Arraylist 返回 List&lt;Integer&gt; resIndexlist = new ArrayList&lt;Integer&gt;(); // 向 mid 索引值的左边扫描，将所有满足 findVal 的元素的下标，加入到集合 ArrayList int temp = mid - 1; while (true) { if (temp &lt; 0 || arr[temp] != findVal) { // 退出 break; } // 否则，就把 temp 放入到 resIndexlist resIndexlist.add(temp); temp -= 1; // temp 左移 } resIndexlist.add(mid); // 把 mid 值加入到集合 // 向 mid 索引值的右边扫描，将所有满足 findVal 的元素的下标，加入到集合 ArrayList temp = mid + 1; while (true) { if (temp &gt; arr.length - 1 || arr[temp] != findVal) { // 退出 break; } // 否则，就把 temp 放入到 resIndexlist resIndexlist.add(temp); temp += 1; // temp 右移 } Collections.sort(resIndexlist); // 此行代码不过说对结果进行排序，不是特别重要。去掉这一行，集合可能乱序 return resIndexlist; }} 二分查找-非递归二分查找-非递归（只有一个值） 代码实现： 12345678910111213141516171819202122232425262728293031public static void main(String[] args) { int[] arr = {10, 20, 30, 30, 30, 30, 40, 50, 60, 70, 80, 90}; int value = binarySearchOne(arr, 40); System.out.println(value);}// 二分查找-非递归（只有一个值）public static int binarySearchOne(int[] arr, int target) { int left = 0; int right = arr.length - 1; while (left &lt;= right) { // 当左边小于等于右边时，一直执行。【数组默认升序】 int mid = (left + right) / 2; if (arr[mid] == target) { return mid; } else if (arr[mid] &gt; target) { right = mid - 1; // 向左边查找 } else { left = mid + 1; // 向右边查找 } } return -1;} 二分查找-非递归（查找多个值） 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void main(String[] args) { int[] arr = {10, 20, 30, 30, 30, 30, 40, 50, 60, 70, 80, 90}; List list = binarySearchMore(arr, -10); System.out.println(list);}public static List&lt;Integer&gt; binarySearchMore(int[] arr, int value) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int left = 0; int right = arr.length - 1; while (left &lt;= right) { // 当左边小于等于右边时，一直执行。【数组默认升序】 int mid = (left + right) / 2; if (arr[mid] == value) { // 向左查找 int temp = mid - 1; while (true) { if (temp &lt; 0 || arr[temp] != value) { break; } list.add(temp); temp -= 1; } list.add(mid); // 向左查找 temp = mid + 1; while (true) { if (temp &gt; arr.length || arr[temp] != value) { break; } list.add(temp); temp += 1; } break; // 一定要写 break; 否则报错：Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space } else if (arr[mid] &gt; value) { right = mid - 1; // 向左边查找 } else { left = mid + 1; // 向右边查找 } } Collections.sort(list); return list;} 插值查找插值查找算法 类似于二分查找，不同的是插值查找每次从 自适应 mid 处 开始查找。将折半查找中的求 mid 索引的公式进行改造 , low 表示左边索引 left, high 表示右边索引 right. key 就是我们要查找的值 。改造的公式如下： 举两个例子来说明 插值查找的快速 ，哈哈，如下图： 查找一个值插值查找（只有一个值） 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738public static void main(String[] args) { int[] arr = {1, 2, 3, 4, 5, 5, 5, 5, 5, 6, 7, 9}; int valueSearch = insertValueSearch(arr, 0, arr.length - 1, 5); System.out.println(valueSearch);}/** * @param arr 数组 * @param left 左边索引 * @param right 右边索引 * @param findVal 查找值 * @return 如果找到，就返回对应的下标，如果没有找到，返回 -1 * 编写插值查找算法，查找一个值。说明：插值查找算法，也要求数组是有序的 */public static int insertValueSearch(int[] arr, int left, int right, int findVal) { System.out.println(\"插值查找次数~~\"); // 注意：findVal &lt; arr[0] 和 findVal &gt; arr[arr.length - 1] 必须需要，否则 mid 可能越界 if (left &gt; right || findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1]) { return -1; } // 求出 mid int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]); int midVal = arr[mid]; if (findVal &gt; midVal) { // 说明应该向右边递归 return insertValueSearch(arr, mid + 1, right, findVal); } else if (findVal &lt; midVal) { // 说明向左递归查找 return insertValueSearch(arr, left, mid - 1, findVal); } else { return mid; }} 查找多个值插值查找（有多个值） 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static void main(String[] args) { int[] arr = {1, 2, 3, 4, 5, 5, 5, 5, 5, 6, 7, 9}; List valueSearch = insertValueSearch(arr, 0, arr.length - 1, 5); System.out.println(valueSearch);}/** * @param arr 数组 * @param left 左边索引 * @param right 右边索引 * @param findVal 查找值 * @return 如果找到，就返回对应的下标，如果没有找到，返回 -1 * 编写插值查找算法，查找多个值。说明：插值查找算法，也要求数组是有序的 */public static List&lt;Integer&gt; insertValueSearch(int[] arr, int left, int right, int findVal) { System.out.println(\"插值查找次数~~\"); if (left &gt; right || findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1]) { return new ArrayList&lt;&gt;(); } int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]); int midVal = arr[mid]; if (findVal &gt; midVal) { // 说明应该向右边递归 return insertValueSearch(arr, mid + 1, right, findVal); } else if (findVal &lt; midVal) { // 说明向左递归查找 return insertValueSearch(arr, left, mid - 1, findVal); } else { ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); int temp = mid - 1; while (true) { if (temp &lt; 0 || arr[temp] != findVal) { break; } arrayList.add(temp); temp--; } arrayList.add(mid); temp = mid + 1; while (true) { if (temp &gt; arr.length || arr[temp] != findVal) { break; } arrayList.add(temp); temp++; } return arrayList; }} 注意事项： 1、对于 数据量较大，关键字分布比较均匀 的查找表来说，采用 插值查找 , 速度较快。2、对于 关键字分布不均匀 的情况下，该方法不一定比折半查找要好。 斐波那契查找黄金分割黄金分割 是指将整体 一分为二 ，较大部分与整体部分的比值 等于 较小部分与较大部分的比值 ，其比值约为 0.618 。这个比例被公认为是最能引起美感的比例，因此被称为 黄金分割 。由于按此比例设计的造型十分美丽，也称为 中外比 。斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数的比例，无限接近 黄金分割值 0.618 ，因此有了 斐波那契查找算法 。 斐波那契原理斐波那契思想 与二分法相类似，不过中间点不再是中点，而变成了 黄金分割点 的附近 mid = low + F(k - 1) - 1 , F 代表斐波那契数列，以下将对 F(k - 1) - 1 进行解释，如下： 12345678910111213# F(k - 1) - 1 含义的理解1、F 代表的斐波那契数列，k 代表斐波那契数列的第 k 个元素2、由 F[k] = F[k-1] + F[k-2] 可以得知，可以得到 F[k] - 1 = (F[k-1] - 1) + (F[k-2] - 1) + 1 。 这个式子说明只要是顺序表的长度为 F[k] - 1 ,就可以分为 (F[k-1] - 1) 和 (F[k-2] - 1) 两段，另外一个 1 就是 mid 位置的元素3、类似的每一个子段也可以用同样的方式来进行分隔4、但是顺序表的长度不一定是恰好等于 F[k] - 1 ,所以需要将原来的顺序表的长度增加到 F[k] - 1 ， 这里的 k 值仅仅需要使得 F[k] - 1 恰好大于或者等于 n ，新增的位置的值，都赋值为下标是 n - 1 位置的值# 如果不理解也没有关系，这个算法有点难度，慢慢来！！！视频多看几遍，代码多敲几遍，慢慢就理解了。 代码实现斐波那契查找（只有一个值） 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class FibonacciSearch { public static int maxSize = 25; public static void main(String[] args) { int[] arr = {1, 8, 10, 89, 1000, 1234}; int res = fibSearch(arr, 1000); System.out.println(\"index = \" + res); } // 因为后面需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列【非递归方式】 public static int[] fib() { int[] arr = new int[maxSize]; arr[0] = 1; arr[1] = 1; for (int i = 2; i &lt; maxSize; i++) { arr[i] = arr[i - 1] + arr[i - 2]; } return arr; } /** * 使用非递归的方式编写斐波那契查找算法 * @param arr 数组 * @param key 我们需要查找的关键码(值) * @return 返回对应的下标，如果没有-1 */ public static int fibSearch(int[] arr, int key) { int low = 0; int high = arr.length - 1; int k = 0; // 表示斐波那契分割数值的下标 int mid = 0; // 存放 mid 值 int fib[] = fib(); //获取到斐波那契数列 // 获取到斐波那契分割数值的下标 while (high &gt; fib[k] - 1) { k++; } // 因为 fib[k] 值可能大于 arr 的长度，因此我们需要构造一个新的数组，不足的部分会使用 0 填充 int[] temp = Arrays.copyOf(arr, fib[k]); // 实际上需求使用 arr 数组最后的数填充 temp // 举例: temp = {1,8, 10, 89, 1000, 1234, 0, 0} =&gt; {1,8, 10, 89, 1000, 1234, 1234, 1234,} for (int i = high + 1; i &lt; temp.length; i++) { temp[i] = arr[high]; } // 使用 while 来循环处理，找到我们的数 key while (low &lt;= high) { mid = low + fib[k - 1] - 1; if (key &lt; temp[mid]) { // 向数组的前面查找(左边) high = mid - 1; /** * 说明：为什么是 k-- * 1、全部元素 = 前面的元素 + 后边元素 * 2、f[k] = f[k-1] + f[k-2] * 3、前面有 f[k-1] 个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3] * 4、即在 f[k-1] 的前面继续查找 k-- ，即下次循环 mid = f[(k-1)-1] - 1 */ k--; } else if (key &gt; temp[mid]) { // 向数组的后面查找(右边) low = mid + 1; /** * 说明：为什么是 k -= 2 * 1、全部元素 = 前面的元素 + 后边元素 * 2、f[k] = f[k-1] + f[k-2] * 3、因为后面有 f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4] * 4、即在f[k-2] 的前面进行查找 k -= 2 ,即下次循环 mid = f[k-1-2] - 1 */ k -= 2; } else { // 找到，需要确定，返回的是哪个下标 if (mid &lt;= high) { return mid; } else { return high; } } } return -1; }} 哈希表基本介绍散列表（Hash table，也叫 哈希表 ），是根据 关键码值 (Key value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做 散列函数 ，存放记录的数组叫做 散列表 。如下图： 问题描述 Google 公司的一个上机题: 有一个公司,当有新的员工来报道时,要求将该 员工的信息【id,性别,年龄,名字,住址..】 加入到系统，当输入该员工的 id 时，要求查找到该员工的所有信息。要求: 不使用数据库，速度越快越好 。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211import java.util.Scanner;/** * @Author: guoshizhan * @Create: 2020/6/12 16:31 * @Description: 哈希表查询 */public class HashTabTest { public static void main(String[] args) { // 创建哈希表 HashTab hashTab = new HashTab(7); // 写一个简单的菜单 String key; Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"add: 添加雇员\"); System.out.println(\"list: 显示雇员\"); System.out.println(\"find: 查找雇员\"); System.out.println(\"exit: 退出系统\"); key = scanner.next(); switch (key) { case \"add\": System.out.println(\"请输入 id：\"); int id = scanner.nextInt(); System.out.println(\"请输入名字：\"); String name = scanner.next(); //创建雇员 Emp emp = new Emp(id, name); hashTab.add(emp); break; case \"list\": hashTab.list(); break; case \"find\": System.out.println(\"请输入要查找的 id：\"); id = scanner.nextInt(); hashTab.findEmpById(id); break; case \"exit\": scanner.close(); System.exit(0); default: break; } } }}// 创建 HashTab 管理多条链表，这就是所谓的哈希表class HashTab { private EmpLinkedList[] empArray; private int size; // 表示有多少条链表 // 创建构造器 public HashTab(int size) { this.size = size; empArray = new EmpLinkedList[size]; // 初始化 empArray // 分别初始化每个链表 for (int i = 0; i &lt; size; i++) { empArray[i] = new EmpLinkedList(); } } // 添加雇员 public void add(Emp emp) { // 根据员工的 id , 得到该员工应当添加到哪条链表 int empLinkedListNO = hashFun(emp.id); // 将 emp 添加到对应的链表中 empArray[empLinkedListNO].add(emp); } // 遍历所有的链表 public void list() { for (int i = 0; i &lt; size; i++) { empArray[i].list(i); } } // 根据输入的 id , 查找雇员 public void findEmpById(int id) { // 使用散列函数确定到哪条链表查找 int empLinkedListNO = hashFun(id); Emp emp = empArray[empLinkedListNO].findEmpById(id); if (emp != null) { // 找到雇员 System.out.printf(\"在第%d条链表中找到雇员 id = %d\\n\", (empLinkedListNO + 1), id); } else { System.out.println(\"在哈希表中，没有找到该雇员~~~\"); } } // 编写散列函数, 使用一个简单取模法 public int hashFun(int id) { return id % size; }}// 定义一个雇员类 Empclass Emp { public int id; public String name; public Emp next; // next 默认为 null public Emp(int id, String name) { super(); this.id = id; this.name = name; }}// 创建 EmpLinkedList 类，表示链表class EmpLinkedList { // 定义头指针 head，指向第一个 Emp 对象 private Emp head; // 默认 null /** * 添加雇员到链表 * 1、假定，当添加雇员时，id 是自增长，即 id 的分配总是从小到大 * 2、因此我们将该雇员直接加入到本链表的最后即可 */ public void add(Emp emp) { // 如果是添加第一个雇员 if (head == null) { head = emp; return; } // 如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后 Emp curEmp = head; while (true) { if (curEmp.next == null) { // 说明到链表最后 break; } curEmp = curEmp.next; // curEmp 后移 } // 退出时直接将 emp 加入链表 curEmp.next = emp; } // 遍历链表的雇员信息 public void list(int no) { if (head == null) { // 说明链表为空 System.out.println(\"第 \" + (no + 1) + \" 条链表为空\"); return; } System.out.print(\"第 \" + (no + 1) + \" 条链表的信息为\"); Emp curEmp = head; while (true) { System.out.printf(\" =&gt; id=%d name=%s \", curEmp.id, curEmp.name); if (curEmp.next == null) { // 说明 curEmp 已经是最后结点 break; } curEmp = curEmp.next; // curEmp 后移 } System.out.println(); } // 根据 id 查找雇员。如果查找到，就返回 Emp 对象, 如果没有找到，就返回 null public Emp findEmpById(int id) { // 判断链表是否为空 if (head == null) { System.out.println(\"链表为空\"); return null; } Emp curEmp = head; while (true) { if (curEmp.id == id) { break; // 这时 curEmp 就指向要查找的雇员 } // 退出条件 if (curEmp.next == null) { // 说明遍历当前链表没有找到该雇员 curEmp = null; break; } curEmp = curEmp.next; } return curEmp; }} 常用的算法分治算法分治算法介绍分治算法 是一种很重要的算法。字面上的解释是 “分而治之” ，就是把一个 复杂的问题 分成两个或更多的相同或相似的 子问题 ，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)…… 分治算法可以求解的一些经典问题： 1、二分搜索&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、大整数乘法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、棋盘覆盖 4、合并排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、快速排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6、线性时间选择 7、最接近点对问题&nbsp;&nbsp;&nbsp;&nbsp;8、循环赛日程表&nbsp;&nbsp;&nbsp;&nbsp;9、汉诺塔问题 求解步骤分治算法 在每一层递归上都有以下 三个步骤 ： 求解步骤： 1、分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题 2、解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题 3、合并：将各个子问题的解合并为原问题的解。 应用：汉诺塔问题汉诺塔的传说： 汉诺塔（又称河内塔）问题 是源于印度一个古老传说的 益智玩具 。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。假如每秒钟一次，共需多长时间呢？移完这些金片需要 5845.54 亿年 以上，太阳系的预期寿命据说也就是数百亿年。真的过了 5845.54 亿年 ，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。 123456789101112131415161718// 汉诺塔移动的方法：使用分治算法// 参数含义：num 代表金属盘个数，L 代表左边的柱子，M 代表中间的柱子，R 代表右边的柱子public static void hanoiTower(int num, char L, char M, char R){ // 如果只有一个盘 if(num == 1){ System.out.println(\"第\" + num + \"个盘从 \" + L + \"--&gt;\" + R); }else { // 如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘：最下边的一个盘 和 上面的所有盘 // 1. 先把 最上面的所有盘 L--&gt;M， 移动过程会使用到 R hanoiTower(num - 1, L, R, M); // 2. 把最下边的盘 L--&gt;R System.out.println(\"第\" + num + \"个盘从 \" + L + \"--&gt;\" + R); // 3. 把 M 塔的所有盘 从 M--&gt;R , 移动过程使用到 L 塔 hanoiTower(num - 1, M , L , R); }} TIPS : 分治算法理解起来容易，就是分而治之。但关键在于： 如何划分，如何把整体划分成部分。解决划分问题，分治算法就算掌握了。 动态规划算法算法介绍动态规划(Dynamic Programming)算法 的 核心思想 是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法。动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是 ，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )动态规划可以通过 填表的方式 来逐步推进，得到最优解。 应用：背包问题背包问题：有一个背包，容量为 4 磅 ， 现有如下物品： 物品 重量 价格 吉他(G) 1 1500 音响(S) 4 3000 电脑(L) 3 2000 问题要求： ① 达到的目标为装入的背包的总价值最大，并且重量不超出。② 要求装入的物品不能重复。 思路分析 代码演示动态规划算法的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package edu.jgsu.algorithm;/** * @Author: guoshizhan * @Create: 2020/3/28 12:08 * @Description: 动态规划算法之背包问题 */public class KnapsackProblem { public static void main(String[] args) { int[] w = {1,4,2}; // 物品的重量 int[] val = {1500,3000,2000}; // 物品的价值 int n = val.length; // 物品的个数 int m = 4; // 背包的容量 // 创建二维数组，v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值 int[][] v = new int[n+1][m+1]; // 为了记录放入商品的情况，我们定一个二维数组 int[][] path = new int[n+1][m+1]; // 初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是 0 for(int i = 0; i &lt; v.length; i++) { v[i][0] = 0; // 将第一列设置为0 } for(int i=0; i &lt; v[0].length; i++) { v[0][i] = 0; // 将第一行设置0 } // 输出一下 v ，看看目前的情况 for(int i =0; i &lt; v.length;i++) { for(int j = 0; j &lt; v[i].length;j++) { System.out.print(v[i][j] + \" \"); } System.out.println(); } System.out.println(\"============================\"); //根据前面得到公式来动态规划处理 for(int i = 1; i &lt; v.length; i++) { //不处理第一行 i是从1开始的 for(int j=1; j &lt; v[0].length; j++) {//不处理第一列, j是从1开始的 //公式 if(w[i-1]&gt; j) { // 因为我们程序i 是从1开始的，因此原来公式中的 w[i] 修改成 w[i-1] v[i][j]=v[i-1][j]; } else { //说明: //因为我们的i 从1开始的， 因此公式需要调整成 //v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]); //v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]); //为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else来体现公式 if(v[i - 1][j] &lt; val[i - 1] + v[i - 1][j - w[i - 1]]) { v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]]; //把当前的情况记录到path path[i][j] = 1; } else { v[i][j] = v[i - 1][j]; } } } } //输出一下v 看看目前的情况 for(int i =0; i &lt; v.length;i++) { for(int j = 0; j &lt; v[i].length;j++) { System.out.printf(\"%04d \",v[i][j]); } System.out.println(); } System.out.println(\"============================\"); //输出最后我们是放入的哪些商品 //遍历path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入// for(int i = 0; i &lt; path.length; i++) {// for(int j=0; j &lt; path[i].length; j++) {// if(path[i][j] == 1) {// System.out.printf(\"第%d个商品放入到背包\\n\", i);// }// }// } //动脑筋 int i = path.length - 1; //行的最大下标 int j = path[0].length - 1; //列的最大下标 while(i &gt; 0 &amp;&amp; j &gt; 0 ) { //从path的最后开始找 if(path[i][j] == 1) { System.out.printf(\"第%d个商品放入到背包\\n\", i); j -= w[i-1]; //w[i-1] } i--; } }} 暴力匹配算法算法介绍 代码演示12345678910111213141516171819202122232425262728public static int violenceMatch(String str1, String str2) { char[] s1 = str1.toCharArray(); char[] s2 = str2.toCharArray(); int s1Len = s1.length; int s2Len = s2.length; int i = 0; // i索引指向s1 int j = 0; // j索引指向s2 while (i &lt; s1Len &amp;&amp; j &lt; s2Len) {// 保证匹配时，不越界 if(s1[i] == s2[j]) {//匹配ok i++; j++; } else { //没有匹配成功 //如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。 i = i - (j - 1); j = 0; } } //判断是否匹配成功 if(j == s2Len) { return i - j; } else { return -1; } } KMP 算法算法介绍 TIPS : KMP 算法关键： 搞懂 部分匹配表 ，就是代码里的那个 next 数组 。参考文章： https://www.cnblogs.com/zzuuoo666/p/9028287.html 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class KMPAlgorithm { public static void main(String[] args) { // TODO Auto-generated method stub String str1 = \"BBC ABCDAB ABCDABCDABDE\"; String str2 = \"ABCDABD\"; //String str2 = \"BBC\"; int[] next = kmpNext(\"ABCDABD\"); //[0, 1, 2, 0] System.out.println(\"next=\" + Arrays.toString(next)); int index = kmpSearch(str1, str2, next); System.out.println(\"index=\" + index); // 15了 } //写出我们的kmp搜索算法 /** * * @param str1 源字符串 * @param str2 子串 * @param next 部分匹配表, 是子串对应的部分匹配表 * @return 如果是-1就是没有匹配到，否则返回第一个匹配的位置 */ public static int kmpSearch(String str1, String str2, int[] next) { //遍历 for(int i = 0, j = 0; i &lt; str1.length(); i++) { //需要处理 str1.charAt(i) ！= str2.charAt(j), 去调整j的大小 //KMP算法核心点, 可以验证... while( j &gt; 0 &amp;&amp; str1.charAt(i) != str2.charAt(j)) { j = next[j-1]; } if(str1.charAt(i) == str2.charAt(j)) { j++; } if(j == str2.length()) {//找到了 // j = 3 i return i - j + 1; } } return -1; } //获取到一个字符串(子串) 的部分匹配值表 public static int[] kmpNext(String dest) { //创建一个next 数组保存部分匹配值 int[] next = new int[dest.length()]; next[0] = 0; //如果字符串是长度为1 部分匹配值就是0 for(int i = 1, j = 0; i &lt; dest.length(); i++) { //当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j //直到我们发现 有 dest.charAt(i) == dest.charAt(j)成立才退出 //这时kmp算法的核心点 while(j &gt; 0 &amp;&amp; dest.charAt(i) != dest.charAt(j)) { j = next[j-1]; } //当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是+1 if(dest.charAt(i) == dest.charAt(j)) { j++; } next[i] = j; } return next; }} 贪心算法算法介绍 应用场景及分析 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package greedy;import java.util.*;/** * @Author: guoshizhan * @Create: 2020/5/15 17:05 * @Description: 贪心算法之集合覆盖问题 */public class Greedy { public static void main(String[] args) { // 创建广播电台，放到 Map 中 Map&lt;String, HashSet&lt;String&gt;&gt; broadcast = new HashMap&lt;&gt;(); // 每个电台对应的城市 HashSet&lt;String&gt; hashSet1 = new HashSet&lt;&gt;(); hashSet1.add(\"北京\"); hashSet1.add(\"上海\"); hashSet1.add(\"天津\"); HashSet&lt;String&gt; hashSet2 = new HashSet&lt;&gt;(); hashSet2.add(\"广州\"); hashSet2.add(\"北京\"); hashSet2.add(\"深圳\"); HashSet&lt;String&gt; hashSet3 = new HashSet&lt;&gt;(); hashSet3.add(\"成都\"); hashSet3.add(\"上海\"); hashSet3.add(\"杭州\"); HashSet&lt;String&gt; hashSet4 = new HashSet&lt;&gt;(); hashSet4.add(\"上海\"); hashSet4.add(\"天津\"); HashSet&lt;String&gt; hashSet5 = new HashSet&lt;&gt;(); hashSet5.add(\"杭州\"); hashSet5.add(\"大连\"); // 加入到 Map broadcast.put(\"K1\", hashSet1); broadcast.put(\"K2\", hashSet2); broadcast.put(\"K3\", hashSet3); broadcast.put(\"K4\", hashSet4); broadcast.put(\"K5\", hashSet5); // 存放所有地区，且不重复 HashSet&lt;String&gt; allAreas = new HashSet&lt;&gt;(); Set&lt;Map.Entry&lt;String, HashSet&lt;String&gt;&gt;&gt; entries = broadcast.entrySet(); for (Map.Entry&lt;String, HashSet&lt;String&gt;&gt; entry : entries) { HashSet&lt;String&gt; value = entry.getValue(); for (String s : value) { allAreas.add(s); } } // 查看地区是否正确 System.out.println(allAreas); // 创建 ArrayList 集合，存放已选择的电台 ArrayList&lt;String&gt; selects = new ArrayList&lt;&gt;(); // 定义一个临时集合， 存放电台覆盖的地区和还未覆盖的地区的交集 HashSet&lt;String&gt; tempSet = new HashSet&lt;&gt;(); // 定义 maxKey ，保存电台的 Key【能够覆盖最多未覆盖地区的那个电台的 Key。例如：K1 】 String maxKey = null; // 如果不为 0 ，则表示还没有覆盖到所有地区 while (allAreas.size() != 0) { // 每进行一次 while 循环，maxKey 就要置为空 maxKey = null; // 遍历 broadcast ，取出对应 key for (String key : broadcast.keySet()) { // 每进行一次 for 循环，tempSet 就要清空 tempSet.clear(); HashSet&lt;String&gt; areas = broadcast.get(key); tempSet.addAll(areas); tempSet.retainAll(allAreas); // 取交集并把结果赋值给 tempSet // 此处便是贪心算法的体现：每次都是选择最好的 if (tempSet.size() &gt; 0 &amp;&amp; (maxKey == null || tempSet.size() &gt; broadcast.get(maxKey).size())) { maxKey = key; } } if (maxKey != null) { selects.add(maxKey); allAreas.removeAll(broadcast.get(maxKey)); } } System.out.println(\"贪心算法最后结果：--- \" + selects); }} 注意事项 普利姆算法克鲁斯卡尔算法迪杰斯特拉算法弗洛伊德算法回溯算法八皇后算法骑士周游算法番外篇，哈哈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238数据结构：逻辑结构和物理结构（数据在计算机内部的物理存储方式）数据元素存储形式：顺序存储结构和链式存储结构（银行排队叫号系统）逻辑结构：集合结构、线性结构、树形结构（金字塔关系）、图形结构了解：六度空间理论了解算法：就是解决问题的方法。例如：求从1加到100的和。使用for循环和等差公式，对计算机来说都没有什么差别，但加到10000000就差别大了，这就是算法。算法5个特性：零个或多个输入、至少一个或多个输出、有穷性、确定性和可行性。算法设计要求：正确性、可读性、健壮性、时间效率高和存储量低。时间复杂度（渐近时间复杂度）：使用大O体现算法时间复杂度，成为大O计法。线性阶：非嵌套循环涉及线性阶，对应次数成直线增长。平方阶：两个嵌套循环涉及平方阶。对数阶：例如下面的程序：2的x次方=n，求解之后x=log（2）n，所以时间复杂度为O（logn）还有常数阶，立方阶，指数阶。nlogn阶。int i = 1, n = 100;while(i &lt; n){i = i * 2;}最坏情况：平均情况：平均运行时间就是期望运行时间。空间复杂度：写代码时，可以用空间换取时间。闰年算法的例子。 线性表：存和读的情况：时间复杂度为O(1)插入和删除情况：时间复杂度为O(n)单链表：结点：数据域和指针域合在一起叫做结点数据域：存放数据的地方指针域：存放下一个地址的地方第一个结点叫做头结点（头指针）头结点一般不存储任何东西，头指针指向头结点，最后一个结点指向NULL下一次看线性表第6集======================================认识时间复杂度，用big O表示二分搜索，时间复杂度O（log2N）外排（谁小谁移动）题目：给定一个M个数的数组a和N个数的数组B，数组a乱序，数组b顺序，求两个数组共有多少个相同的数的复杂度？第一种：嵌套for循环，复杂度为O（M*N）第二种：对数组b（数组b是顺序的）使用二分查找，时间复杂度O（M*log2N）第三种：使用外排，先对数组a进行排序，然后使用外排，就是将两个数组的索引指向0，指向数字谁小谁就往下移动一个位置，直到结束。选择排序：第一次排序把最小的放在第一位，第二次排序把第二小的数字放在第二位，以此类推，直至结束。这种排序和数据状况没有关系，即便是一个排好的数组，它的时间复杂度仍然不变。冒泡排序：在一个数组中，相邻位置的数进行比较。进行完第一轮排序，最大的数字会在最后一个位置。那么下一轮排序就不用比较最后一个数字了。这种排序和数据状况没有关系，即便是一个排好的数组，它的时间复杂度仍然不变。插入排序：就像打扑克牌一样，一副排好序的牌，然后你摸了一张牌，就要给这张牌找位置，这就是插入排序。插入排序和数据状况有关，例如：数组元素1，2，3，4，5，那么插入排序复杂度为O（N），如果是5，4，3，2，1，那么复杂度为O（N2）.一般情况下，都是按照最坏情况作为一个算法的复杂度。最好情况：平均情况：最坏情况：以上三种情况在插入排序可见，自己百度以下平均情况。对数器【很重要的】：方法在排序代码里有。先要有随机数组产生器，然后需要绝对正确的方法，接着进行大样本的测试。堆的结构准备模板，排序、二叉树、数组也要准备对数器模板。冒泡和选择公司已经不使用了，只具有参考和教学意义。递归算法：1：38：26 递归如何求时间复杂度？1：51：49 时间复杂度求解公式1：54：30归并排序：master公式复杂度为O（N*log2N）计算机网络看视频从第一章开始看，同时参观CSDN别人的博客。===============================韩顺平老师数据结构：===============================KMP算法：汉诺塔问题：使用分治算法八皇后问题：使用回溯算法骑士周游问题：DFS+贪心算法场合不同，所使用的算法不一样五子棋程序约瑟夫问题【单向环形链表】稀疏数组和队列队列的应用：队列是个有序列表，可以用数组或者链表实现。特点：先进先出队列加数据在尾部加入，且rear+1，取数据在头部取，且front+1。queue包里面代码：数组实现队列和链表实现队列。数组模拟成环形队列。栈的应用：如子弹的弹夹，最先压入的子弹最后打出。线性表：自己补充单链表知识：看完写博客双向链表：（环形链表）约瑟夫环：排序算法：内容在 PPT 上已看：50 51 冒泡排序：选择排序：插入排序：希尔排序：快速排序：归并排序：基数排序：桶排序：堆排序：计数排序：查找算法：顺序（线性）查找：二分查找/折半查找：插值查找： 非常的牛逼斐波那契查找（黄金分割查找）：哈希表：二叉树：- 各种二叉树术语- 三种遍历方式- 二叉树的查找- 二叉树的删除- 顺序存储二叉树- 线索化二叉树- 堆排序：先变成大顶堆，然后排序赫夫曼树：wpl最小的就是赫夫曼树，赫夫曼树也是二叉树赫夫曼编码：不要前缀编码，就是不要出现二义性赫夫曼压缩赫夫曼解压二叉排序树：- 创建- 遍历- 删除平衡二叉树：- 左旋转- 右旋转- 双旋转多叉树：B树- 2-3树- 234树B+树B*树多路查找树图：图的基本术语图的邻接矩阵图的邻接表图的遍历方式：- 深度优先遍历（DFS）- 广度优先遍历（BFS）想要理解清楚 DFS 和 BFS 的区别，就要以图的邻接矩阵为例子，更好理解一点。程序员常用的 10 中算法：- 二分查找算法（非递归）- 分治算法（汉诺塔问题）【使用了递归算法】- 动态规划算法（背包问题）- KMP 算法（字符串匹配问题）- 暴力匹配算法- 贪心算法- 普利姆算法（prim算法）（修路问题）（最小生成树问题）- 克鲁斯卡尔算法（公交站问题）- 迪杰斯特拉算法（最短路径问题）- 弗洛伊德算法- 马踏棋盘算法（骑士周游问题）卖油翁和老黄牛的故事：在通往成功的路上，我们必须坚持，不要中途放弃，自毁前程，而要勇往直前，坚持不懈，最终会抵达理想的彼岸。既然选择了远方，便只顾风雨兼程。 其他算法小案例反转输出1234567891011121314// 01-小米笔试题：输入一个句子，例如 hello world xiaomi ，然后反转输出如： xiaomi world hellopublic static void xiaomi(){ Scanner sc = new Scanner(System.in); System.out.println(\"请输入句子，以空格分隔：\"); String str = sc.nextLine(); // 通过split方法把句子切割保存到String数组 String[] arr = str.split(\" \"); // 遍历数组 for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[arr.length - 1 - i] + \" \"); }} 十进制和十六进制转化1234567891011public static String intToHex(int n) { StringBuffer s = new StringBuffer(); String a; char[] b = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}; while (n != 0) { s = s.append(b[n % 16]); n = n / 16; } a = s.reverse().toString(); return a;} 杨辉三角12345678910111213// 杨辉三角：金字塔型的，方法里面的参数代表输出的行数public static void yanghui(int rows){ for (int i = 0; i &lt; rows; i++) { int number = 1; // 打印空格字符串 System.out.format(\"%\" + (rows - i) * 2 + \"s\", \"\"); for (int j = 0; j &lt;= i; j++) { System.out.format(\"%4d\", number); number = number * (i - j) / (j + 1); } System.out.println(); }} 格式化数组1234567891011// 按照指定的格式输出数组public static void arrayFormat(int[] arr){ System.out.print(\"[\"); for (int i = 0; i &lt; arr.length; i++) { if(i == arr.length -1){ System.out.print(arr[i] + \"#]\"); }else { System.out.print(arr[i] + \"# \"); } }}","link":"/Algorithm.html"},{"title":"Java 基础（上篇）","text":"内容概要： 开启-Java-之门 数据类型和运算符 流程控制语句 开发工具和方法 数组知识 类与面向对象 封装特性 开启 Java 之门Java 语言概述什么是 Java 语言Java 语言是美国的 Sun 公司（Stanford University Network） 在 1995 年推出的高级的编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。 Java 语言发展史 Java 发展史： 1995年发布Java 1.0版本 1997年发布Java 1.1版本 1998年发布Java 1.2版本 2000年发布Java 1.3版本 2002年发布Java 1.4版本 2004年发布Java 1.5版本 2006年发布Java 1.6版本 2009年 Oracle 甲骨文公司收购 Sun 公司 2011年发布Java 1.7版本（Oracle 公司发布） 2014年发布Java 1.8版本 2017年发布Java 9.0版本 2018年发布Java 10版本 … Java 能干什么Java 语言主要应用在互联网程序的后台开发领域。常见的互联网程序比如天猫、京东、物流系统、网银系统等，以及服务器后台处理大数据的存储、查询、数据挖掘等也有很多应用。例如下图： 计算机基础认识进制计算机中的数据不同于我们生活中的数据，在生活中，我们采用 十进制数 计数，而在计算机中，全部都采用了 二进制数 表示，它只包含 0、1 两个数，逢二进一。例如：1 + 1 = 10 。每一个 0 或者每一个 1 ，叫做一个 bit（比特） ，表示信息的最小单位 。 进制转换方法： 十进制数据转成二进制数据：使用除以 2 获取余数的方式 二进制数据转成十进制数据：使用 8421 编码的方式 各种进制的表示形式123456public static void main(String[] args) { System.out.println(\"二进制100的大小：\\t\" + 0B100); // 二进制表示形式前面加0B(B可以大写，也可以小写) System.out.println(\"八进制100的大小：\\t\" + 0100); // 八进制表示形式前面加0 System.out.println(\"十进制100的大小：\\t\" + 100); // 十进制直接输出 System.out.println(\"十六进制100大小：\\t\" + 0X100); // 十六进制前面加0x(X可以大写也可以小写)} 认识字节字节 是我们常见的计算机中 最小存储单元 。计算机存储任何的数据，都是以字节的形式存储，右键点击文件属性，我们可以查看文件的字节大小。8 个 bit 表示为 1 个字节 ，写成 1byte 或者 1B 。 位与字节： 位（bit）：一个数字 0 或者一个数字 1，代表一位。 字节（Byte）： 8 位是一个字节，这是数据存储的最小单位。 计算机存储单位之间的转换： 1 Byte = 8 bit 1 KB = 1024 Byte 1 MB = 1024 KB 1 GB = 1024 MB 1 TB = 1024 GB 1 PB = 1024 TB 1 EB = 1024 PB 1 ZB = 1024 EB 1 YB = 1024 ZB 1 BB = 1024 YB 常用 DOS 命令MS-DOS(Microsoft Disk Operating System) ，作为 Java 语言的初学者，学习一些 DOS 命令，会非常有帮助。DOS 是一个早期的操作系统，现在已经被 Windows 系统取代，对于我们开发人员，目前需要在 DOS 中完成一些事情，因此就需要掌握一些必要的命令。 相关操作 命令 进入 DOS 窗口 WIN + R ，输入 cmd 回车 切换盘符 例如切换到 D 盘： D: 进入文件夹 cd 文件夹名称 进入多级文件夹 cd 文件夹1\\文件夹2\\文件夹3 返回上一级 cd .. 直接回根路径 cd \\ 查看当前内容 dir 清屏 cls 退出 exit 开发环境搭建Java 虚拟机JVM（Java Virtual Machine）： Java 虚拟机，简称 JVM ，是运行所有 Java 程序的假想计算机，是 Java 程序的运行环境，是 Java 最具吸引力的特性之一。我们编写的 Java 代码，都运行在其上。 跨平台性： 任何软件的运行，都必须要运行在操作系统之上。 而我们用 Java 编写的软件可以运行在任何的操作系统上，这个特性称为 Java 语言的跨平台特性。该特性是由 JVM 实现的，我们编写的程序运行在 JVM 上，而 JVM 运行在操作系统上 。 JRE 和 JDK 计算机存储单位之间的转换： 1、JRE (Java Runtime Environment)： 是 Java 程序的运行时环境，包含 JVM 和运行时所需要的类库。 2、JDK (Java Development Kit)： 是 Java 程序开发工具包，包含 JRE 和编译器等开发工具。 三者关系： JDK &gt; JRE &gt; JVM JDK 安装图解第一步： 下载 JDK ，这是 下载网址 ，如下图： 第二步： 安装 JDK 。如下图： 温馨小提示： 到此为止， JDK 安装结束，接下来需要配置环境变量，这样才能使用。个人推荐配置： 开发工具： IDEA ； JDK 版本: 11 及以上版本 JAVA_HOME 的配置首先 win + r 打开命令行，输入 sysdm.cpl ，结果如下图： 然后一直点击 确定 即可。这样，Java 环境就安装配置好了。那么怎么查看呢？打开命令行，使用 java -version 查看版本。有如下结果，就代表环境配置好了，否则配置出错了。结果如下图： 其他教程： 菜鸟教程之 Java 开发环境配置 编写入门程序开发环境已经搭建完毕了，现在可以开发我们的第一个 Java 程序了。Java 程序开发三步骤：编写代码、编译、运行 。现在，我们来搞定 第一步： 编写代码 。在桌面新建一个 HelloWorld.java 文件，写入如下代码： 123456789public class HelloWorld { public static void main(String[] args) { // 在 IDEA 软件中，alt + 4 是 console 的快捷键 System.out.println(\"******************************\"); System.out.println(\"Hello World!\"); System.out.println(\"This is my first Java program！\"); System.out.println(\"******************************\"); }} 第二步： 编译 HelloWorld.java 。编译 是指将我们编写的 Java 源文件 翻译成 JVM 认识的 class 文件 。在这个过程中，编译器会检查我们所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功。打开命令行，执行如下命令即进行了编译。如下图： 第三步： 运行代码 。运行 是指将 字节码文件 交给 JVM 去执行，这样，我们的程序就跑起来了。如下图： 1、小提示：上述使用命令行编译和运行代码挺麻烦的，了解一下就行了。以后用 IDEA 编译和运行，就不需要用命令行了。2、关于 main 方法main 方法： 称为主方法。写法是固定格式不可以更改。main 方法是程序的入口点或起始点，无论我们编写多少程序，JVM 在运行的时候，都会从 main 方法这里开始执行。这里要注意：不要写成 mian ，初学容易写错。 Java 中的注释注释： 就是对代码的解释和说明。其目的是 让开发人员能够更加轻松地了解代码 。为代码添加注释，是十分必要的，它不影响程序的编译和运行。Java 中有三种注释方式 ，相关介绍如下： 12345单行注释 # 单行注释以 // 开头换行结束，单行注释支持嵌套。多行注释 # 多行注释以 /* 开头，以 */ 结束，多行注释不支持嵌套。文档注释 # 文档注释以 /** 开始，以 */ 结束，文档注释也不支持嵌套。 单行注释单行注释以 // 开头换行结束，单行注释支持嵌套。 1234567// 定义一个变量 keyint key = 10;// 定义一个方法，实现两数相加public static void add(int a, int b){ return a + b;} 多行注释多行注释以 /* 开头，以 */ 结束，多行注释不支持嵌套。 123456789/* * 定义一个变量 key */int key = 10;/* 定义一个方法，实现两数相加 */public static void add(int a, int b){ return a + b;} 文档注释文档注释以 /** 开始，以 */ 结束，文档注释也不支持嵌套。 1234567891011/** * 定义一个变量 key */int key = 10;/** * 定义一个方法，实现两数相加 */public static void add(int a, int b){ return a + b;} Java 关键字与标识符关键字 关键字概念： 关键字是指在程序中，Java 已经定义好的单词，具有特殊含义。 关键字举例： 在入门案例中，出现的关键字有 public ，static ，void ，class 等，这些单词已经被 Java 提前定义好了，全部都是小写字母，在 notepad++ 中有特殊的颜色 。关键字比较多，不用死记硬背，学到哪里记到哪里即可。需要一次性了解的请自行百度。 标识符标识符： 是指在程序中，我们自己定义内容。比如 类的名字、方法的名字 和 变量的名字 等等，都是标识符。在入门案例中，出现的标识符有类的名字： HelloWorld 。 命名规则【硬性要求】： 1、标识符可以包含英文字母 26 个(区分大小写)、0-9 数字、$（美元符号）和 _（下划线）。 2、标识符不能以数字开头。 3、标识符不能是关键字。 命名规范【软性建议】： 1、类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。 2、方法名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。 3、变量名规范：小驼峰式。用 final 修饰的变量全部大写，多个单词用 \"_\" 分隔。 Java 中的常量和变量常量概述及分类常量概念： 常量是 “不改变的量” ，在计算机程序运行时，不会被程序修改的量，即固定不变的数据。以下是常量的分类： 类型 含有 举例 整数常量 所有的整数 0，1，567，-9 小数常量 所有的小数 0.0，-0.1，2.55 字符常量 单引号引起来,只能写一个字符,必须有内容 ‘a’，’好’ 字符串常量 双引号引起来,可以写多个字符,也可以不写 “A”，”Hello”，”你好” 布尔常量 只有两个值（流程控制中讲解） true，false 空常量 只有一个值（引用数据类型中讲解） null 常量练习12345678910111213141516171819202122232425262728293031public class Constant { public static void main(String[] args) { // 常量的概念：在程序运行期间，固定不变的量。 // 1、字符串常量 System.out.println(\"ABC\"); System.out.println(\"\"); System.out.println(\"XYZ\"); // 2、整数常量 System.out.println(30); System.out.println(-500); // 3、浮点数/小数常量 System.out.println(3.14); System.out.println(-2.5); // 4、字符常量 System.out.println('A'); System.out.println('6'); System.out.println(' '); // 代表空格字符 /*System.out.println(''); // 两个单引号中间必须有且仅有一个字符，没有不行。 System.out.println('AB'); // 两个单引号中间必须有且仅有一个字符，有两个不行。*/ // 5、布尔常量：只有两种取值。true、false。 System.out.println(true); System.out.println(false); // 6、空常量：null。代表没有任何数据。空常量不能直接用来打印输出。 // System.out.println(null); }} 变量概述及定义变量概念： 常量是固定不变的数据，那么在程序中可以变化的量称为 变量 。在数学中，可以使用字母代替数字运算,例如 x = 1 + 5 或者 6 = x + 5。同样，在程序中，也可以用字母保存数字的方式来进行运算，提高计算能力。比如用 x 保存 5，且 x 也可以保存 6，这样 x 保存的数据是可以改变的，也就是我们所讲的变量。Java 中要求 一个变量每次只能保存一个数据 ，必须要明确保存的数据类型。所以下一章节我们去了解一下 Java 中的数据类型。 变量的定义： 1、三要素：数据类型、变量名、数据值。 2、格式为：数据类型 变量名 = 数据值; 变量练习定义所有基本数据类型的变量，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Variable { public static void main(String[] args) { // 变量概念：程序运行期间，内容可以发生改变的量。 int num1; num1 = 10; System.out.println(\"num1 = \" + num1); num1 = 20; System.out.println(\"num1 = \" +num1); int num2 = 25; System.out.println(\"num2 = \" +num2); num2 = 35; System.out.println(\"num2 = \" +num2); System.out.println(\"===============\"); // 注意：右侧数值的范围不能超过左侧数据类型的取值范围 // byte num4 = 400; // 右侧超出了 byte 数据范围，错误！ byte num3 = 30; System.out.println(\"num3 = \" + num3); short num5 = 50; System.out.println(\"num5 = \" + num5); long num6 = 3000000000L; System.out.println(\"num6 = \" + num6); float num7 = 2.5F; System.out.println(\"num7 = \" + num7); double num8 = 1.2; System.out.println(\"num8 = \" + num8); char zifu1 = 'A'; System.out.println(\"zifu1 = \" + zifu1); // char 可以存储中文 zifu1 = '中'; System.out.println(\"zifu1 = \" + zifu1); // char 的范围是 0 --&gt; 65535 zifu1 = 100; System.out.println(zifu1); boolean var1 = true; System.out.println(\"var1 = \" + var1); var1 = false; System.out.println(\"var1 = \" + var1); boolean var2 = var1; System.out.println(\"var2 = \" + var2); }} 温馨小提示：1、long 类型： 建议数据后加 大写 L 表示，不建议用小写，易混淆。2、float 类型： 建议数据后加 大写 F 表示，不建议用小写，易混淆。3、整数默认为 int 类型。4、小数默认为 double 类型。 变量的注意事项 变量的注意事项： 1、变量名称：在同一个大括号范围内，变量的名字不可以相同。 2、变量赋值：定义的变量，不赋值不能使用。 变量的注意事项 相关代码如下： 1234567891011121314151617181920212223242526public static void main(String[] args) { /*int num1 = 10; // 创建了一个新的变量，名叫 num1 int num1 = 20; // 又创建了另一个新的变量，名字也叫 num1，错误！*/ /*int num4; // 定义了一个变量，但是没有进行赋值 System.out.println(num4); // 直接使用打印输出就是错误的！ System.out.println(num5); // 在创建 num5 这变量之前，不能使用这个变量*/ int num5 = 500; System.out.println(num5); { int num6 = 60; System.out.println(num6); } //System.out.println(num6); // 已经超出了大括号的范围，超出了作用域，变量不能再使用了 // 同时创建了三个全都是 int 类型的变量 int a, b, c; a = 10; b = 20; c = 30; System.out.println(\"a = \" + a + \"\\tb = \" + b + \"\\tc = \" + c); // 同时创建三个 int 变量，并且同时各自赋值 int x = 100, y = 200, z = 300; System.out.println(\"x = \" + x + \"\\ty = \" + y + \"\\tz = \" + z);} 数据类型和运算符数据类型分类 Java 的数据类型分为两大类： 基本数据类型：包括整数、浮点数、字符、布尔。 引用数据类型：包括类、数组、接口。 Java 基本数据类型 可以概括为 四类八种 ，如下表所示： 数据类型 关键字 内存占用 取值范围 字节型 byte 1 个字节 -128~127 短整型 short 2 个字节 -32768~32767 整型 int(默认) 4 个字节 -2的31次方~2的31次方-1 长整型 long 8 个字节 -2的63次方~2的63次方-1 单精度浮点数 float 4 个字节 1.4013E-45~3.4028E+38 双精度浮点数 double(默认) 8 个字节 4.9E-324~1.7977E+308 字符型 char 2 个字节 0-65535 布尔类型 boolean 1 个字节(有争议) true，false 我们使用代码把上面表格的内容显示出来： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public static void main(String[] args) { // byte System.out.println(\"************************************************\\n\"); System.out.println(\"基本类型：byte\\t二进制位数：\" + \"|\"+Byte.SIZE+\"|\"); System.out.println(\"包装类：java.lang.Byte\"); System.out.println(\"最小值：Byte.MIN_VALUE=\" + Byte.MIN_VALUE); System.out.println(\"最大值：Byte.MAX_VALUE=\" + Byte.MAX_VALUE); System.out.println(); // char System.out.println(\"************************************************\\n\"); System.out.println(\"基本类型：char\\t二进制位数：\" + \"|\"+Character.SIZE+\"|\"); System.out.println(\"包装类：java.lang.Character\"); // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台 System.out.println(\"最小值：Character.MIN_VALUE=\"+(int)Character.MIN_VALUE); // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台 System.out.println(\"最大值：Character.MAX_VALUE=\"+(int)Character.MAX_VALUE); System.out.println(); // short System.out.println(\"************************************************\\n\"); System.out.println(\"基本类型：short\\t二进制位数：\" + \"|\"+Short.SIZE+\"|\"); System.out.println(\"包装类：java.lang.Short\"); System.out.println(\"最小值：Short.MIN_VALUE=\" + Short.MIN_VALUE); System.out.println(\"最大值：Short.MAX_VALUE=\" + Short.MAX_VALUE); System.out.println(); // int System.out.println(\"************************************************\\n\"); System.out.println(\"基本类型：int\\t二进制位数：\" + \"|\"+Integer.SIZE+\"|\"); System.out.println(\"包装类：java.lang.Integer\"); System.out.println(\"最小值：Integer.MIN_VALUE=\" + Integer.MIN_VALUE); System.out.println(\"最大值：Integer.MAX_VALUE=\" + Integer.MAX_VALUE); System.out.println(); // float System.out.println(\"************************************************\\n\"); System.out.println(\"基本类型：float\\t二进制位数：\" + \"|\"+Float.SIZE+\"|\"); System.out.println(\"包装类：java.lang.Float\"); System.out.println(\"最小值：Float.MIN_VALUE=\" + Float.MIN_VALUE); System.out.println(\"最大值：Float.MAX_VALUE=\" + Float.MAX_VALUE); System.out.println(); // long System.out.println(\"************************************************\\n\"); System.out.println(\"基本类型：long\\t二进制位数：\" + \"|\"+Long.SIZE+\"|\"); System.out.println(\"包装类：java.lang.Long\"); System.out.println(\"最小值：Long.MIN_VALUE=\" + Long.MIN_VALUE); System.out.println(\"最大值：Long.MAX_VALUE=\" + Long.MAX_VALUE); System.out.println(); // double System.out.println(\"************************************************\\n\"); System.out.println(\"基本类型：double\\t二进制位数：\" + \"|\"+Double.SIZE+\"|\"); System.out.println(\"包装类：java.lang.Double\"); System.out.println(\"最小值：Double.MIN_VALUE=\" + Double.MIN_VALUE); System.out.println(\"最大值：Double.MAX_VALUE=\" + Double.MAX_VALUE); System.out.println(); System.out.println(\"************************************************\");} Java 中的默认类型： 整数类型是 int , 浮点类型是 double 。Java 引用数据类型： 这部分后面会涉及到，请往下阅读。 数据类型转换Java 程序中要求参与计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生 类型转换异常 。 自动类型转换 概念： 将取值范围小的类型自动提升为取值范围大的类型。转换规则： 范围小的类型向范围大的类型提升，byte、short、char ‐‐&gt; int ‐‐&gt; long ‐‐&gt; float ‐‐&gt; double 。 自动类型转换 代码演示如下： 1234567891011121314151617public class DataTypeConversion { public static void main(String[] args) { // 数据类型转换之隐式转换 // 1、特点：代码不需要进行特殊处理，自动完成。 // 2、规则：数据范围从小到大。 int x1 = 3; byte b1 = 4; // byte 取值范围：-128~127 x1 = x1 + b1; // 这里的 b1 自动转换为 int System.out.println(x1); double num2 = 2.5F; System.out.println(num2); // 左边是float类型，右边是long类型，long --&gt; float，范围是float更大一些，符合从小到大的规则,发生自动类型转换 float num3 = 30L; System.out.println(num3); }} 以下是一道 面试题 ，如下： 12345678910111213141516171819public static void main(String[] args) { // 面试题:以下程序是否有问题，给出理由。 byte b01 = 3; byte b02 = 4; System.out.println(b01); System.out.println(b02); byte b03 = b01 + b02; System.out.println(b03); byte b04 = 3 + 4; // java 编译器有常量优化机制 System.out.println(b04); // 问题解析： // 1、byte 与 byte (或short,char)进行运算的时候会自动提升为 int ,两个 int 类型相加的结果也是 int 类型 // 2、b01 和 b02 是两个变量,变量存储的值是变化,在编译的时候无法判断里面具体的值,相加有可能会超出 byte 的取值范围 // 3、程序是有错的，自己拿到 IDEA 上就知道了。} 下面是有关 ASCll 码表 中字符与数字对应关系，例如 字符 0 对应 ASCll 码表中的 数字 48 。 123456789101112131415161718192021222324public class DataTypeChar { public static void main(String[] args) { // 数字和字符的对照关系表（编码表）： // ASCII 码表：American Standard Code for Information Interchange，美国信息交换标准代码。 // Unicode 码表：万国码。也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始包含有更多字符。 // 48 - '0' // 65 - 'A' // 97 - 'a' char zifu1 = '1'; System.out.println(zifu1 + 0); // 49 char zifu2 = 'A'; // 其实底层保存的是65数字 System.out.println(zifu2 + 0); // 65 char zifu3 = 'c'; // 左侧是int类型，右边是char类型， char --&gt; int，确实是从小到大，从而发生了自动类型转换 int num = zifu3; System.out.println(num); // 99 char zifu4 = '中'; System.out.println(zifu4 + 0); // 20013 }} 强制类型转换强制类型转换 就是将 取值范围大的类型强制转换成取值范围小的类型 。比较而言，自动转换是 Java 自动执行的，而强制转换需要我们自己手动执行。强制类型转换格式： 数据类型 变量名 =（数据类型）被转数据值; 代码演示如下： 12345678910public static void main(String[]args){ //short类型变量，内存中2个字节 short s = 1; // 将会出现编译失败，s 和 1 做运算的时候，1 是 int 类型，s 会被提升为 int 类型 // s+1后的结果是int类型，将结果在赋值会short类型时发生错误short内存2个字节，int类型4个字节 // 必须将 int 强制转成 short 才能完成赋值 s = s + 1; //编译失败 s = (short)( s + 1 ); //编译成功} 强制类型转换 的图解如下： 12345678910111213141516171819202122232425262728293031public static void main(String[]args){ // 数据类型转换之强制转换 // 1. 特点：代码需要进行特殊的格式处理，不能自动完成。 // 2. 格式：范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据; // 注意事项： // 1. 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。 // 2. byte/short/char这三种类型都可以发生数学运算，例如加法“+”. // 3. byte/short/char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。 // 4. boolean类型不能发生数据类型转换 int x2 = 3; byte b2 = 4; b2 = (byte)(x2 + b2); //b2=(byte)x2+b2;这种写法是会出错的 System.out.println(b2); //00000000 00000000 00000000 10000010 130的二进制 //10000010 -126补码 //00000001 -1求反码 //10000001 -126反码 //11111110 -126原码 byte b3 = (byte)(126 + 4); System.out.println(b3); //00000000 00000000 00000001 00101100 300的二进制 //00101100 正数的原码反码和补码一样 byte b4 = (byte)300; System.out.println(b4); System.out.println((char)('a' + 1)); //结果是b System.out.println(\"hello\"+'a'+1); //任何数据类型用+与字符串相连接都会产生新的字符串 System.out.println('a'+1+\"hello\"); //98hello,因为有ASCII码表,a字符对应的是int类型的97} 小提示： 1. 浮点转成整数，直接取消小数点，可能造成数据损失精度。2. int 强制转成 short 砍掉2个字节，可能造成数据丢失。 各种运算符算术运算符 算术运算符包括 中文解释 + 加法运算，字符串连接运算 - 减法运算 * 乘法运算 / 除法运算 % 取模运算，两个数字相除取余数 ++，- - 自增自减运算(单独说) 算术运算符 代码演示如下： 12345678910111213141516171819202122232425262728293031323334353637/** * 1. 运算符：进行特定操作的符号。例如：+ * 2. 表达式：用运算符连起来的式子叫做表达式。例如：20 + 5。又例如：a + b * 3. 四则运算 ==&gt; 加：+ 减：- 乘：* 除：/ * 4. 取模运算（取余数）：% ，只有对于整数的除法来说，取模运算符才有余数的意义。 * 5. 首先计算得到表达式的结果，然后再打印输出这个结果 * 6. 复习一下除法公式：被除数 / 除数 = 商 ... 余数 * 7. 对于一个整数的表达式来说，除法用的是整除，整数除以整数，结果仍然是整数。只看商，不看余数。 * 8. 注意事项：一旦运算当中有不同类型的数据，那么结果将会是数据类型范围大的那种。 */public class Operator { public static void main(String[] args) { // 两个常量之间可以进行数学运算 System.out.println(20 + 30); // 两个变量之间也可以进行数学运算 int a = 20; int b = 30; System.out.println(a - b); // -10 // 变量和常量之间可以混合使用 System.out.println(a * 10); // 200 int x = 10; int y = 3; int result1 = x / y; System.out.println(result1); // 3 int result2 = x % y; System.out.println(result2); // 余数【模】为 1 // int + double --&gt; double + double --&gt; double double result3 = x + 2.5; System.out.println(result3); // 12.5 }} 取模运算 比较特殊，具体的解释代码里都有，代码如下： 123456789101112131415161718public class Operator{ public static void main(String[] args){ // % --&gt; 取模运算符 // % 运算符结果的符号只和左边有关系,与右边无关 // 任何一个正整数 %2 结果不是 0 就是 1 , 可以用来当作切换条件 System.out.println(10 / 3); // 整数相除结果只能是整数 System.out.println(10 / 3.0); // 如果想得到小数,把其中一个数变成小数,另一个数在运算的时候会自动类型提升 System.out.println(-6 % 5); System.out.println(13 % -5); }}// 输出结果：33.3333333333333335-13 赋值运算符 赋值运算符包括 中文解释 = 等于号 += 加等于 -= 减等于 *= 乘等于 /= 除等于 %= 取模等 赋值运算符 代码演示如下： 1234567891011121314151617181920212223242526public class Operator{ public static void main(String[] args){ // 赋值运算符 = int a1 = 3; // 把右边的常量值赋值给左边的变量,左边必须是变量 // 赋值运算符 += a1 += 4; // a1 = a1 + 4; System.out.println(a1); // 赋值运算符 -= a1 -= 5; // a1 = a1 - 4; System.out.println(a1); // 赋值运算符 *= a1 *= 2; // a1 = a1 * 4; System.out.println(a1); // 赋值运算符 /= a1 /= 2; // a1 = a1 / 4; System.out.println(a1); // 赋值运算符 %= a1 %= 2; // a1 = a1 % 4; System.out.println(a1); }} 比较运算符 比较运算符包括 中文解释 == 比较符号两边数据是否相等，相等结果是true。 != 不等于符号，如果符号两边的数据不相等，结果是true。 &gt; 比较符号左边的数据是否大于右边的数据，如果大于结果是true。 &gt;= 比较符号左边的数据是否大于或等于右边的数据，如果大于等于结果是true。 &lt; 比较符号左边的数据是否小于右边的数据，如果小于结果是true。 &lt;= 比较符号左边的数据是否小于或等于右边的数据，如果小于等于结果是true。 比较运算符 代码演示如下： 123456789101112public class Operator{ public static void main(String[] args){ // 比较运算符，也称为关系运算符 // == , != , &gt; , &gt;= , &lt; , &lt;= System.out.println(4 == 3); System.out.println(4 != 3); System.out.println(4 &gt; 4); System.out.println(4 &gt;= 4); System.out.println(4 &lt; 3); System.out.println(4 &lt;= 3); }} 逻辑运算符 逻辑运算符包括： 相关说明 &amp;&amp; 短路与 两边都是 true，结果是 true一边是 false，结果是 false短路特点： 符号左边是 false，右边不再运算 || 短路或 两边都是 false，结果是 false一边是 true，结果是 true短路特点： 符号左边是 true，右边不再运算 ! 取反 !true 结果是 false!false 结果是 true 逻辑运算符 是用来连接两个布尔类型结果的运算符，运算结果都是布尔值 true 或者 false 。代码演示如下： 12345678910111213public static void main(String[] args) { // 逻辑运算符(不支持短路运算) &amp; | ^(异或) // 逻辑运算符(支持短路运算) &amp;&amp; || ! int a = 10; int b = 23; int c = 34; System.out.println(\"&amp;\\t\" + (a &gt; b &amp; b &lt; c)); // false，a &gt; b 和 b &lt; c 都会执行 System.out.println(\"&amp;&amp;\\t\" + (a &gt; b &amp;&amp; b &lt; c)); // false, 当 a &gt; b 被判断为错误时，b &lt; c 不执行 System.out.println(\"|\\t\" + (a &gt; b | b &lt; c)); // true System.out.println(\"||\\t\" + (a &gt; b || b &lt; c)); // true System.out.println(\"^\\t\" + (a &gt; b ^ b &lt; c)); // 相同为 false，不相同为 true 。例如：1^1=0 0^0=0 1^0=1 0^1=1 System.out.println(\"!\\t\" + !(a &lt; b));} 位运算符位运算符 主要针对二进制，它包括了：&amp; 与 、| 或 、~ 非 、^ 异或 、&lt;&lt; 左移 、&gt;&gt; 右移 。从表面上看，位运算符 似乎有点像逻辑运算符，但逻辑运算符是针对两个关系运算符来进行逻辑运算，而位运算符主要针对两个二进制数的位进行逻辑运算 。下面详细介绍每个位运算符。相关代码演示如下： 12345678910111213141516171819202122232425public static void main(String[] args) { // 位运算符 &amp; ^ | ~(按位取反) // ^ 的特点：一个数据对另一个数据位异或两次，该数本身不变。 System.out.println(\"^ = \" + (5 ^ 10 ^ 10)); // 可利用此特点不通过第三者而达到交换两个数的目的 System.out.println(\"6 &amp; 2 = \" + (6 &amp; 2)); System.out.println(\"6 ^ 2 = \" + (6 ^ 2)); System.out.println(\"6 | 2 = \" + (6 | 2)); System.out.println(\"~56 = \" + (~56)); // 位运算符：左移 &lt;&lt; 左移几位就乘以 2 的几次方 System.out.println(\"12左移3位：\\t\" + (12 &lt;&lt; 3)); System.out.println(\"12左移5位：\\t\" + (12 &lt;&lt; 5)); // 位运算符：右移 &gt;&gt; 右移几位就除以 2 的几次幂 System.out.println(\"16右移3位：\\t\" + (16 &gt;&gt; 3)); System.out.println(\"128右移5位：\\t\" + (128 &gt;&gt; 5));}// 输出结果：6 | 2 = 6~56 = -5712左移3位： 9612左移5位： 38416右移3位： 2128右移5位： 4 三元运算符三目运算符 又称 条件运算符 ，是计算机语言（c,c++,java等）的重要组成部分。它是 唯一一个有 3 个操作数 的运算符，有时又被称为 三元运算符 。一般来说，三目运算符的结合性是右结合的。【————百度百科】 三元运算符格式： 数据类型变量名 = 布尔类型表达式 ？ 结果1 ： 结果2 。 三元运算符计算方式： 如果 布尔类型表达式 结果是 true，三元运算符整体结果为 结果1，然后把 结果1 赋值给变量。否则就把 结果2 赋值给变量。代码演示如下： 123456789101112131415public static void main(String[]args){ int i = (1 == 2 ? 100 : 200); System.out.println(i); // 200 int j = (3 &lt;= 4 ? 500 : 600); System.out.println(j); // 500 int max = getMax(31,32,33); System.out.println(max);}// 求三个整数中的最大值public static int getMax(int a , int b , int c ){ return (a &gt; b ? a : b) &gt; c ? (a &gt; b ? a : b) : c;} 自增自减运算符自增自减运算符 的所有知识点都在下面的代码演示中，所以这里就不做过多的介绍，代码演示如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 自增运算符：++ 自减运算符：-- * 1. 基本含义：让一个变量涨一个数字1，或者让一个变量降一个数字1 * 2. 使用格式：写在变量名称之前，或者写在变量名称之后。例如：++num ，也可以 num++ * 3. 使用方式： * 1. 单独使用：不和其他任何操作混合，自己独立成为一个步骤。 * 2. 混合使用：和其他操作混合，例如与赋值混合，或者与打印操作混合，等。 * 4. 使用区别： * 1. 在单独使用的时候，前++和后++没有任何区别。也就是：++num;和num++;是完全一样的。 * 2. 在混合的时候，有【重大区别】 * A. 如果是【前++】，那么变量【立刻马上+1】，然后拿着结果进行使用。 【先加后用】 * B. 如果是【后++】，那么首先使用变量本来的数值，【然后再让变量+1】。 【先用后加】 * 5. 注意事项：只有变量才能使用自增、自减运算符。常量不可发生改变，所以不能用。 */public static void main(String[] args) { int num1 = 10; System.out.println(num1); // 10 ++num1; // 单独使用，前++ System.out.println(num1); // 11 num1++; // 单独使用，后++ System.out.println(num1); // 12 System.out.println(\"=================\"); // 与打印操作混合的时候 int num2 = 20; // 混合使用，先++，变量立刻马上变成21，然后打印结果21 System.out.println(++num2); // 21 System.out.println(num2); // 21 System.out.println(\"=================\"); int num3 = 30; // 混合使用，后++，首先使用变量本来的30，然后再让变量+1得到31 System.out.println(num3++); // 30 System.out.println(num3); // 31 System.out.println(\"=================\"); int num4 = 40; // 和赋值操作混合 int result1 = --num4; // 混合使用，前--，变量立刻马上-1变成39，然后将结果39交给result1变量 System.out.println(result1); // 39 System.out.println(num4); // 39 System.out.println(\"=================\"); int num5 = 50; // 混合使用，后--，首先把本来的数字50交给result2，然后我自己再-1变成49 int result2 = num5--; System.out.println(result2); // 50 System.out.println(num5); // 49 System.out.println(\"=================\"); int x = 10; int y = 20; // 11 + 20 = 31 int result3 = ++x + y--; System.out.println(result3); // 31 System.out.println(x); // 11 System.out.println(y); // 19 // 30++; // 错误写法！常量不可以使用++或者--} JShell 脚本工具JShell 是 JDK9 的新特性，这部分是个了解内容，需了解请参考： JShell 工具 流程控制语句流程控制概述在一个程序执行的过程中，各条语句的执行顺序 对程序的结果是有直接影响的。也就是说，程序的流程对运行结果有直接的影响。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。接下来介绍 三种流程控制结构 。 顺序结构顺序结构 就是 从上到下依此执行 ，代码演示如下： 1234567public static void main(String[] args){ // 顺序执行，根据编写的顺序，从上到下运行 System.out.println(\"今天天气不错\"); System.out.println(\"挺风和日丽的\"); System.out.println(\"我们下午没课\"); System.out.println(\"这的确挺爽的\");} 选择结构选择结构 有 两种形式： if 选择结构 和 switch 选择结构 。接下来我们详细讲一下这两种选择结构的 异同点 。 选择结构-if 第一种格式：if if (关系表达式) { &nbsp;&nbsp;&nbsp;&nbsp;语句体; } 第一种格式执行流程： 1、首先判断关系表达式，看其结果是 true 还是 false 2、如果是 true 就执行语句体；如果是 false 就不执行语句体 3、代码举例如下 123456// 因为 8 比 3 更大，所以输出结果为 OK!public static void main(String[] args){ if(8 &gt; 3){ System.out.println(\"OK!\"); }} 第二种格式：if…else if (关系表达式) { &nbsp;&nbsp;&nbsp;&nbsp;语句体1; } else { &nbsp;&nbsp;&nbsp;&nbsp;语句体2; } 第二种格式执行流程： 1、首先判断关系表达式，看其结果是 true 还是 false 2、如果是 true 就执行语句体1；如果是 false 就执行语句体2 3、代码举例如下 12345678// 因为 8 比 10 更小，所以输出结果为 NO!public static void main(String[] args){ if(8 &gt; 10){ System.out.println(\"OK!\"); } else { System.out.println(\"NO!\"); }} 第三种格式：if…else if…else if (关系表达式1) { &nbsp;&nbsp;&nbsp;&nbsp;语句体1; } else if (关系表达式2) { &nbsp;&nbsp;&nbsp;&nbsp;语句体2; }... }else if(关系表达式n) { &nbsp;&nbsp;&nbsp;&nbsp;语句体n; } else { &nbsp;&nbsp;&nbsp;&nbsp;语句体n+1; } 第三种格式执行流程： 1、首先判断关系表达式1，看其结果是 true 还是 false 2、如果是 true 就执行语句体1；如果是 false 就继续判断关系表达式2，看其结果是 true 还是 false 3、如果关系表达式2是 true ，就执行语句体2 ，如果是 false 就继续判断关系表达式3，看其结果是 true 还是 false 4、…… 5、如果没有任何关系表达式为 true，就执行语句体n+1 6、案例演示如下 综合案例： 学生成绩等级设计 ，指定考试成绩，判断学生等级。 评分机制如下： 优秀：90~100 很好：80~89 良好：70~79 及格：60~69 加油：&nbsp;0~60 12345678910111213141516171819202122232425public static void main(String[] args){ Scanner scanner = new Scanner(System.in); while (true) { System.out.print(\"请输入一个整数：\"); int score = scanner.nextInt(); if (score &lt; 0 || score &gt; 100) { System.out.println(\"你的成绩是错误的\"); } else if (score &gt;= 90 &amp;&amp; score &lt;= 100) { System.out.println(\"你的成绩属于优秀\"); } else if (score &gt;= 80 &amp;&amp; score &lt; 90) { System.out.println(\"你的成绩属于很好\"); } else if (score &gt;= 70 &amp;&amp; score &lt; 80) { System.out.println(\"你的成绩属于良好\"); } else if (score &gt;= 60 &amp;&amp; score &lt; 70) { System.out.println(\"你的成绩属于及格\"); } else { System.out.println(\"你的成绩属于需要再接再厉！\"); } }} 选择结构-switch switch 语法格式： switch (表达式) { &nbsp;&nbsp;&nbsp;&nbsp;case 常量值1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语句体1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;case 常量值2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语句体2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语句体n+1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; } switch 语句执行流程： 首先 获取到表达式的值，然后 把这个值和 case 的常量值依次比较，一旦有对应的值，就会执行相应 case 的语句体。在执行的过程中，遇到 break 就会结束。最后 ，如果所有的 case 都和表达式的值不匹配，就会执行default 语句体 部分，然后程序结束。代码演示如下： 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) { // 定义变量，判断是星期几 int weekday = 6; // switch 语句实现选择 switch(weekday) { case 1: System.out.println(\"星期一\"); break; case 2: System.out.println(\"星期二\"); break; case 3: System.out.println(\"星期三\"); break; case 4: System.out.println(\"星期四\"); break; case 5: System.out.println(\"星期五\"); break; case 6: System.out.println(\"星期六\"); break; case 7: System.out.println(\"星期日\"); break; default: System.out.println(\"你输入的数字有误\"); break; }} 小提示： switch 语句中 ，表达式的数据类型，可以是 byte，short，int，char，enum（枚举） ，JDK7 后可以接收 字符串 。 case 的穿透性： 在 switch 语句中，如果 case 的后面不写 break ，将出现 穿透现象 ，也就是不会再判断下一个 case 的值，而是直接向后运行，直到遇到 break，或者整体 switch 结束。代码举例如下： 123456789101112131415161718public static void main(String[]args){ int i = 5; switch(i){ case 0: System.out.println(\"执行case0\");break; case 5: System.out.println(\"执行case5\"); case 10: System.out.println(\"执行case10\"); default: System.out.println(\"执行default\"); }}// 输出结果执行case5执行case10执行default 在上述程序中，执行 case5 后，由于没有 break 语句，程序会一直向后走 ，不会再判断 case，直接运行完整体 switch 或者遇到 break 才会结束。由于 case 存在穿透性，因此初学者在编写 switch 语句时，必须要写上 break 。 循环结构循环结构 可以 在满足循环条件的情况下，反复执行某一段代码 ，这段被重复执行的代码被称为 循环体语句 。当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为 false，从而结束循环，否则循环将一直执行下去，形成 死循环 。 循环结构-for for 循环的格式： for (初始化表达式①; 布尔表达式②; 步进表达式④) { &nbsp;&nbsp;&nbsp;&nbsp;循环体③ } for 循环的执行流程： 1、执行顺序：①②③④ > ②③④ > ②③④ … 直到②不满足循环条件为止。 2、①负责完成循环变量初始化 3、②负责判断是否满足循环条件，不满足则跳出循环 4、③是具体执行的语句 5、④表示循环后，循环条件所涉及变量的变化情况 代码演示如下： 123456public static void main(String[] args){ // 循环 10 次，输出 HelloWorld 10次。定义变量从 0 开始，循环条件为 x &lt; 10 for (int x = 0; x &lt; 10; x++) { System.out.println(\"HelloWorld\" + x); }} 一个小案例： 使用循环，计算 1-100 之间的偶数和 。代码如下： 12345678910111213141516public static void main(String[] args){ // 1、定义一个初始化变量,记录累加求和,初始值为 0 int sum = 0; // 2、利用 for 循环获取 1‐100 之间的数字 for (int i = 1; i &lt;= 100; i++) { // 3、判断获取的数组是奇数还是偶数 if(i % 2 == 0){ // 4、如果是偶数就累加求和 sum += i; } } // 5、循环结束之后,打印累加结果 System.out.println(\"sum: \" + sum);} 循环结构-foreach123456789101112131415161718192021222324252627282930313233public static void main(String[] args) { int[] num = {1, 2, 3, 4, 5, 6, 7, 8, 9}; for (int i : num) // 这就是 for 的增强，类似于自然语言 for each System.out.println(i); int[] numbers = {10, 20, 30, 40, 50}; for (int x : numbers) { System.out.print(x); System.out.print(\",\"); } System.out.print(\"\\n\"); String[] names = {\"James\", \"Larry\", \"Tom\", \"Lacy\", \"Bob\", \"Jobs\"}; for (String name : names) { if (name == \"Larry\") continue; // 结束本次循环，开始下一次循环 if (name == \"Lacy\") break; // 结束所有循环，直接跳出 System.out.print(name); System.out.print(\",\"); } System.out.println(\"\\n-----------------------------\"); for (int x = 10; x &lt; 20; x = x + 1) { System.out.print(\"value of x : \" + x); System.out.print(\"\\n\"); } } 循环结构-while while 循环的格式： 初始化表达式① while (布尔表达式②) { &nbsp;&nbsp;&nbsp;&nbsp;循环体③ &nbsp;&nbsp;&nbsp;&nbsp;步进表达式④ } while 循环的执行流程： 1、执行顺序：①②③④ > ②③④ > ②③④ … 直到②不满足循环条件为止。 2、①负责完成循环变量初始化 3、②负责判断是否满足循环条件，不满足则跳出循环 4、③是具体执行的语句 5、④表示循环后，循环变量的变化情况 代码演示如下： 123456789101112// while 循环实现打印 10次 HelloWorldpublic static void main(String[] args){ // 定义初始化变量 int i = 1; // 循环条件 i &lt;= 10 while(i &lt;= 10){ System.out.println(\"HelloWorld\"); // 步进表达式 i++; }} 一个小案例： 使用循环，计算 1-100 之间的和 12345678910111213141516171819public static void main(String[] args){ // 使用 while 循环实现 // 定义一个变量,记录累加求和 int sum = 0; // 定义初始化表达式 int i = 1; // 使用 while 循环让初始化表达式的值变化 while(i &lt;= 100){ // 累加求和 sum += i; // 步进表达式改变变量的值 i++; } // 循环结束之后,打印累加结果 System.out.println(\"1‐100 的和是：\" + sum);} 循环结构-do…while do…while 循环的格式： 初始化表达式① do { &nbsp;&nbsp;&nbsp;&nbsp;循环体③ &nbsp;&nbsp;&nbsp;&nbsp;步进表达式④ } while(布尔表达式②); do…while 循环的执行流程： 1、执行顺序：①②③④ > ②③④ > ②③④ … 直到②不满足循环条件为止。 2、①负责完成循环变量初始化 3、②负责判断是否满足循环条件，不满足则跳出循环 4、③是具体执行的语句 5、④表示循环后，循环变量的变化情况 代码演示如下： 123456789101112// while 循环实现打印 10 次 HelloWorldpublic static void main(String[] args){ // 定义初始化变量 int i = 1; // 循环条件 i &lt;= 10 do { System.out.println(\"HelloWorld\"); // 步进表达式 i++; } while(i &lt;= 10);} 注意： do…while 循环中的 while 后面有分号哦，可不要忘记了。 do…while 循环的特点： 无条件执行一次循环体，即使我们将循环条件直接写成 false ，也依然会循环一次。这样的循环具有一定的风险性，因此不太建议使用 do…while 循环，推荐使用 for 循环和 while 循环 。 12345public static void main(String[] args){ do { System.out.println(\"无条件执行一次\"); } while(false);} 接下来演示一个 do…while 版的 9 * 9 乘法口诀表 小案例,代码演示如下： 12345678910111213141516public static void main(String[] args) { int i = 1; //外循环变量定义在外面 do { int j = 1; // 内循环变量定义在第一个 do…while 里面 do { System.out.printf(\"%d * %d = %d\\t\", i, j, i * j); j++; } while (j &lt;= i); System.out.println(); i++; } while (i &lt;= 9);} 扩展知识点break 和 continue break 使用场景： 跳出循环，只能在 switch 和 循环语句 中使用123456789public static void main(String[] args){ for (int i = 1; i &lt;= 10; i++) { // 打印完两次 HelloWorld 就结束循环 if(i == 3){ break; } System.out.println(\"HelloWorld\" + i); }} continue 使用场景： 结束本次循环，继续下一次的循环。只能在 循环语句 中使用123456789public static void main(String[] args){ for(int i = 1;i &lt;= 10;i++){ // 不打印第三次 HelloWorld if(i == 3){ continue; } System.out.println(\"HelloWorld\" + i); }} 死循环死循环： 也就是循环中的条件永远为 true ，死循环是永不结束的循环 。例如：while(true){} 。在后期的开发中，会出现使用死循环的场景。例如：我们需要读取用户输入的输入，但是用户输入多少数据我们并不清楚，也只能使用死循环，当用户不想输入数据了，就可以结束循环了，如何去结束一个死循环呢，就需要使用到跳出语句了。代码演示如下： 1234567891011121314151617181920212223// 以下是三种循环的死循环public static void main(String[] args) { // 以下是 for 的死循环，去掉 break 就是死循环 for ( ; ; ) { System.out.println(\"I LOVE YOU!\"); break; } // 以下是 do~while 的死循环，去掉 break 就是死循环 do { System.out.println(\"HOPE IS BEAUTIFUL!\"); break; } while(true); // 以下是 while 的死循环 while (true) { System.out.println(\"SHAPE OF YOU!\"); }} 嵌套循环嵌套循环 是指一个循环的循环体是另一个循环。比如 for 循环里面还有一个 for 循环 ，就是 嵌套循环 。当然也可以嵌套多层，而且不同的循环结构相互之间也可以嵌套。循环次数： 总共的循环次数 = 外循环次数 * 内循环次数 嵌套循环格式举例： for (初始化表达式①; 循环条件②; 步进表达式⑦) { &nbsp;&nbsp;&nbsp;&nbsp;for (初始化表达式③; 循环条件④; 步进表达式⑥) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行语句⑤; &nbsp;&nbsp;&nbsp;&nbsp;} } 嵌套循环执行流程： 1、执行顺序：①②③④⑤⑥ > ④⑤⑥ > ⑦②③④⑤⑥ > ④⑤⑥ 2、外循环一次，内循环多次。比如跳绳：一共跳5组，每组跳10个。5组就是外循环，10个就是内循环。 嵌套循环练习： 使用嵌套循环，打印 5*8 的矩形 。实现代码如下： 123456789101112// 5*8 的矩形，打印5行*号，每行8个public static void main(String[] args){ // 外循环 5 次，内循环 8 次 for (int i = 0; i &lt; 5; i++) { for (int j = 0; j &lt; 8; j++) { // 不换行打印星号 System.out.print(\"*\"); } // 内循环打印 8 个星号后，需要一次换行 System.out.println(); }｝ 开发工具和方法开发工具概述我们常用的 Java 开发工具 有 Eclipse 、 NetBeans 和 IDEA 等等。这里只介绍 IDEA ，因为是世界上用的最多的 。 IDEA 是一个专门针对 Java 的集成开发工具(IDE)，由 Java 语言编写。所以需要有 JRE 运行环境并配置好环境变量 ，它可以极大地提升我们的开发效率。在公司中，使用的就是 IDEA 进行开发。具体的安装和使用请参考： IDEA 入门教程 Java 中的方法方法的概述在学习运算符的时候，需要为每个运算符单独地创建一个新的类。这时我们发现，这样编写代码是非常的繁琐，而且重复的代码过多。能否避免这些重复的代码呢？当然可以，使用方法来实现。方法： 在 C 语言中称之为 函数 ，就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象 。 方法的格式： 修饰符 返回值类型 方法名 （参数列表）{ &nbsp;&nbsp;&nbsp;&nbsp;方法体 &nbsp;&nbsp;&nbsp;&nbsp;return 返回值; } 方法的格式的解释： 修饰符：目前固定写法 public static 返回值类型：基本数据类型和引用数据类型 方法名：为我们定义的方法起名，满足标识符的规范，用来调用方法。 参数列表：可以空参，也可以有参 return：方法结束。如果返回值类型是 void ，方法大括号内的 return 可以不写。其他情况一律需要返回值。 代码演示如下： 1234// 定义 twoSum 方法，实现两个整数相加public static void twoSum(int a , int b){ System.out.println(\"两数之和为：\" + (a + b));} 方法定义的两个明确举例说明： 定义方法实现 两个整数的求和计算 。需要明确的两件事如下： 明确返回值类型： 方法计算的是整数的求和，结果也必然是个整数，所以返回值类型定义为 int 类型。 明确参数列表： 计算哪两个整数的和，并不清楚，但可以确定是整数，参数列表可以定义两个int类型的变量，由调用者调用方法时传递 代码演示如下： 123456789101112public static void main(String[] args){ // 调用方法 getSum，传递两个整数，这里传递的实际数据又称为实际参数 // sum 接收方法计算后的结果作为返回值 int sum = getSum(5,6); System.out.println(sum);}/*定义计算两个整数和的方法，返回值类型和计算结果都是 int参数：定义两个 int 类型参数。这两个参数称为形式参数*/public static int getSum(int a,int b){ return a + b;} 方法的调用方法在定义完毕后，方法不会自己运行，必须被调用才能执行 。【方法的调用有三种方式，直接调用 、赋值调用 和 输出调用 ，三种调用方式自行搜索一下，这里只是简单了解。】我们可以在 主方法 main 中来调用我们自己定义好的方法。在主方法中，直接写要调用的方法名字就可以调用了【前提是你定义的方法 必须被 static 关键字修饰 才行】。 123456789101112131415161718192021222324public static void main(String[] args) { // 单独调用 sum(10, 20); System.out.println(\"===========\"); // 打印调用 System.out.println(sum(10, 20)); // 30 System.out.println(\"===========\"); // 赋值调用 int number = sum(15, 25); number += 100; System.out.println(\"变量的值：\" + number); // 140}public static int sum(int a, int b) { System.out.println(\"方法执行啦！\"); int result = a + b; return result;} 方法的调用图解 方法的重载 方法重载： 1、方法重载：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。 2、参数列表：个数不同，数据类型不同，顺序不同。 3、重载方法调用：JVM 通过方法的参数列表，调用不同的方法。 方法重载 代码演示如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static void main(String[] args) { // 普通方法 print(3, 3); // 方法重载：方法名字相同，形式参数的类型不同或者形式参数的个数不同 // 重载: 方法名相同,参数列表不同,与返回值类型无关 // 重载的分类: 1、参数个数不同 2、参数类型不同 3、参数顺序不同 double sum1 = add(10, 20.1); System.out.println(sum1); int sum2 = add(10, 20, 30); System.out.println(sum2); double sum3 = add(12.3, 13); System.out.println(sum3);}/** * 在控制台输出矩形星形 * 1、明确返回值类型,经分析没有具体的返回值类型,那么返回值类型就是 void * 2、明确参数列表 int a, int b */public static void print(int a, int b) { for (int i = 1; i &lt;= a; i++) { //行数 for (int j = 1; j &lt;= b; j++) { //列数 System.out.print(\"*\"); } System.out.println(); } // 如果返回值类型是 void, return 可以省略,即使省略系统也会默认给加上, 形式是 return; //return ;}/** * 求两个整数的和 * 1、返回值类型 int * 2、参数列表 int a, int b */public static double add(int a, double b) { return a + b;}/** * 求三个整数的和 * 1、返回值类型 int * 2、参数列表 int a,int b,int c */public static int add(int a, int b, int c) { return a + b + c;}/** * 求两个小数的和 * 1、返回值类型 double * 2、参数列表 double a, double b */public static double add(double a, int b) { return a + b;} 方法的注意事项 方法的注意事项： 1、方法必须定义在类中方法外 2、方法不能定义在另一个方法里面 3、返回值类型必须要和语句返回的类型相同，否则编译失败 还有 更多的注意事项 写在代码的注释里面了，代码演示如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 使用方法的时候，有如下注意事项： * 1、方法应该定义在类当中，但是不能在方法当中再定义方法。不能嵌套。 * 2、方法定义的前后顺序无所谓。 * 3、方法定义之后不会执行，如果希望执行，一定要调用。三种调用方式：单独调用、打印调用、赋值调用。 * 4、如果方法有返回值，那么必须写上“return 返回值;”，不能不写。 * 5、return 后面的返回值数据，必须和方法的返回值类型，对应起来。 * 6、对于一个 void 没有返回值的方法，不能写 return 后面的返回值，只能写 return 自己。 * 7、对于 void 方法当中最后一行的 return 可以省略不写。 * 8、一个方法当中可以有多个 return 语句，但是必须保证同时只有一个会被执行到，两个 return 不能连写。 */class MethodNotice { public static int method1() { return 10; } public static void method2() {// return 10; // 错误的写法！方法没有返回值，return后面就不能写返回值。 return; // 没有返回值，只是结束方法的执行而已。 } public static void method3() { System.out.println(\"AAA\"); System.out.println(\"BBB\");// return; // 最后一行的return可以省略不写。 } public static int getMax(int a, int b) { /*int max; if (a &gt; b) { max = a; } else { max = b; } return max;*/ /*if (a &gt; b) { return a; } else { return b; }*/ return a &gt; b ? a : b; }} 数组知识数组的概述和初始化容器的概述现在需要统计某公司员工的工资情况，例如 计算平均工资、找最高工资 等。假设该公司有 50 名员工，那么首先需要声明 50 个变量来分别记住每位员工的工资，然后再进行操作，这样做会显得很麻烦，而且错误率也会很高。因此我们可以使用 容器 进行操作。将所有的数据全部存储到一个容器中，统一操作。容器 是将多个数据存储到一起，每个数据称为该容器的 元素 。生活中常见的容器：水杯，衣柜，教室 等等。 数组的概念数组 就是存储 数据长度固定 的容器，保证了多个数据的数据类型一致。数组的其他介绍都在代码里了，代码演示如下： 1234567891011121314151617181920212223242526272829/** * 01-数组的概念：数组是一种容器，可以同时存放多个数据值。 * 02-数组的特点： * 1、数组是一种引用数据类型 * 2、数组当中的多个数据，类型必须统一 * 3、数组的长度在程序运行期间不可改变 * 03-数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。 * 04-两种常见的初始化方式：1. 动态初始化（指定长度） 2. 静态初始化（指定内容） * 05-动态初始化数组的格式：数据类型[] 数组名称 = new 数据类型[数组长度]; * 06-解析含义： * 1、左侧数据类型：也就是数组当中保存的数据，全都是统一的数据类型 * 2、左侧的中括号：代表是一个数组 * 3、左侧数组名称：给数组取一个名字 * 4、右侧的 new：代表创建数组的动作 * 5、右侧数据类型：必须和左边的数据类型保持一致 * 6、右侧中括号的长度：也就是数组当中，到底可以保存多少个数据，是一个 int 类型的值 */public static void main(String[] args) { // 创建一个 int 类型的数组，里面可以存放 300 个 int 数据。 格式：数据类型[] 数组名称 = new 数据类型[数组长度]; int[] arrayA = new int[300]; // 创建一个 double 类型的数组，能存放 10 个 double 类型的数据 double[] arrayB = new double[10]; // 创建一个 String 类型的数组，能存放 5 个字符串 String[] arrayC = new String[5];} 数组的初始化接下来介绍 数组的初始化和注意事项 ，都写在代码里了，请看代码： 123456789101112131415161718192021222324252627282930313233343536/** * 01-动态初始化（指定长度）：在创建数组的时候，直接指定数组当中的数据元素个数。 * 02-静态初始化（指定内容）：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定。 * 03-静态初始化标准格式：数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, ... }; * 04-使用静态初始化数组的时候，格式还可以省略。省略格式：数据类型[] 数组名称 = { 元素1, 元素2, ... }; * 05-注意事项： * 1、静态初始化没有直接指定长度，但是根据大括号里面的元素具体内容，也可以自动推算出来长度。 * 2、静态初始化标准格式可以拆分成为两个步骤。 * 3、动态初始化也可以拆分成为两个步骤。 * 4、静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。 * 06-使用建议：如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。 */public static void main(String[] args) { // 直接创建一个数组，里面装的全都是 int 数字，具体为：5、15、25 int[] arrayA = new int[]{5, 15, 25, 40}; // 创建一个数组，用来装字符串：\"Hello\"、\"World\"、\"Java\" String[] arrayB = new String[]{\"Hello\", \"World\", \"Java\"}; // 省略格式的静态初始化 int[] arrayC = {10, 20, 30}; // 静态初始化的标准格式，可以拆分成为两个步骤 int[] arrayD; arrayD = new int[]{11, 21, 31}; // 动态初始化也可以拆分成为两个步骤 int[] arrayE; arrayE = new int[5]; // 静态初始化的省略格式，不能拆分成为两个步骤。// int[] arrayD;// arrayD = { 10, 20, 30 };} 数组的访问数组索引： 每一个存储到数组的元素，都会自动的拥有一个 编号，从 0 开始 ，这个自动编号称为 数组索引(index) 。我们可以通过 数组的索引 访问到 数组中的元素 。访问格式： 数组名[索引] ，代码演示如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 01-直接打印数组名称，得到的是数组对应的内存地址哈希值。 * 02-进制了解：二进制：01 十进制：0123456789 十六进制：0123456789abcdef * 03-访问数组元素的格式：数组名称[索引值]。索引值：就是一个 int 数字，代表数组当中元素的编号。 * 04-【注意】索引值从 0 开始，一直到 “ 数组的长度 - 1 ”为 止。 * 05-使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值。规则如下： * 如果是整数类型，那么默认为 0； * 如果是浮点类型，那么默认为 0.0； * 如果是字符类型，那么默认为 '\\u0000'； * 如果是布尔类型，那么默认为 false； * 如果是引用类型，那么默认为 null。 * 06-注意事项：静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成为了大括号当中的具体数值。 */public static void main(String[] args) { // 静态初始化的省略格式 int[] array = {10, 20, 30}; System.out.println(array); // 内存地址值 // 直接打印数组当中的元素 System.out.println(array[0]); // 10 System.out.println(array[1]); // 20 System.out.println(array[2]); // 30 System.out.println(\"=============\"); // 也可以将数组当中的某一个单个元素，赋值交给变量 int num = array[1]; System.out.println(num); // 20 // 动态初始化一个数组,使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值,具体规则如顶部注释。 int[] array2 = new int[3]; System.out.println(array); // 内存地址值 System.out.println(array[0]); // 0 System.out.println(array[1]); // 0 System.out.println(array[2]); // 0 System.out.println(\"=================\"); // 将数据 123 赋值交给数组 array 当中的 1 号元素 array2[1] = 123; System.out.println(array[0]); // 0 System.out.println(array[1]); // 123 System.out.println(array[2]); // 0} 数组常见的错误数组一般会出现 两个常见错误 ：数组越界异常 和 空指针异常 。具体代码如下： 12345678910111213141516171819202122232425262728293031/** * 01-数组的索引编号从 0 开始，一直到 “数组的长度 - 1” 为止。 * 02-如果访问数组元素的时候，索引编号并不存在，那么将发生：数组索引越界异常： ArrayIndexOutOfBoundsException * 03-原因及解决方法：原因：索引编号写错了。解决方法：修改成为存在的正确索引编号。 * 04-所有的引用类型变量，都可以赋值为一个 null 值。但是代表其中什么都没有。 * 05-数组必须进行 new 初始化才能使用其中的元素。 * 06-如果只是赋值了一个 null，没有进行 new 创建，那么将会发生：空指针异常： NullPointerException * 07-原因及解决方法：原因：忘了 new 。解决方法：补上 new */public static void main(String[] args) { int[] array = {15, 25, 35}; System.out.println(array[0]); // 15 System.out.println(array[1]); // 25 System.out.println(array[2]); // 35 // 错误写法：并不存在 3 号元素，所以发生数组越界异常 System.out.println(array[3]); // 给数组 arr 赋值为 null int[] arr = null; System.out.println(arr[0]); // 报错：NullPointerException ，IDEA 会有提示 char[] ch = new char[]{'a', 'b', 'c'}; // 这里输出的不是字符数组 ch 的地址，而是abc， // 因为 PrintStream 有多个重载的 println 方法，其中一个就是 public void println(char[] x)，直接打印字符数组 System.out.println(ch); // 如果要输出字符数组的地址，使用 toString() 方法 System.out.println(ch.toString());} 数组的各种操作第一种操作： 获取数组的长度 。代码演示如下： 123456789101112public static void main(String[] args) { // 静态初始化一个数组 int[] arr = {1, 2, 3, 4, 5, 6, 7}; // 获取数组的长度 int length = arr.length; // 输出查看结果 System.out.println(\"数组的长度：\" + length);} 第二种操作： 数组的遍历输出 。代码演示如下： 12345678910111213141516public static void main(String[] args) { // 静态初始化一个数组 int[] arr = {1, 2, 3, 4, 5, 6, 7}; // 第一种遍历方式： foreach for (int i : arr) { System.out.println(i); } // 第二种遍历方式 for for (int i = 0; i &lt; arr.length; i++) { System.out.println(\"arr[\" + i + \"] = \" + arr[i]); }} 第三种操作： 数组的最值获取 。代码演示如下： 123456789101112131415161718192021222324public static void main(String[] args) { // 静态初始化一个数组 int[] arr = {10, 2, 3, 40, 50, 6, 70}; int max = arr[0]; int min = arr[0]; for (int i = 1; i &lt; arr.length; i++) { // 获取最大值并保存于变量 max 中 if (arr[i] &gt; max) { max = arr[i]; } // 获取最小值并保存于变量 min 中 if (arr[i] &lt; min) { min = arr[i]; } } System.out.println(\"数组中最小值为：\" + min); System.out.println(\"数组中最大值为：\" + max);} 第四种操作： 数组的反转 。代码演示如下： 12345678910111213141516171819public static void main(String[] args) { // 静态初始化一个数组 int[] arr = {1, 2, 3, 4, 5, 6, 7}; // 数组的反转 for (int left = 0, right = arr.length - 1; left &lt; right; left++, right--) { int temp; temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; } // 数组的遍历 for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); }} 第五种操作： 数组作为方法的参数 。代码演示如下： 123456789101112131415161718192021222324252627public static void main(String[] args) { // 静态初始化一个数组 int[] arr = {1, 2, 3, 4, 5, 6, 7}; // 调用 getMax() 方法，获取数组最大值 int max = getMax(arr); // 输出查看结果 System.out.println(\"数组的最大值为：\" + max);}// 使用数组作为方法的参数，获取数组的最大值public static int getMax(int[] arr) { int max = arr[0]; for (int i = 0; i &lt; arr.length; i++) { if (max &lt; arr[i]) { max = arr[i]; } } return max;} 第六种操作： 数组作为返回值 。代码演示如下： 123456789101112131415public static void main(String[] args) { // 调用 getArray() 方法获得数组 int[] arr = getArray(2, 3, 4); // 打印查看结果 System.out.println(Arrays.toString(arr));}// 使用数组作为方法的返回值，从而得到一个数组public static int[] getArray(int a, int b, int c) { int[] arr = {a, b, c}; return arr;} 数组的原理内存图内存的概述内存 是计算机中的重要原件，临时存储区域 ，作用 是 运行程序 。我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。Java 虚拟机 要运行程序，必须要对内存进行空间的分配和管理。 Java中的内存划分为了提高运算效率 ，就对内存空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。具体区域如下图： 区域名称 作用 寄存器 给 CPU 使用，和我们开发无关。 本地方法栈 JVM 在使用操作系统功能的时候使用，和我们开发无关。 方法区 存储可以运行的 class 文件。 堆内存 存储对象或者数组，new 来创建的，都存储在堆内存。 方法栈 方法运行时使用的内存，比如 main 方法运行，进入方法栈中执行。 当 两个引用指向同一个数组 的时候，他们操作的其实是 堆内的同一块区域 。先看代码： 12345678910111213141516public static void main(String[] args) { // 定义第一个数组 int[] arr1 = new int[]{12, 13, 14}; // 定义第二个数组 int[] arr2 = arr1; // 两个数组的内存地址相同 System.out.println(arr1); System.out.println(arr2); // 改变数组的第三个元素 arr2[2] = 234; System.out.println(arr1[2]); System.out.println(arr2[2]);} 二维数组概念和初始化二维数组 就是 存储一维数组(内存地址/引用)的数组 。内存参考图如下： 二维数组的初始化 ，详见代码： 123456789101112131415161718192021222324public static void main(String[] args) { // 二维数组不是规则的矩阵 int[] arrayA[] = {{1, 2}, {2, 3, 4}, {3, 4, 5, 6}}; System.out.println(arrayA); // [[I@5e265ba4 两个[[表示是二维的，I表示数组是int型，@5e265ba4是内存地址 // 声明一个二维数组 arrayB ，用于存储 3 个一维数组，每一个一维数据存多少个数组，不知道 ，null int[][] arrayB = new int[3][]; // 给 arrayB 赋值 arrayB[0] = new int[3]; // 3 arrayB[1] = new int[]{1, 2, 3, 4}; // 4 arrayB[2] = new int[2]; // 2 // 打印查看结果 System.out.println(arrayB[1]); // [I@156643d4 System.out.println(arrayB[1][1]); // 2 // 声明一个二维数组，同时创建出一维数组，每个一维数组的长度均相同 // 存储三个一维数组，每个一维数组的长度为 4 int[] arrayC[] = new int[3][4]; System.out.println(arrayC);} 二维数组的遍历二维数组的遍历如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @Author: guoshizhan * @Create: 2020/3/3 23:19 * @Description: 二维数组的遍历 */public class ArrayTest { public static void main(String[] args) { // 定义一个二维数组 arr int[] arr[] = {{1, 2}, {2, 3, 4}, {3, 4, 5, 6}}; // (1)普通 for 循环遍历 for (int i = 0; i &lt; arr.length; i++) { // 0, 1, 2 for (int j = 0; j &lt; arr[i].length; j++) { // 每一个一维数组的长度 System.out.print(arr[i][j] + \"\\t\"); } System.out.println(); } // (2)加强 for 循环遍历 System.out.println(\"\\n-------------------------\"); for (int[] i : arr) { for (int j : i) { System.out.print(j + \"\\t\"); } System.out.println(); } // (3)普通与加强 for 循环的混搭 System.out.println(\"\\n-------------------------\"); for (int[] ints : arr) { // 加强 for for (int i = 0; i &lt; ints.length; i++) { System.out.print(ints[i] + \"\\t\"); } System.out.println(); } // (3)普通与加强for循环的混搭 System.out.println(\"\\n-------------------------\"); for (int i = 0; i &lt; arr.length; i++) { for (int j : arr[i]) { // 加强 for System.out.print(j + \"\\t\"); } System.out.println(); } }} 多维数组声明一个数组，引用存在于栈中，new 出来的对象 存在堆中。三维数组及多维数组 一般很少用到，有用到时自己查吧！下面是一个 三维数组的创建和遍历输出 。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * @Author: guoshizhan * @Create: 2020/3/3 23:36 * @Description: 三维数组的遍历 */public class ArrayTest { public static void main(String arg[]) { // 创建一个三维数组 arr ，arr 存放了 3 个二维数组：arr[0]、arr[1]、arr[2] int[][][] arr = new int[3][][]; // arr[0] ，存放了 3 个一维数组 arr[0] = new int[3][]; // arr[0][0] ，存放了 2 个数值 arr[0][0] = new int[2]; arr[0][0][0] = 1111; arr[0][0][1] = 1112; // arr[0][1] ，存放了 2 个数值 arr[0][1] = new int[2]; arr[0][1][0] = 1121; arr[0][1][1] = 1122; // arr[0][2] ，存放了 3 个数值 arr[0][2] = new int[3]; arr[0][2][0] = 1131; arr[0][2][1] = 1132; arr[0][2][2] = 1133; // arr[1] ，存放了 3 个一维数组 arr[1] = new int[3][]; // arr[1][0] ，存放了 2 个数值 arr[1][0] = new int[2]; arr[1][0][0] = 1211; arr[1][0][1] = 1212; // arr[1][1] ，存放了 2 个数值 arr[1][1] = new int[2]; arr[1][1][0] = 1221; arr[1][1][1] = 1222; // arr[1][2] ，存放了 2 个数值 arr[1][2] = new int[2]; arr[1][2][0] = 1231; arr[1][2][1] = 1232; // arr[2] ，存放了 3 个一维数组 arr[2] = new int[3][]; // arr[2][0] ，存放了 2 个数值 arr[2][0] = new int[2]; arr[2][0][0] = 1311; arr[2][0][1] = 1312; // arr[2][1] ，存放了 2 个数值 arr[2][1] = new int[2]; arr[2][1][0] = 1321; arr[2][1][1] = 1322; // arr[2][2] ，存放了 2 个数值 arr[2][2] = new int[2]; arr[2][2][0] = 1331; arr[2][2][1] = 1332; // 使用增强 for 循环输出结果 for (int[][] a2 : arr) { for (int[] a1 : a2) { for (int a: a1) { System.out.print(a + \"\\t\"); } System.out.println(); } System.out.println(); } }} 类与面向对象面向对象思想概述面向对象概述Java 语言 是一种 面向对象 的程序设计语言，而面向对象思想是一种程序设计思想。我们在面向对象思想的指引下，使用 Java 语言去设计、开发计算机程序。这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为 。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的 属性特征、行为特征 抽象出来，描述成计算机事件的设计思想。它区别于 面向过程思想 ，面向对象思想 强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。 面向对象举例 洗衣服: 面向过程：把衣服脱下来 --> 找一个盆 --> 放点洗衣粉 --> 加点水 --> 浸泡10分钟 --> 揉一揉 --> 清洗衣服 --> 拧干 --> 晾起来 面向对象：把衣服脱下来 --> 打开全自动洗衣机 --> 扔衣服 --> 按开关 --> 晾起来 面向过程和面向对象的区别: 面向过程：强调步骤。 面向对象：强调对象，这里的对象就是洗衣机。 面向对象特点面向对象思想 是一种更符合我们思考习惯的思想，它可以 将复杂的事情简单化 ，并将我们从执行者变成了指挥者。面向对象的语言中，包含了 三大基本特征：即 封装 、继承 和 多态 。这三大特性以后详细讲。 类和对象环顾周围，你会发现很多 对象 ，比如 桌子，椅子，同学，老师 等。桌椅属于办公用品，师生都是人类。那么什么是类呢？什么是对象呢？ 什么是类类： 是一组相关属性和行为的集合 。可以看成是一类事物的 模板 ，使用事物的 属性特征和行为特征 来描述该类事物。现实中，我们可以这样描述一类事物 （属性 + 行为） 。属性 就是该事物的状态信息 。行为 就是该事物能够做什么 。 类的举例： 举例：小猫。 属性：名字、体重、年龄、颜色。 行为：走、跑、叫。 类的定义格式 类的定义格式： 定义类：就是定义类的成员，包括成员变量和成员方法。 成员变量：和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。 成员方法：和以前定义方法几乎是一样的。只不过把static去掉，static的作用在面向对象后面课程中再详细讲解。 类的定义格式 代码演示如下： 1234567891011121314public class Student{ // 成员变量 String name; // 姓名 int age; // 年龄 // 定义成员方法 study() public void study(){ System.out.println(\"好好学习，天天向上\"); } // 定义成员方法 eat() public void eat(){ System.out.println(\"学习饿了要吃饭\"); }} 事物与类的对比 现实世界的一类事物： 属性：事物的状态信息。 行为：事物能够做什么。 Java 中用 class 描述事物也是如此： 成员变量：对应事物的属性 成员方法：对应事物的行为 什么是对象对象： 是一类事物的具体体现 。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的 属性和行为 。现实中，一类事物的一个实例就是对象 ：一只小猫。属性： tom、5kg、2years、yellow。行为： 溜墙根走、蹦跶的跑、喵喵叫。 类与对象的关系 类与对象的关系： 类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。 举个例子，手机模板 是 抽象的 ，不能被人使用，这个叫做 类 。但是 通过模板做成的手机 是 具体的 ，可以被使用，叫做 对象 ，也叫 实体 。参考图如下： 对象的使用对象的使用格式第一步： 了解 创建对象格式 以及 对象访问类中成员格式 ，如下： 1234567891011# 创建对象格式类名 对象名 = new 类名();#对象访问类中成员格式# 访问成员变量对象名.成员变量；# 访问成员方法对象名.成员方法()； 第二步： 创建 Student 实体类 ，代码如下： 1234567891011121314public class Student { public int age; public String name; public void study() { System.out.println(\"好好学习，天天向上\"); } public void eat() { System.out.println(\"学习饿了要吃饭\"); }} 第三步： 创建 Student 类的测试类 StudentTest ，用于创建 Student 类的 对象 并访问其 成员变量及成员方法 ，代码如下： 123456789101112131415161718192021222324252627282930public class StudentTest { public static void main(String[] args) { // 创建对象格式：类名 对象名 = new 类名(); Student stu = new Student(); System.out.println(\"stu：\" + stu); System.out.println(\"‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐\"); // 直接输出成员变量值 System.out.println(\"姓名：\" + stu.name); // null System.out.println(\"年龄：\" + stu.age); // 0 System.out.println(\"‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐\"); // 给成员变量赋值 stu.name = \"赵丽颖\"; stu.age = 18; // 再次输出成员变量的值 System.out.println(\"姓名：\" + stu.name); // 赵丽颖 System.out.println(\"年龄：\" + stu.age); // 18 System.out.println(\"‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐\"); // 调用成员方法 stu.study(); // \"好好学习，天天向上\" stu.eat(); // \"学习饿了要吃饭\" }} 成员变量的默认值 数据类型 默认值 整数（byte，short，int，long） 0 浮点数（ﬂoat，double） 0.0 字符（char） ‘\\u0000’ 布尔（boolean） false 数组，类，接口 null 类和对象的练习第一步： 定义一个 手机类 Phone ，代码如下： 1234567891011121314151617public class Phone { // 成员变量 String brand; // 品牌 double price; // 价格 String color; // 颜色 // 成员方法 public void call(String name) { System.out.println(\"给\" + name + \"打电话\"); } public void sendMessage() { System.out.println(\"群发短信\"); }} 第二步： 定义一个 测试类 PhoneTest ，代码如下： 123456789101112131415161718192021222324252627public class PhoneTest { public static void main(String[] args) { // 根据 Phone 类，创建一个名为 one 的对象 // 格式：类名称 对象名 = new 类名称(); Phone one = new Phone(); System.out.println(one.brand); // null System.out.println(one.price); // 0.0 System.out.println(one.color); // null System.out.println(\"=========\"); one.brand = \"苹果\"; one.price = 8388.0; one.color = \"黑色\"; System.out.println(one.brand); // 苹果 System.out.println(one.price); // 8388.0 System.out.println(one.color); // 黑色 System.out.println(\"=========\"); one.call(\"乔布斯\"); // 给乔布斯打电话 one.sendMessage(); // 群发短信 }} 对象内存图一个对象 两个对象 作为参数 作为返回值 成员变量与局部变量两者概念成员变量 分为 类变量（static修饰） 和 实例变量（无static） 。类变量 可以直接使用类名调用，实例变量 需要 创建对象 才能使用。局部变量 是定义在方法里或定义在方法的参数位置 。它们的具体区别如下： 两者区别 在类中的位置不同： 成员变量：类中，方法外 局部变量：方法中或者方法声明上(形式参数) 作用范围不一样： 成员变量：类中 局部变量：方法中 初始化值的不同： 成员变量：有默认值 局部变量：没有默认值，必须先定义，赋值，最后使用 在内存中的位置不同： 成员变量：堆内存 局部变量：栈内存 生命周期不同： 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 封装特性封装概述面向对象 编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装 可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。 要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性 。 原则： 将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。封装步骤： ① 使用 private 关键字 来修饰成员变量。② 对需要访问的成员变量，提供对应的 一对 getxxx 方法、 setxxx 方法 。 private 关键字 private 的含义： private 是一个权限修饰符，代表最小权限。 可以修饰成员变量和成员方法。 被 private 修饰后的成员变量和成员方法，只在本类中才能访问。 使用 private 修饰成员变量 ，代码如下： 1234567public class Student{ // private 的使用格式：private 数据类型 变量名; private String name; private int age;} 提供 getxxx 方法/ setxxx 方法 ，可以访问成员变量，代码如下： 12345678910111213141516171819202122class Student { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} this 关键字请看下面一段代码，看是否会出现问题。代码如下： 1234567891011121314public class Student{ private String name; private int age; public void setName(String name){ name = name; } public void setAge(int age){ age = age; }} 经过测试，我们发现了一个问题，成员变量赋值失败了 。也就是说，在修改了的形参变量名后，方法并没有给成员变量赋值！这是由于 形参变量名与成员变量名重名 ，导致成员变量名被隐藏，方法中的变量名，无法访问到成员变量，从而赋值失败。所以，我们只能使用 this 关键字，来解决这个重名问题。this 代表所在类的当前对象的引用（地址值） ，即对象自己的引用。方法被哪一个对象调用，方法中的 this 就代表那个对象。即谁在调用，this 就代表谁。代码演示如下： 123456789101112131415161718192021222324class Student { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } // this 使用格式：this.成员变量名; public int getAge() { return age; } // this 使用格式：this.成员变量名; public void setAge(int age) { this.age = age; }} 构造方法当一个对象被创建时候，构造方法 用来 初始化该对象，给对象的成员变量赋初始值 。 小提示： 无论你与否自定义构造方法，所有的类都有构造方法 。因为 Java 会 自动提供了一个无参数构造方法 。一旦自己定义了构造方法，那么 Java 自动提供的默认无参数构造方法就会失效，除非自己再重新定义一个无参构造方法。 构造方法在写法上，方法名与它所在的类名相同 。它没有返回值，所以不需要返回值类型，甚至不需要 void 。代码演示如下： 1234567891011121314151617181920/** * 构造方法的格式： * 修饰符 构造方法名(参数列表) { * //方法体 * } */class Student { private String name; private int age; public Student() { // 无参构造 } public Student(String name, int age) { // 有参构造 this.name = name; this.age = age; }} 注意事项： 1、如果你不提供构造方法，系统会给出无参数构造方法。 2、如果你提供了构造方法，系统将不再提供无参数构造方法。 3、构造方法是可以重载的，既可以定义参数，也可以不定义参数。 标准代码 JavaBeanJavaBean 是 Java 语言编写类的一种 标准规范 。符合 JavaBean 的类，要求 类必须是具体的和公共的，并且具有无参数的构造方法 ，还需要提供用来操作成员变量的 getxxx 和 setxxx 方法 。 1234567891011public class ClassName{ // 成员变量 // 构造方法 // 无参构造方法【必须】 // 有参构造方法【建议】 // 成员方法 // getXxx() // setXxx()} 编写符合 JavaBean 规范的类，以学生类为例，标准代码如下： 123456789101112131415161718192021222324252627282930313233class Student { // 成员变量 private String name; private int age; // 无参构造方法 public Student() { } // 有参构造方法 public Student(String name, int age) { this.name = name; this.age = age; } // getxxx 和 setxxx 方法 public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 到此为止，Java 基础（上篇） 就结束了，接下来相关的文章是 Java 基础（中篇）。","link":"/JavaSE-01.html"},{"title":"Java 中的 IO 流","text":"内容概要： File-类 递归 IO-流概述 字节流 字符流 IO-异常的处理 Properties-属性集 缓冲流 转换流 序列化流 打印流 File 类File 概述java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。具体功能如下： 具体功能： 创建一个文件/文件夹 删除文件/文件夹 获取文件/文件夹 判断文件/文件夹是否存在 对文件夹进行遍历 获取文件的大小 输出路径分隔符和文件名称分隔符的代码如下： 123456789101112131415public static void main(String[] args) { // 01-路径分隔符【例如环境变量里的分隔符】 windows系统使用“分号”，linux系统使用“冒号” String pathSeparator = File.pathSeparator; System.out.println(pathSeparator); char pathSeparatorChar = File.pathSeparatorChar; System.out.println(pathSeparatorChar); // 02-文件名称分隔符 windows系统使用反斜杠\\ linux系统使用正斜杠/ String separator = File.separator; System.out.println(separator); char separatorChar = File.separatorChar; System.out.println(separatorChar);} 构造方法 构造方法： public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File 实例。 public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File 实例。 public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File 实例。 构造方法代码如下： 12345678910111213141516public static void main(String[] args) { // 01-public File(String pathname) File file01 = new File(\"F:\\\\00-BLOG-HOME\\\\themes\\\\icarus-latest\\\\layout\\\\widget\"); System.out.println(file01); // 重写了 toString 方法，否则会打印内存地址 // 02-public File(String parent, String child) File file02 = new File(\"F:\\\\\", \"00-BLOG-HOME\"); System.out.println(file02); // 03-public File(File parent, String child) File parent = new File(\"F:\\\\\"); File file03 = new File(parent, \"00-BLOG-HOME\"); System.out.println(file03);} 小贴士： 一个 File 对象代表硬盘中实际存在的一个文件或者目录，无论该路径下是否存在文件或者目录，都不影响 File 对象的创建。 常用方法获取功能的方法 获取功能的方法 public String getAbsolutePath() ：返回此 File 的绝对路径名字符串。 public String getPath() ：将此 File 转换为路径名字符串。 public String getName() ：返回由此 File 表示的文件或目录的名称。 public long length() ：返回由此 File 表示的文件的长度。 方法演示，代码如下： 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) { // 01-public String getAbsolutePath() File file01 = new File(\"F:\\\\00-BLOG-HOME\\\\themes\\\\icarus-latest\\\\layout\\\\widget\"); System.out.println(file01.getAbsolutePath()); File file02 = new File(\"00-BLOG-HOME\"); System.out.println(file02.getAbsolutePath()); // 02-public String getPath() System.out.println(file01.getPath()); System.out.println(file02.getPath()); System.out.println(file01); System.out.println(file01.toString()); // 看源码知：toString 调用的就是 getPath() 方法 // 03-public String getName() ，获取的就是构造方法传递路径的结尾部分(文件/文件夹) System.out.println(file01.getName()); System.out.println(file02.getName()); /** * 04-public long length() ：返回由此 File 表示的文件的长度。获取的是构造方法指定的文件的大小,以字节为单位。 * 注意 : 1、文件夹是没有大小概念的,不能获取文件夹的大小。2、如果构造方法中给出的路径不存在,那么length方法返回0 */ // 获取文件大小，不存在返回 0 File file04 = new File(\"F:\\\\00-BLOG-HOME\\\\source\\\\about\\\\index.md\"); System.out.println(file04.length()); // 获取文件夹大小，直接返回 0 ，因为文件夹没有大小，只有文件有大小 File file05 = new File(\"F:\\\\00-BLOG-HOME\\\\source\\\\about\"); System.out.println(file05.length());} 判断功能的方法 判断功能的方法 public boolean exists() ：此 File 表示的文件或目录是否实际存在。 public boolean isDirectory() ：此 File 表示的是否为目录。 public boolean isFile() ：此 File 表示的是否为文件。 方法演示，代码如下： 12345678910111213141516171819202122public static void main(String[] args) { // 01-public boolean exists() ：用于判断构造方法中的路径是否存在 File file01 = new File(\"F:\\\\00-BLOG-HOME\\\\themes\\\\icarus-latest\\\\layout\\\\widget\"); System.out.println(file01.exists()); File file02 = new File(\"00-BLOG-HOME\"); System.out.println(file02.exists()); /** * 02-public boolean isDirectory() ：用于判断构造方法中给定的路径是否以文件夹结尾 * 03-public boolean isFile() ：用于判断构造方法中给定的路径是否以文件结尾 * 注意 : 1、电脑的硬盘中只有文件/文件夹,两个方法是互斥。2、这两个方法使用前提,路径必须是存在的,否则都返回 false */ if(file01.exists()){ System.out.println(file01.isDirectory()); System.out.println(file01.isFile()); System.out.println(file02.isDirectory()); System.out.println(file02.isFile()); }} 创建和删除功能的方法 创建和删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 public boolean delete() ：删除由此 File 表示的文件或目录。 public boolean mkdir() ：创建由此 File 表示的目录。 public boolean mkdirs() ：创建由此 File 表示的目录，包括任何必需但不存在的父目录。 方法演示，代码如下： 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) throws IOException { //demo01(); //demo02(); //demo03();}private static void demo03() { // 04-public boolean delete() ：可以删除构造方法路径中给出的文件/文件夹 // 注意：文件/文件夹删除成功,返回 true 。2、文件夹中有内容,不会删除返回 false ; 构造方法中路径不存在 false 。 // 注意：delete 方法是直接在硬盘删除文件/文件夹,不走回收站,删除要谨慎。 File file05 = new File(\"F:\\\\home\\\\111\"); System.out.println(file05.delete());}private static void demo02() { // 02-public boolean mkdir() ：创建单级空文件夹 File file03 = new File(\"F:\\\\home\\\\啊啊啊\"); System.out.println(file03.mkdir()); // 03-public boolean mkdirs() ：既可以创建单级空文件夹,也可以创建多级文件夹，创建文件夹的路径和名称在构造方法中给出(构造方法的参数) File file04 = new File(\"F:\\\\home\\\\111\\\\啊啊啊\"); System.out.println(file04.mkdirs()); // 注意 : 1.此方法只能创建文件夹,不能创建文件。2、文件夹不存在,创建文件夹,返回 true 。 // 3、文件夹存在,不会创建,返回 false;构造方法中给出的路径不存在返回 false}private static void demo01() throws IOException { // 01-public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。创建文件的路径和名称在构造方法中给出(构造方法的参数) // 注意 : 1、此方法只能创建文件,不能创建文件夹。2、创建文件的路径必须存在,否则会抛出异常。3、文件不存在,创建文件,返回 true ，文件存在,不会创建,返回 false 。 File file01 = new File(\"F:\\\\home\\\\01.txt\"); System.out.println(file01.createNewFile()); File file02 = new File(\"F:\\\\blog-home\\\\01.txt\"); System.out.println(file02.createNewFile()); // 路径不存在，抛异常：java.io.IOException: 系统找不到指定的路径。} 目录的遍历详情看代码： 1234567891011121314151617181920public static void main(String[] args) { // 01-public String[] list() ：返回一个 String 数组，表示该 File 目录中的所有子文件或目录。 File file01 = new File(\"F:\\\\home\"); String[] list = file01.list(); for (String str : list) { System.out.println(str); } // 02-public File[] listFiles() ：返回一个 File 数组，表示该 File 目录中的所有的子文件或目录。 File file02 = new File(\"F:\\\\home\"); File[] listFiles = file02.listFiles(); for (File file : listFiles) { System.out.println(file); } // 03-注意事项： // 1、list 方法和 listFiles 方法遍历的是构造方法中给出的目录，如果构造方法中给出的目录的路径不存在,会抛出空指针异常。 // 2、如果构造方法中给出的路径不是一个目录,也会抛出空指针异常。} 调用 listFiles 方法的 File 对象，表示的必须是实际存在的目录，否则返回 null，无法进行遍历。 递归递归概述 递归: 指在当前方法内调用自己的这种现象。递归的分类: 递归分为两种，直接递归和间接递归。直接递归: 方法自身调用自己。间接递归: 可以理解为 A 方法调用 B 方法，B 方法调用 C 方法，C 方法调用 A 方法。注意事项：1、递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。2、在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。3、构造方法,禁止递归。 递归分析图解： 12345678910111213public static void main(String[] args) { recursion(1);}private static void recursion(int i) { // 添加一个递归结束的条件，i == 500 的时候结束 // 如果此递归没有结束条件，会报异常：Exception in thread \"main\" java.lang.StackOverflowError if(i &gt; 500){ return; // 结束方法 } System.out.println(i); recursion(++i);} 递归累加求和1234567891011public static void main(String[] args) { int sum = sum(100); System.out.println(sum);}public static int sum(int n) { if (n == 1) { return 1; } return n + sum(n - 1);} 递归求阶乘1234567891011public static void main(String[] args) { long mul = mul(10); System.out.println(mul); } public static long mul(int n){ if(n == 1){ return 1; } return n * mul(n - 1); } 递归打印多级目录1234567891011121314151617// 定义一个变量，记录文件数目static int count = 0;public static void main(String[] args) { File file = new File(\"F:\\\\home\"); getFiles(file);}public static void getFiles(File file){ File[] list = file.listFiles(); for (File s : list) { if(s.isDirectory()){ getFiles(s); } System.out.println(s); System.out.println(++count); }} 文件搜索123456789101112131415161718192021 // 定义一个变量，记录文件数目static int count = 0;public static void main(String[] args) { File file = new File(\"F:\\\\home\"); getFiles(file);}public static void getFiles(File file) { File[] list = file.listFiles(); for (File s : list) { if (s.isDirectory()) { getFiles(s); } else { if (s.toString().endsWith(\".xml\")) { System.out.println(s); System.out.println(++count); } } }} 文件搜索之过滤器 文件过滤器： 1、java.io.FileFilter 是一个接口，是 File 的过滤器。该接口的对象可以传递给 File 类的 listFiles(FileFilter) 作为参数。 2、接口中只有一个方法 boolean accept(File pathname) ，测试 pathname 是否应该包含在当前 File 目录中，符合则返回 true。 1234567891011121314151617181920212223242526272829// 定义一个变量，记录文件数目static int count = 0;public static void main(String[] args) { File file = new File(\"F:\\\\home\"); getFiles(file);}public static void getFiles(File file) { File[] list = file.listFiles(new FileFilter() { @Override public boolean accept(File pathname) { if(pathname.isDirectory()){ return true; } return pathname.getName().toLowerCase().endsWith(\".xml\"); } }); for (File s : list) { if (s.isDirectory()) { getFiles(s); } else { if (s.toString().endsWith(\".xml\")) { System.out.println(s); System.out.println(++count); } } }} 过滤器之 Lambda 优化1234567891011121314151617181920212223 // 定义一个变量，记录文件数目 static int count = 0;public static void main(String[] args) { File file = new File(\"F:\\\\home\"); getFiles(file); System.out.println(\"\\n匹配到的合适的文件个数：\" + count + \"个\");}public static void getFiles(File file) { // 使用 Lambda 表达式优化了匿名内部类 File[] list = file.listFiles(pathname-&gt; pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(\".xml\")); for (File s : list) { if (s.isDirectory()) { getFiles(s); } else { if (s.toString().endsWith(\".xml\")) { System.out.println(s); count++; } } }} IO 流概述什么是 IO 流当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。我们把这种数据的传输，可以看做是一种数据的流动，称之为 IO 流 。按照流动的方向，以内存为基准，分为 输入流 input 和 输出流 output ，即流向内存是输入流，流出内存的输出流。如下草图： Java 中 IO 操作主要是指使用 java.io 包下的内容所进行的输入、输出操作。输入 也叫做读取数据，输出 也叫做作写出数据。 IO 流的分类 根据数据的流向分： 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存中写出到其他设备上的流。 根据数据的类型分： 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 根据分类不同，IO 流所对应的类也有所不同，如下表： 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer IO 流的简单介绍就到这里了，下面将详细介绍 Java 中的 IO 流。请往下阅读 👇👇👇 字节流一切皆为字节一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都是一个一个的字节，那么在传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 字节输出流java.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。 字节输出流的通用方法： public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b) ：将 b.length 字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 FileOutputStream 类OutputStream 有很多子类，我们从最简单的一个子类 java.io.FileOutputStream 开始。这个类是文件输出流，用于将数据写出到文件，也就是从内存把数据写出到硬盘上。 写出数据的原理(内存 --> 硬盘): java 程序 --> JVM(java 虚拟机) --> OS(操作系统) --> OS 调用写数据的方法 --> 把数据写入到文件中 字节输出流的使用步骤(重点): 1、创建一个 FileOutputStream 对象,构造方法中传递写入数据的目的地 2、调用 FileOutputStream 对象中的方法 write ,把数据写入到文件中 3、释放资源(IO 流操作会占用一定的内存,使用完毕要把内存清空,提供程序的效率) 构造方法 构造方法： public FileOutputStream(File file) ： 创建文件输出流以写入由指定的 File 对象表示的文件。 public FileOutputStream(String name) ： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。上述两种构造方法举例，代码如下： 1234567891011121314public static void main(String[] args) throws Exception { // 01-创建文件对象 File file = new File(\"F:\\\\home\\\\02.txt\"); // 02-创建输出流对象的第一种构造方法 FileOutputStream fos = new FileOutputStream(file); // 03-创建输出流对象的第二种构造方法 FileOutputStream fileOutputStream = new FileOutputStream(\"F:\\\\home\\\\03.txt\"); // 04-关闭流 fileOutputStream.close(); fos.close();} 写出字节数据通过 write(int b) 方法，每次可以写出一个字节数据，代码使用演示： 1234567891011121314public static void main(String[] args) throws IOException { // 01-使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"F:\\\\home\\\\fos.txt\"); // 02-写出数据 fos.write(97); // 写出第1个字节 fos.write(98); // 写出第2个字节 fos.write(99); // 写出第3个字节 // 03-关闭资源 fos.close();}// 输出结果 ：abc 小贴士： 1、虽然参数为 int 类型四个字节，但是只会保留一个字节的信息写出。2、流操作完毕后，必须释放系统资源，调用 close 方法，千万记得。 写出字节数组通过 write(byte[] b) 方法，每次可以写出数组中的数据，代码使用演示： 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws Exception {public static void main(String[] args) throws Exception { /** * 一次写多个字节的方法: * public void write(byte[] b)：将 b.length 字节从指定的字节数组写入此输出流。 * public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流。 */ FileOutputStream fileOutputStream = new FileOutputStream(\"F:\\\\home\\\\03.txt\"); FileOutputStream fos = new FileOutputStream(\"F:\\\\home\\\\04.txt\"); // 01-如果写的第一个字节是正数(0 —— 127),那么显示的时候会查询 ASCII 表 byte[] arr = {65, 66, 67, 68, 69}; // ABCDE // 02-向文件中写入数据 fileOutputStream.write(arr); // 03-如果写的第一个字节是负数,那第一个字节会和第二个字节,两个字节组成一个中文显示,查询系统默认码表(GBK) byte[] bytes = {-65, -66, -67, 68, 69}; // 烤紻E fos.write(bytes); // 04-public void write(byte[] b, int off, int len fos.write(arr, 1, 2); // 04.txt文件中：烤紻EBC // 05-写入字符串的方法 : 可以使用 String 类中的 getBytes() 方法把字符串,转换为字节数组 byte[] str = \"你好\".getBytes(); System.out.println(Arrays.toString(str)); // [-28, -67, -96, -27, -91, -67] fos.write(str); // 04.txt文件中：烤紻EBC浣犲ソ // 06-关闭流 fileOutputStream.close(); fos.close();} 写出指定长度字节数组通过 write(byte[] b, int off, int len) 方法,每次写出从 off 索引开始，len 个字节，代码使用演示： 123456789101112public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(\"F:\\\\home\\\\06.txt\"); // 字符串转换为字节数组 byte[] b = \"abcde\".getBytes(); // 写出从索引 2 开始，2 个字节。索引 2 是 c，两个字节，也就是 cd fos.write(b, 2, 2); // 关闭资源 fos.close();} 数据追加续写当我们创建输出流对象时，都会清空目标文件中的数据。那么如何保留目标文件中数据，并且还能继续添加新数据呢？使用以下两个构造方法便可以解决我们苦恼的问题。构造方法如下： 构造方法： public FileOutputStream(File file, boolean append) ： 创建文件输出流以写入由指定的 File 对象表示的文件。 public FileOutputStream(String name, boolean append) ： 创建文件输出流以指定的名称写入文件。 这两个构造方法的参数中，都需要传入一个boolean 类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了。代码演示如下： 12345678910111213public static void main(String[] args) throws IOException { // 这样创建流对象，可以在 05.txt 文件中追加数据 FileOutputStream fos = new FileOutputStream(\"F:\\\\home\\\\05.txt\"，true); // 字符串转换为字节数组 byte[] bytes = \"abcde\".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(bytes); // 关闭资源 fos.close();} 写出换行Windows 系统里，换行符号是 \\r\\n ，代码演示如下： 1234567891011121314151617public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(\"F:\\\\home\\\\05.txt\"); // 定义字节数组 byte[] words = {97, 98, 99, 100, 101}; // 遍历数组 for (int i = 0; i &lt; words.length; i++) { // 写出一个字节 fos.write(words[i]); // 写出一个换行, 换行符号转成数组写出 fos.write(\"\\r\\n\".getBytes()); } // 关闭资源 fos.close();} 回车符和换行符： 回车符：回到一行的开头（return）。 换行符：下一行（newline）。 各种系统的回车换行： 1、Windows 系统里，每行结尾是【回车 + 换行】 ，即 \\r\\n 2、Unix/Linux 系统里，每行结尾只有【换行】 ，即 \\n 3、Mac 系统里，每行结尾是【回车】 ，即 \\r 。从 Mac OS X 开始与 Linux 统一 字节输入流java.io.InputStream 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 基本共性功能方法： public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read()： 从输入流读取数据的下一个字节。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 FileInputStream 类java.io.FileInputStream 类是文件输入流，从文件中读取字节。 读入数据的原理(硬盘-->内存)： java 程序 --> JVM --> OS --> OS读取数据的方法 --> 读取文件 字节输入流的使用步骤(重点) : 1、创建 FileInputStream 对象,构造方法中绑定要读取的数据源 2、使用 FileInputStream 对象中的方法 read , 读取文件 3、释放资源 构造方法 构造方法： FileInputStream(File file) ： 创建一个 FileInputStream ，该文件由文件系统中的 File 对象 file 命名。 FileInputStream(String name) ： 创建一个 FileInputStream ，该文件由文件系统中的路径名 name 命名。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出 FileNotFoundException 。构造举例，代码如下： 123456789101112public static void main(String[] args) throws IOException{ // 01-使用 File 对象创建流对象 File file = new File(\"F:\\\\home\\\\05.txt\"); FileInputStream fos = new FileInputStream(file); // 02-使用文件名称创建流对象 FileInputStream fileInputStream = new FileInputStream(\"F:\\\\home\\\\06.txt\"); // 03-关闭资源 fileInputStream.close(); fos.close();} 读取字节数据通过 read 方法，每次可以读取一个字节的数据，提升为 int 类型，读取到文件末尾，返回 -1 ，代码演示如下： 12345678910111213141516public static void main(String[] args) throws Exception { // 01-创建输入流对象 FileInputStream fileInputStream = new FileInputStream(\"F:\\\\home\\\\04.txt\"); // 02-记录读取到的字节 int read = fileInputStream.read(); // 03-循环输出内容 while (read != -1){ System.out.print(read + \" \"); read = fileInputStream.read(); } // 04-关闭资源 fileInputStream.close();} 小贴士： 1、虽然读取了一个字节，但是会自动提升为 int 类型。2、流操作完毕后，必须释放系统资源，调用 close 方法，千万记得。 使用字节数组读取通过 read(byte[] b) ，每次读取 b 个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回 -1 ，代码使用演示： 123456789101112131415161718192021222324public static void main(String[] args) throws IOException{ // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(\"F:\\\\home\\\\06.txt\"); // 文件中为 abcde // 定义变量，作为有效个数 int len； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len = fis.read(b)) != -1) { // 每次读取后,把数组变成字符串打印 System.out.println(new String(b)); } // 关闭资源 fis.close();}// 输出结果：// ab// cd// ed 最后一次读取的 ed 是错误数据 ，原因是：在最后一次读取中，上次读取到的数据 c 被 e 替换了，而 d 没有被替换，只读取一个字节 e ，从而产生了错误。所以要通过 len 来获取有效的字节。代码使用演示： 123456789101112131415161718192021222324public static void main(String[] args) throws IOException { // 01-使用文件名称创建流对象. FileInputStream fis = new FileInputStream(\"F:\\\\home\\\\03.txt\"); // 文件中为 abcde // 02-定义变量，作为有效个数 int len; // 03-定义字节数组，作为装字节数据的容器 byte[] b = new byte[1024]; // 04-循环读取 while ((len = fis.read(b)) != -1) { // 每次读取后,把数组的有效字节部分，变成字符串打印 System.out.println(new String(b, 0, len)); // len 每次读取的有效字节个数 System.out.println(len); } // 05-关闭资源 fis.close();}// 输出结果：// abcde// 5 小贴士： 使用数组读取，每次读取多个字节，减少了系统间的 IO 操作次数，从而提高了读写的效率，建议开发中使用。 图片复制练习复制原理图解 案例实现复制图片文件，代码演示如下： 1234567891011121314151617181920212223242526272829public static void main(String[] args) throws IOException { // 1、创建一个字节输入流对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(\"F:\\\\home\\\\01.png\"); // 2、创建一个字节输出流对象,构造方法中绑定要写入的目的地 FileOutputStream fos = new FileOutputStream(\"F:\\\\01.png\"); // 一次读取一个字节写入一个字节的方式 // 3、使用字节输入流对象中的方法read读取文件 /*int len = 0; while((len = fis.read())!=-1){ // 4、使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中 fos.write(len); }*/ // 3、使用数组缓冲读取多个字节,写入多个字节 byte[] bytes = new byte[1024 * 8]; // 4、使用字节输入流对象中的方法 read 读取文件 int len; // 每次读取的有效字节个数 while ((len = fis.read(bytes)) != -1) { // 5、使用字节输出流中的方法 write , 把读取到的字节写入到目的地的文件中 fos.write(bytes, 0, len); } // 6、释放资源(先关写的,后关闭读的;如果写完了,肯定读取完毕了) fos.close(); fis.close();} 小贴士： 流的关闭原则：先开后关，后开先关。 字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以 Java 提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 使用字节流读取中文文件,1个中文所占用字节如下：GBK: 占用 2 字节UTF-8: 占用 3 个字节 字符输入流java.io.Reader 抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。 基本共性功能方法： public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read() ： 从输入流读取一个字符。 public int read(char[] cbuf) ： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中 。 FileReader 类java.io.FileReader 类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 小贴士： 1、字符编码：字节与字符的对应规则。Windows 系统的中文编码默认是 GBK 编码表。在 IDEA 中是 UTF-8 编码。2、字节缓冲区：一个字节数组，用来临时存储字节数据。 构造方法 构造方法： FileReader(File file) ： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName) ： 创建一个新的 FileReader ，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径。类似于 FileInputStream 。构造举例，代码如下： 123456789101112public static void main(String[] args) throws IOException{ // 01-使用 File 对象创建流对象 File file = new File(\"F:\\\\home\\\\02.txt\"); FileReader fr = new FileReader(file); // 02-使用文件名称创建流对象 FileReader fileReader = new FileReader(\"F:\\\\home\\\\03.txt\"); // 03-关闭资源 fileReader.close(); fr.close();} 读取字符数据通过 read 方法，每次可以读取一个字符的数据，提升为 int 类型，读取到文件末尾，返回 -1 ，循环读取，代码使用演示： 123456789101112131415public static void main(String[] args) throws IOException { // 使用文件名称创建流对象 FileReader fr = new FileReader(\"F:\\\\home\\\\02.txt\"); // 定义变量，保存数据 int b; // 循环读取 while ((b = fr.read()) != -1) { System.out.println((char)b); } // 关闭资源 fr.close();} 小贴士： 虽然读取了一个字符，但是会自动提升为 int 类型。 通过 read(char[] cbuf) 方法，每次读取 b 个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回 -1 ，代码演示： 1234567891011121314151617181920public static void main(String[] args) throws IOException { // 1、创建 FileReader 对象,构造方法中绑定要读取的数据源 FileReader fr = new FileReader(\"F:\\\\home\\\\01.txt\"); // 2、int read(char[] cbuf) 一次读取多个字符,将字符读入数组。 char[] cs = new char[2]; // 存储读取到的多个字符 int len; while((len = fr.read(cs)) != -1){ // String类的构造方法：String(char[] value) 把字符数组转换为字符串 System.out.println(new String(cs); } // 3、释放资源 fr.close();}// 输出结果：// 我在// 这里// 呀里 获取有效的字符改进，避免读取到无效的字符，代码使用演示： 1234567891011121314151617181920public static void main(String[] args) throws IOException { // 1、创建 FileReader 对象,构造方法中绑定要读取的数据源 FileReader fr = new FileReader(\"F:\\\\home\\\\01.txt\"); // 2、int read(char[] cbuf) 一次读取多个字符,将字符读入数组。 char[] cs = new char[2]; // 存储读取到的多个字符 int len; while((len = fr.read(cs)) != -1){ // String(char[] value, int offset, int count) 把字符数组的一部分转换为字符串 offset 数组的开始索引 count 转换的个数 System.out.println(new String(cs, 0, len)); } // 3、关闭资源 fr.close();}// 输出结果：// 我在// 这里// 呀 字符输出流java.io.Writer 抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。以下是字符输出流的基本共性功能方法。 基本共性功能方法： void write(int c) ，写入单个字符。 void write(char[] cbuf) ，写入字符数组。 abstract void write(char[] cbuf, int off, int len) ，写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 void write(String str) ，写入字符串。 void write(String str, int off, int len) ，写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 void flush() ，刷新该流的缓冲。 void close() ，关闭此流，但要先刷新它。 FileWriter 类java.io.FileWriter 类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 构造方法 构造方法： FileWriter(File file) ： 创建一个新的 FileWriter，给定要读取的 File 对象。 FileWriter(String fileName) ： 创建一个新的 FileWriter，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径，类似于 FileOutputStream 。构造举例，代码如下： 123456789101112public static void main(String[] args) throws IOException { // 使用 File 对象创建流对象 File file = new File(\"F:\\\\home\\\\05.txt\"); FileWriter fw = new FileWriter(file); // 使用文件名称创建流对象 FileWriter fileWriter = new FileWriter(\"F:\\\\home\\\\06.txt\"); // 03-关闭资源 fileWriter.close(); fw.close();} 基本写出数据通过 write(int b) 方法，每次可以写出一个字符数据，代码使用演示： 12345678910111213141516public static void main(String[] args) throws IOException { // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"F:\\\\home\\\\07.txt\"); // 写出数据 fw.write(97); // 写出第1个字符 fw.write('b'); // 写出第2个字符 fw.write('C'); // 写出第3个字符 fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。 // 【注意】关闭资源时,与 FileOutputStream 不同。如果不关闭,数据只是保存到缓冲区，并未保存到文件。 fw.close();}// 输出结果：// abC田 小贴士： 1、虽然参数为 int 类型四个字节，但是只会保留一个字符的信息写出。2、未调用 close 方法，数据只是保存到了缓冲区，并未写出到文件中。 关闭和刷新因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要使用 flush() 方法了。代码演示如下： 1234567891011121314151617181920212223/** * flush 方法和 close 方法的区别： * - flush ：刷新缓冲区，流对象可以继续使用。 * - close ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 */public static void main(String[] args) throws IOException { // 1、创建 FileWriter 对象,构造方法中绑定要写入数据的目的地 FileWriter fw = new FileWriter(\"F:\\\\home\\\\08.txt\"); // 2、使用 FileWriter 中的方法 write , 把数据写入到内存缓冲区中(字符转换为字节的过程) // void write(int c) 写入单个字符。 fw.write(97); // 3、使用 FileWriter 中的方法 flush , 把内存缓冲区中的数据,刷新到文件中 fw.flush(); fw.write(98); // 刷新之后流可以继续使用 // 4、释放资源(会先把内存缓冲区中的数据刷新到文件中) fw.close(); // close 方法之后流已经关闭了,已经从内存中消失了,流就不能再使用了 fw.write(99); // IOException: Stream closed} 小贴士： 即便是 flush 方法写出了数据，操作的最后还是要调用 close 方法，释放系统资源。 写出其他数据 写出字符数组 ：通过 write(char[] cbuf) 方法和 write(char[] cbuf, int off, int len) 方法 ，每次可以写出字符数组中的数据，用法类似于 FileOutputStream ，代码演示如下： 12345678910111213141516public static void main(String[] args) throws IOException { // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"F:\\\\home\\\\09.txt\"); // 字符串转换为字节数组 char[] chars = \"井冈山大学\".toCharArray(); // 写出字符数组 fw.write(chars); // 井冈山大学 // 写出从索引3开始，写2个字节。索引3是'大'，两个字节，也就是 大学 fw.write(b, 3, 2); // 大学 // 关闭资源 fos.close();} 写出字符串：通过 write(String str) 方法和 write(String str, int off, int len) 方法，每次可以写出字符串中的数据，更为方便，代码演示如下： 12345678910111213141516public static void main(String[] args) throws IOException { // 01-使用文件名称创建流对象 FileWriter fw = new FileWriter(\"F:\\\\home\\\\10.txt\"); // 02-定义字符串 String msg = \"井冈山大学\"; // 03-写出字符串 fw.write(msg); // 井冈山大学 // 04-写出从索引3开始，写2个字节。索引3是'大'，两个字节，也就是 大学 fw.write(msg, 3, 2); // 大学 // 05-关闭资源 fw.close();} 数据追加续写1234567891011121314151617181920public static void main(String[] args) throws IOException { // 01-使用文件名称创建流对象，可以续写数据 FileWriter fw = new FileWriter(\"F:\\\\home\\\\11.txt\"，true); // 02-写出字符串 fw.write(\"井冈山\"); // 03-写出换行 fw.write(\"\\r\\n\"); // 04-写出字符串 fw.write(\"大学\"); // 05-关闭资源 fw.close();}// 输出结果:// 井冈山// 大学 小贴士： 1、字符流只能操作文本文件，不能操作图片、视频等非文本文件。2、当我们单纯读或者写文本文件时可以使用字符流，其他情况使用字节流。 IO 异常的处理JDK7 前处理之前的代码中，我们一直把异常抛出，而实际开发中并不能这样处理，而是建议使用 try...catch...finally 代码块处理异常部分，代码演示如下： 123456789101112131415161718192021222324252627282930313233343536373839/** * 在jdk1.7之前使用try catch finally 处理流中的异常 * 格式: * try{ * 可能会产出异常的代码 * }catch(异常类变量 变量名){ * 异常的处理逻辑 * }finally{ * 一定会执行的代码 * 资源释放 * } */public static void main(String[] args) { // 提高变量 fw 的作用域,让 finally 可以使用。变量在定义的时候,可以没有值,但是使用的时候必须有值 // fw = new FileWriter(\"09_IOAndProperties\\\\g.txt\",true); 执行失败,fw 没有值,fw.close 会报错 FileWriter fw = null; try{ // 可能会产出异常的代码 fw = new FileWriter(\"F:\\\\home\\\\11.txt\", true); for (int i = 0; i &lt; 10 ; i++) { fw.write(\"HelloWorld \" + i + \"\\r\\n\"); } }catch(IOException e){ // 异常的处理逻辑 System.out.println(e); }finally { // 一定会执行的代码 // 创建对象失败了,fw的默认值就是 null , null 是不能调用方法的,会抛出 NullPointerException , 需要增加一个判断,不是 null 在把资源释放 if(fw != null){ try { // fw.close 方法声明抛出了 IOException 异常对象,所以我们就的处理这个异常对象,要么 throws , 要么 try catch fw.close(); } catch (IOException e) { e.printStackTrace(); } } }} JDK7 的处理还可以使用 JDK7 优化后的 try-with-resource 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。代码演示如下： 1234567891011121314151617181920212223242526/** * JDK7 的新特性 * 在try的后边可以增加一个(),在括号中可以定义流对象 * 那么这个流对象的作用域就在try中有效 * try中的代码执行完毕,会自动把流对象释放,不用写finally */public static void main(String[] args) { try(// 1、创建一个字节输入流对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(\"F:\\\\home\\\\12.txt\"); // 2、创建一个字节输出流对象,构造方法中绑定要写入的目的地 FileOutputStream fos = new FileOutputStream(\"F:\\\\home\\\\13.txt\");){ // 可能会产出异常的代码 // 一次读取一个字节写入一个字节的方式 // 3、使用字节输入流对象中的方法 read 读取文件 int len = 0; while((len = fis.read()) != -1){ // 4、使用字节输出流中的方法 write , 把读取到的字节写入到目的地的文件中 fos.write(len); } }catch (IOException e){ // 异常的处理逻辑 System.out.println(e); }} JDK9 的改进123456789101112131415161718192021222324252627282930313233/** * JDK9 新特性 * try的前边可以定义流对象 * 在try后边的()中可以直接引入流对象的名称(变量名) * 在try代码执行完毕之后,流对象也可以释放掉,不用写finally * 格式: * A a = new A(); * B b = new B(); * try(a,b){ * 可能会产出异常的代码 * }catch(异常类变量 变量名){ * 异常的处理逻辑 * } */public static void main(String[] args) throws IOException { // 1、创建一个字节输入流对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(\"F:\\\\home\\\\14.txt\"); // 2、创建一个字节输出流对象,构造方法中绑定要写入的目的地 FileOutputStream fos = new FileOutputStream(\"F:\\\\home\\\\15.txt\"); try(fis; fos){ // 一次读取一个字节写入一个字节的方式 // 3、使用字节输入流对象中的方法 read 读取文件 int len = 0; while((len = fis.read()) != -1){ // 4、使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中 fos.write(len); } }catch (IOException e){ System.out.println(e); }} Properties 属性集属性集概述java.util.Properties 继承于 Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多 Java 类使用，比如获取系统属性时，System.getProperties 方法就是返回一个 Properties 对象。 Properties 类构造方法和其他方法 构造方法： public Properties() : 创建一个空的属性列表。 其他方法： public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 public Set stringPropertyNames() ：所有键的名称的集合。 上述方法代码演示如下： 1234567891011121314151617181920212223242526/** * 使用Properties 集合存储数据,遍历取出 Properties 集合中的数据。Properties 集合是一个双列集合,key 和 value 默认都是字符串 * Properties集合有一些操作字符串的特有方法 * Object setProperty(String key, String value) 调用 Hashtable 的方法 put。 * String getProperty(String key) 通过 key 找到 value 值,此方法相当于 Map 集合中的 get(key) 方法 * Set&lt;String&gt; stringPropertyNames() 返回此属性列表中的键集，其中该键及其对应值是字符串,此方法相当于 Map 集合中的 keySet 方法 */public static void main(String[] args) { // 01-创建 Properties 集合对象 Properties prop = new Properties(); // 02-使用 setProperty 往集合中添加数据 prop.setProperty(\"赵丽颖\", \"168\"); prop.setProperty(\"迪丽热巴\", \"165\"); prop.setProperty(\"古力娜扎\", \"160\"); // 03-使用 stringPropertyNames 把 Properties 集合中的键取出,存储到一个 Set 集合中 Set&lt;String&gt; set = prop.stringPropertyNames(); // 04-遍历 Set 集合,取出 Properties 集合的每一个键 for (String key : set) { // 05-使用 getProperty 方法通过 key 获取 value String value = prop.getProperty(key); System.out.println(key + \" = \" + value); }} 与流相关的方法这是保存的方法，知识点都在代码的注释里面了，请看代码演示： 12345678910111213141516171819202122232425/** * 可以使用 Properties 集合中的方法 store,把集合中的临时数据,持久化写入到硬盘中存储 * void store(OutputStream out, String comments) * void store(Writer writer, String comments) * 参数: * OutputStream out: 字节输出流,不能写入中文 * Writer writer: 字符输出流,可以写中文 * String comments: 注释,用来解释说明保存的文件是做什么用的，但是不能使用中文,会产生乱码,默认是 Unicode 编码,一般使用\"\"空字符串 */public static void main(String[] args) throws IOException { // 1、创建 Properties 集合对象并添加数据 Properties prop = new Properties(); prop.setProperty(\"赵丽颖\", \"168\"); prop.setProperty(\"迪丽热巴\", \"165\"); prop.setProperty(\"古力娜扎\", \"175\"); // 2、创建字符输出流对象,构造方法中绑定要输出的目的地，不要使用字节输出流，会乱码 FileWriter fw = new FileWriter(\"F:\\\\home\\\\14.txt\"); // 3、使用 Properties 集合中的方法 store,把集合中的临时数据,持久化写入到硬盘中存储 prop.store(fw,\"save my data\"); // 4、释放资源 fw.close();} 这是读取的方法，知识点都在代码的注释里面了，请看代码演示： 1234567891011121314151617181920212223242526/** * 可以使用 Properties 集合中的方法 load,把硬盘中保存的文件(键值对),读取到集合中使用 * void load(InputStream inStream) * void load(Reader reader) * 参数: * InputStream inStream : 字节输入流,不能读取含有中文的键值对 * Reader reader : 字符输入流,能读取含有中文的键值对 * 注意事项: * 1、存储键值对的文件中,键与值默认的连接符号可以使用=,空格(其他符号) * 2、存储键值对的文件中,可以使用#进行注释,被注释的键值对不会再被读取 * 3、存储键值对的文件中,键与值默认都是字符串,不用再加引号 */public static void main(String[] args) throws IOException { // 1、创建 Properties 集合对象 Properties prop = new Properties(); // 2、使用 Properties 集合对象中的方法 load 读取保存键值对的文件 prop.load(new FileReader(\"F:\\\\home\\\\14.txt\")); // 3、遍历 Properties 集合 Set&lt;String&gt; set = prop.stringPropertyNames(); for (String key : set) { String value = prop.getProperty(key); System.out.println(key + \" = \" + value); }} 小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。 缓冲流 上面介绍了基本的一些流，作为 IO 流的入门。现在我们要见识一些更强大的流，比如能够高效读写的缓冲流、能够转换编码的转换流、能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。 缓冲流概述缓冲流，也叫高效流，是对 4 个基本的 FileXxx 流的增强。缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统 IO 操作的次数，从而提高读写的效率。以下是缓冲流的分类： 按照数据类型分类： 字节缓冲流：BufferedInputStream 和 BufferedOutputStream 字符缓冲流：BufferedReader 和 BufferedWriter 字节缓冲流构造方法 构造方法： public BufferedInputStream(InputStream in) ：创建一个新的缓冲输入流。 public BufferedOutputStream(OutputStream out) ： 创建一个新的缓冲输出流。 构造方法举例如下： 12345// 01-创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"F:\\\\home\\\\05.txt\"));// 02-创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"F:\\\\home\\\\05.txt\")); 字节缓冲输出流字节缓冲输出流【BufferedOutputStream】实际案例如下： 123456789101112131415161718192021222324252627282930/** * 继承自父类的共性成员方法: * public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 * public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 * public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 * public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 * public abstract void write(int b) ：将指定的字节输出流。 * 构造方法: * BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 * BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 * 参数: * OutputStream out:字节输出流，我们可以传递FileOutputStream,缓冲流会给FileOutputStream增加一个缓冲区,提高FileOutputStream的写入效率 * int size:指定缓冲流内部缓冲区的大小,不指定默认 */public static void main(String[] args) throws IOException { // 1、创建 FileOutputStream 对象,构造方法中绑定要输出的目的地 FileOutputStream fos = new FileOutputStream(\"F:\\\\home\\\\05.txt\"); // 2、创建 BufferedOutputStream 对象,构造方法中传递 FileOutputStream 对象,提高效率 BufferedOutputStream bos = new BufferedOutputStream(fos); // 3、使用 BufferedOutputStream 对象中的方法 write , 把数据写入到内部缓冲区中 bos.write(\"井冈山大学\".getBytes()); // 4、使用 BufferedOutputStream 对象中的方法 flush , 把内部缓冲区中的数据,刷新到文件中 bos.flush(); // 5、释放资源(会先调用 flush 方法刷新数据,第4部可以省略) bos.close();} 字节缓冲输入流字节缓冲输入流【BufferedInputStream】实际案例如下： 123456789101112131415161718192021222324252627282930313233343536/** * 继承自父类的成员方法: * int read()从输入流中读取数据的下一个字节。 * int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 * void close() 关闭此输入流并释放与该流关联的所有系统资源。 * 构造方法: * BufferedInputStream(InputStream in) 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 * BufferedInputStream(InputStream in, int size) 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 * 参数: * InputStream in:字节输入流，我们可以传递FileInputStream,缓冲流会给FileInputStream增加一个缓冲区,提高FileInputStream的读取效率 * int size:指定缓冲流内部缓冲区的大小,不指定默认 */public static void main(String[] args) throws IOException { // 1、创建 FileInputStream 对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(\"F:\\\\home\\\\05.txt\"); // 2、创建 BufferedInputStream 对象,构造方法中传递 FileInputStream 对象,提高读取效率 BufferedInputStream bis = new BufferedInputStream(fis); // 3、使用 BufferedInputStream 对象中的方法 read ,读取文件 // int read() 从输入流中读取数据的下一个字节，也就是一个字节一个字节地读，效率低// int len; // 记录每次读取到的字节// while((len = bis.read()) != -1){// System.out.println(len);// } // int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 byte[] bytes = new byte[1024 * 8];//存储每次读取的数据 int len; // 记录每次读取的有效字节个数 while ((len = bis.read(bytes)) != -1) { System.out.println(new String(bytes, 0, len)); } // 4、释放资源 bis.close();} 效率测试查询 API，缓冲流读写方法与基本的流是一致的。那我们通过复制大文件（229MB），来测试它的效率。 基本流的复制，代码演示如下： 12345678910111213141516171819202122public static void main(String[] args) { // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( FileInputStream fis = new FileInputStream(\"F:\\\\home\\\\01.pdf\"); FileOutputStream fos = new FileOutputStream(\"F:\\\\01.pdf\") ) { // 读写数据 int b; while ((b = fis.read()) != -1) { fos.write(b); } } catch (IOException e) { e.printStackTrace(); } // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\"普通流复制时间: \" + (end - start) + \" 毫秒\");}// 普通流复制时间: 1278098 毫秒 缓冲流的复制，代码演示如下： 12345678910111213141516171819202122public static void main(String[] args) { // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"F:\\\\home\\\\01.pdf\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"F:\\\\01.pdf\")) ) { // 读写数据 int b; while ((b = bis.read()) != -1) { bos.write(b); } } catch (IOException e) { e.printStackTrace(); } // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\"缓冲流复制时间: \" + (end - start) + \" 毫秒\");}// 缓冲流复制时间: 10480 毫秒 那么如何做才能更快呢？答案是：使用数组的方式，代码如下： 1234567891011121314151617181920212223public static void main(String[] args) { // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"F:\\\\home\\\\01.pdf\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"F:\\\\02.pdf\")) ) { // 读写数据 int len; byte[] bytes = new byte[8 * 1024]; while ((len = bis.read(bytes)) != -1) { bos.write(bytes, 0, len); } } catch (IOException e) { e.printStackTrace(); } // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\"缓冲流使用数组复制时间: \" + (end - start) + \" 毫秒\");}// 缓冲流使用数组复制时间: 566 毫秒 字符缓冲流构造方法 构造方法： public BufferedReader(Reader in) ：创建一个新的缓冲输入流。 public BufferedWriter(Writer out) ： 创建一个新的缓冲输出流。 构造方法举例如下： 12345// 01-创建字符缓冲输入流BufferedReader br = new BufferedReader(new FileReader(\"F:\\\\home\\\\05.txt\"));// 02-创建字符缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter(\"F:\\\\home\\\\05.txt\")); 特有方法字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 特有方法： BufferedReader：public String readLine() : 读一行文字。 BufferedWriter：public void newLine() : 相当于换行分隔符,由系统属性定义符号。 public String readLine() 方法演示，代码如下： 12345678910111213141516public static void main(String[] args) throws IOException { // 创建流对象 BufferedReader br = new BufferedReader(new FileReader(\"F:\\\\home\\\\05.txt\")); // 定义字符串,保存读取的一行文字 String line; // 循环读取,读取到最后返回 null while ((line = br.readLine()) != null) { System.out.print(line); System.out.println(\"---\"); } // 释放资源 br.close();} public void newLine() 方法演示，代码如下： 12345678910111213141516171819202122public static void main(String[] args) throws IOException { // 创建流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(\"F:\\\\home\\\\edu.txt\")); // 写出数据 bw.write(\"井冈山\"); // 写出换行 bw.newLine(); bw.write(\"大学\"); bw.newLine(); bw.write(\"欢迎你\"); bw.newLine(); // 释放资源 bw.close();}// 输出效果:// 井冈山// 大学// 欢迎你 字符缓冲输出流字符缓冲输出流【BufferedWriter】实际案例如下： 12345678910111213141516171819202122232425262728293031323334/** * 继承自父类的共性成员方法: * void write(int c) 写入单个字符。 * void write(char[] cbuf)写入字符数组。 * abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分, off 数组的开始索引, len 写的字符个数。 * void write(String str)写入字符串。 * void write(String str, int off, int len) 写入字符串的某一部分,off 字符串的开始索引, len 写的字符个数。 * void flush()刷新该流的缓冲。 * void close() 关闭此流，但要先刷新它。 * * 构造方法: * BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流。 * BufferedWriter(Writer out, int sz) 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。 * 参数: * Writer out:字符输出流，我们可以传递FileWriter,缓冲流会给FileWriter增加一个缓冲区,提高FileWriter的写入效率 * int sz:指定缓冲区的大小,不写默认大小 */public static void main(String[] args) throws IOException { // 1、创建字符缓冲输出流对象,构造方法中传递字符输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\"F:\\\\home\\\\edu.txt\")); // 2、调用字符缓冲输出流中的方法 write , 把数据写入到内存缓冲区中 for (int i = 0; i &lt; 10 ; i++) { bw.write(\"井冈山大学~~~\"); // bw.write(\"\\r\\n\"); bw.newLine(); } // 3、调用字符缓冲输出流中的方法 flush ,把内存缓冲区中的数据,刷新到文件中 bw.flush(); // 4、释放资源 bw.close();} 字符缓冲输入流字符缓冲输入流【BufferedReader】实际案例如下： 12345678910111213141516171819202122232425262728/** * 继承自父类的共性成员方法: * int read() 读取单个字符并返回。 * int read(char[] cbuf)一次读取多个字符,将字符读入数组。 * void close() 关闭该流并释放与之关联的所有资源。 * 构造方法: * BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流。 * BufferedReader(Reader in, int sz) 创建一个使用指定大小输入缓冲区的缓冲字符输入流。 * 参数: * Reader in:字符输入流，我们可以传递FileReader,缓冲流会给FileReader增加一个缓冲区,提高FileReader的读取效率 * 特有的成员方法: * String readLine() 读取一个文本行。读取一行数据 * 行的终止符号:通过下列字符之一即可认为某行已终止：换行 ('\\n')、回车 ('\\r') 或回车后直接跟着换行(\\r\\n)。 * 返回值:包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null */public static void main(String[] args) throws IOException { // 1、创建字符缓冲输入流对象,构造方法中传递字符输入流 BufferedReader br = new BufferedReader(new FileReader(\"F:\\\\home\\\\05.txt\")); // 2、使用字符缓冲输入流对象中的方法read/readLine读取文本 String line; while ((line = br.readLine()) != null) { System.out.println(line); } // 3、释放资源 br.close();} 练习：文本排序练习描述请将下列文本信息恢复顺序。 1234567893.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。 案例分析 1、逐行读取文本信息。 2、解析文本信息到集合中。 3、遍历集合，按顺序，写出文本信息。 代码实现1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args) throws IOException { // 1、创建一个 HashMap 集合对象,存储每行文本的序号(1,2,3,..);value:存储每行的文本 HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); // 2、创建字符缓冲输入流对象,构造方法中绑定字符输入流 BufferedReader br = new BufferedReader(new FileReader(\"F:\\\\home\\\\05.txt\")); // 3、创建字符缓冲输出流对象,构造方法中绑定字符输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\"F:\\\\05.txt\")); // 4、使用字符缓冲输入流中的方法 readline ,逐行读取文本 String line; while ((line = br.readLine()) != null) { // 5、对读取到的文本进行切割,获取行中的序号和文本内容 String[] arr = line.split(\"\\\\.\"); // 6、把切割好的序号和文本的内容存储到 HashMap 集合中(key 序号是有序的,会自动排序 1,2,3,4..) map.put(arr[0], arr[1]); } // 7、遍历 HashMap 集合,获取每一个键值对 for (String key : map.keySet()) { String value = map.get(key); // 8、把每一个键值对,拼接为一个文本行 line = key + \".\" + value; // 9、把拼接好的文本,使用字符缓冲输出流中的方法 write ,写入到文件中 bw.write(line); bw.newLine(); // 写换行 } // 10、释放资源 bw.close(); br.close();} 转换流字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为 编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为 解码 。比如说，按照 A 规则存储，同样按照 A 规则解析，那么就能显示正确的文本符号。反之，按照 A 规则存储，再按照 B 规则解析，就会导致乱码现象。 各种概念： 编码 : 字符(我们能看懂的) --> 字节(我们看不懂的) 解码 : 字节(我们看不懂的) --> 字符(我们能看懂的) 字符编码【Character Encoding】 : 就是一套自然语言的字符与二进制数之间的对应规则。 编码表 : 生活中文字和计算机中二进制的对应规则 字符集字符集【Charset】 ：也叫编码表，是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有 ASCII 字符集 、GBK 字符集 、Unicode 字符 集等。字符编码与字符集对应关系如下图： 可见，当指定了 编码，它所对应的 字符集 自然就指定了，所以 编码 才是我们最终要关心的。接下来我们介绍各种字符集。 ASCII 字符集 1、 ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 2、 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1 字符集 拉丁码表，别名 Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。ISO-8859-1 使用单字节编码，兼容 ASCII 编码。 GBxxx 字符集 1、 GB 就是国标的意思，是为了显示中文而设计的一套字符集。 2、 GB2312 ：简体中文码表。一个小于 127 的字符的意义与原来相同。但两个大于 127 的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。 3、 GBK ：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 4、 GB18030 ：最新的中文码表。收录汉字 70244 个，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 1、 Unicode 编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。它最多使用 4 个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16 和 UTF-32。最为常用的 UTF-8 编码。 2、 UTF-8 编码，可以用来表示 Unicode 标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持 UTF-8 编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则如下： &nbsp;&nbsp;&nbsp;&nbsp;1、 128 个 US-ASCII 字符，只需一个字节编码。 &nbsp;&nbsp;&nbsp;&nbsp;2、 拉丁文等字符，需要二个字节编码。 &nbsp;&nbsp;&nbsp;&nbsp;3、 大部分常用字（含中文），使用三个字节编码。 &nbsp;&nbsp;&nbsp;&nbsp;4、 其他极少使用的 Unicode 辅助字符，使用四字节编码。 编码引出的问题在 IDEA 中，可以使用 FileReader 读取项目中的文本文件。由于 IDEA 默认是 UTF-8 编码，所以读取的内容没有任何问题。但是，当读取 Windows 系统中创建的文本文件时，由于 Windows 系统的默认是 GBK 编码，就会出现乱码。代码演示如下： 1234567891011public static void main(String[] args) throws IOException { FileReader fileReader = new FileReader(\"F:\\\\GBK.txt\"); // 井冈山大学 int read; while ((read = fileReader.read()) != -1) { System.out.print((char)read); } fileReader.close();}// 输出结果：// ����ɽ��ѧ 那么问题来了，我们要如何才能读取 GBK 编码的文件呢？这时就要用到转换流了。接着往下看 👇👇👇 转换流图解 InputStreamReader 类转换流 java.io.InputStreamReader ，是 Reader 的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 构造方法 InputStreamReader(InputStream in) : 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName) : 创建一个指定字符集的字符流。 指定编码读取1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws IOException { read_gbk(); read_utf_8();}// 使用 InputStreamReader 读取 GBK 格式的文件private static void read_gbk() throws IOException { // 1、创建 InputStreamReader 对象,构造方法中传递字节输入流和指定的编码表名称 InputStreamReader isr = new InputStreamReader(new FileInputStream(\"F:\\\\gbk.txt\"),\"GBK\"); // 你好 // 2、使用InputStreamReader对象中的方法 read 读取文件 int len; while((len = isr.read())!=-1){ System.out.println((char)len); } // 3、释放资源 isr.close();}// 使用 InputStreamReader 读取 UTF-8 格式的文件private static void read_utf_8() throws IOException { // 1、创建 InputStreamReader 对象,构造方法中传递字节输入流和指定的编码表名称 InputStreamReader isr = new InputStreamReader(new FileInputStream(\"F:\\\\utf_8.txt\")); // 不指定默认使用 UTF-8 // 2、使用 InputStreamReader 对象中的方法 read 读取文件 int len; while((len = isr.read())!=-1){ System.out.println((char)len); } // 3、释放资源 isr.close();} OutputStreamWriter 类转换流 java.io.OutputStreamWriter ，是 Writer 的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 构造方法 OutputStreamWriter(OutputStream in) : 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName) : 创建一个指定字符集的字符流。 指定编码写出12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) throws IOException { gbk(); utf_8();}// 使用转换流 OutputStreamWriter 写 GBK 格式的文件private static void gbk() throws IOException { // 1、创建 OutputStreamWriter 对象,构造方法中传递字节输出流和指定的编码表名称 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"F:\\\\gbk.txt\"),\"GBK\"); // 2、使用 OutputStreamWriter 对象中的方法 write , 把字符转换为字节存储缓冲区中(编码) osw.write(\"你好\"); // 3、使用 OutputStreamWriter 对象中的方法 flush , 把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程) osw.flush(); // 4、释放资源 osw.close();}// 使用转换流 OutputStreamWriter 写 UTF-8 格式的文件private static void utf_8() throws IOException { // 1、创建 OutputStreamWriter 对象,构造方法中传递字节输出流和指定的编码表名称 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"F:\\\\utf_8.txt\"),\"utf-8\"); // 不指定默认使用UTF-8 // 2、使用 OutputStreamWriter 对象中的方法 write , 把字符转换为字节存储缓冲区中(编码) osw.write(\"你好\"); // 3、使用 OutputStreamWriter 对象中的方法 flush , 把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程) osw.flush(); // 4、释放资源 osw.close();} 练习：转换文件编码将 GBK 编码的文本文件，转换为 UTF-8 编码的文本文件。代码演示如下： 123456789101112131415161718public static void main(String[] args) throws IOException { // 1、创建 InputStreamReader 对象,构造方法中传递字节输入流和指定的编码表名称 GBK InputStreamReader isr = new InputStreamReader(new FileInputStream(\"F:\\\\GBK.txt\"),\"GBK\"); // 2、创建 OutputStreamWriter 对象,构造方法中传递字节输出流和指定的编码表名称 UTF-8 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"F:\\\\utf_8.txt\"),\"UTF-8\"); // 3、使用 InputStreamReader 对象中的方法 read 读取文件 int len; while((len = isr.read()) != -1){ // 4、使用 OutputStreamWriter 对象中的方法 write , 把读取的数据写入到文件中 osw.write(len); } // 5、释放资源 osw.close(); isr.close();} 序列化流Java 提供了一种对象 序列化 的机制。用一个字节序列可以表示一个对象，该字节序列包含该 对象的数据 、对象的类型 和 对象中存储的属性 等信息。字节序列写出到文件之后，相当于文件中 持久保存 了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行 反序列化。对象的数据 、对象的类型 和 对象中存储的数据 信息，都可以用来在内存中创建对象。请看下图理解序列化： ObjectOutputStream 类java.io.ObjectOutputStream 类，将 Java 对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法 构造方法 public ObjectOutputStream(OutputStream out) ： 创建一个指定 OutputStream 的 ObjectOutputStream 。 序列化操作 一、对象要想序列化，必须满足两个条件： 1、该类必须实现 java.io.Serializable 接口，这是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出 NotSerializableException 。 2、该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用 transient 关键字修饰。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* * 序列化和反序列化的时候,会抛出NotSerializableException没有序列化异常 * 类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。 * Serializable接口也叫标记型接口 * 要进行序列化和反序列化的类必须实现Serializable接口,就会给类添加一个标记 * 当我们进行序列化和反序列化的时候,就会检测类上是否有这个标记 * 有:就可以序列化和反序列化 * 没有:就会抛出 NotSerializableException异常 * 去市场买肉--&gt;肉上有一个蓝色章(检测合格)--&gt;放心购买--&gt;买回来怎么吃随意 * * * static关键字:静态关键字 * 静态优先于非静态加载到内存中(静态优先于对象进入到内存中) * 被static修饰的成员变量不能被序列化的,序列化的都是对象 * private static int age; * oos.writeObject(new Person(\"小美女\",18)); * Object o = ois.readObject(); * Person{name='小美女', age=0} * * transient关键字:瞬态关键字 * 被transient修饰成员变量,不能被序列化 * private transient int age; * oos.writeObject(new Person(\"小美女\",18)); * Object o = ois.readObject(); * Person{name='小美女', age=0} */public class Person implements Serializable{ // 防止出现 InvalidClassException private static final long serialVersionUID = 1L; private String name; //private static int age; //private transient int age; public int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 二、写出对象方法： 通过 public final void writeObject (Object obj)` 方法，将指定的对象写出。 12345678910111213141516171819202122/* * java.io.ObjectOutputStream extends OutputStream * ObjectOutputStream:对象的序列化流 * 作用:把对象以流的方式写入到文件中保存 * * 构造方法: * ObjectOutputStream(OutputStream out) 创建写入指定 OutputStream 的 ObjectOutputStream。 * 参数: * OutputStream out:字节输出流 * 特有的成员方法: * void writeObject(Object obj) 将指定的对象写入 ObjectOutputStream。 */public static void main(String[] args) throws IOException { // 1、创建 ObjectOutputStream 对象,构造方法中传递字节输出流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"F:\\\\person.txt\")); // 2、使用 ObjectOutputStream 对象中的方法 writeObject ,把对象写入到文件中 oos.writeObject(new Person(\"小美女\", 18)); // 3、释放资源 oos.close();} ObjectInputStream 类ObjectInputStream 反序列化流，将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象。 构造方法 构造方法： public ObjectInputStream(InputStream in) ： 创建一个指定 InputStream 的 ObjectInputStream 。 反序列化操作一 反序列化操作一： 如果能找到一个对象的 class 文件，我们可以进行反序列化操作，调用 ObjectInputStream 读取对象的 public final Object readObject() 方法，读取一个对象。 123456789101112131415public static void main(String[] args) throws IOException, ClassNotFoundException { // 1、创建 ObjectInputStream 对象,构造方法中传递字节输入流 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"F:\\\\person.txt\")); // 2、使用 ObjectInputStream 对象中的方法 readObject 读取保存对象的文件 Object o = ois.readObject(); // 3、释放资源 ois.close(); // 4、使用读取出来的对象(打印) System.out.println(o); Person p = (Person)o; System.out.println(p.getName() + p.getAge());} JVM 可以反序列化对象的条件： 它必须能够找到 class 文件的类，如果找不到该类的 class 文件，则会抛出一个 ClassNotFoundException 异常。 反序列化操作二还有一种情况，当 JVM 反序列化对象时，能找到 class 文件，但是 class 文件在序列化对象之后发生了修改，那么反序列化操作也会失败，会抛出一个 InvalidClassException 异常。 InvalidClassException 原因如下： 1、该类的序列版本号与从流中读取的类描述符的版本号不匹配 2、该类包含未知数据类型 3、该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。该版本号的目的在于验证序列化的对象和对应类是否版本匹配。只要给上述 Person 类加入下面代码就可以防止该异常发生。代码如下： 12// 防止出现 InvalidClassException private static final long serialVersionUID = 1L; 练习：序列化集合 1、将存有多个自定义对象的集合序列化操作，保存到 list.txt 文件中。 2、反序列化 list.txt ，并遍历集合，打印对象信息。 案例分析 案例分析： 1、把若干学生对象 ，保存到集合中。 2、把集合序列化。 3、反序列化读取时，只需要读取一次，转换为集合类型。 4、遍历集合，可以打印所有的学生信息。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 练习：序列化集合// 当我们想在文件中保存多个对象的时候，可以把多个对象存储到一个集合中，对集合进序列化和反序列化。public static void main(String[] args) throws IOException, ClassNotFoundException { // 1、定义一个存储 Person 对象的 ArrayList 集合 ArrayList&lt;Person&gt; list = new ArrayList&lt;&gt;(); // 2、往 ArrayList 集合中存储 Person 对象 list.add(new Person(\"张三\",18)); list.add(new Person(\"李四\",19)); list.add(new Person(\"王五\",20)); // 3、创建一个序列化流 ObjectOutputStream 对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"F:\\\\list.txt\")); // 4、使用 ObjectOutputStream 对象中的方法 writeObject ,对集合进行序列化 oos.writeObject(list); // 5、创建一个反序列化 ObjectInputStream 对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"F:\\\\list.txt\")); // 6、使用 ObjectInputStream 对象中的方法 readObject 读取文件中保存的集合 Object o = ois.readObject(); // 7、把 Object 类型的集合转换为 ArrayList 类型 ArrayList&lt;Person&gt; list2 = (ArrayList&lt;Person&gt;)o; // 8、遍历 ArrayList 集合 for (Person p : list2) { System.out.println(p); } // 9、释放资源 ois.close(); oos.close();}class Person implements Serializable{ // 防止出现 InvalidClassException private static final long serialVersionUID = 1L; private String name; //private static int age; //private transient int age; public int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 打印流打印流概述平时我们在控制台打印输出，是调用 print 方法和 println 方法完成的，这两个方法都来自于 java.io.PrintStream 类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。接下来我们介绍 PrintStream 类。 PrintStream 类构造方法 构造方法： public PrintStream(String fileName) ： 使用指定的文件名创建一个新的打印流。 改变打印流向System.out 就是 PrintStream 类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个 “小把戏” ，改变它的流向。示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * java.io.PrintStream:打印流 * PrintStream 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。 * PrintStream特点: * 1.只负责数据的输出,不负责数据的读取 * 2.与其他输出流不同，PrintStream 永远不会抛出 IOException * 3.有特有的方法,print,println * void print(任意类型的值) * void println(任意类型的值并换行) * 构造方法: * PrintStream(File file):输出的目的地是一个文件 * PrintStream(OutputStream out):输出的目的地是一个字节输出流 * PrintStream(String fileName) :输出的目的地是一个文件路径 * PrintStream extends OutputStream * 继承自父类的成员方法: * - public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 * - public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 * - public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 * - public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 * - public abstract void write(int b) ：将指定的字节输出流。 * 注意: * 如果使用继承自父类的write方法写数据,那么查看数据的时候会查询编码表 97-&gt;a * 如果使用自己特有的方法print/println方法写数据,写的数据原样输出 97-&gt;97 */public static void main(String[] args) throws FileNotFoundException { // 创建打印流 PrintStream 对象,构造方法中绑定要输出的目的地 PrintStream ps = new PrintStream(\"F:\\\\print.txt\"); // 如果使用继承自父类的write方法写数据,那么查看数据的时候会查询编码表 97-&gt;a ps.write(97); // 如果使用自己特有的方法 print/println 方法写数据,写的数据原样输出 97-&gt;97 ps.println(97); ps.println(8.8); ps.println('a'); ps.println(\"HelloWorld\"); ps.println(true); // 释放资源 ps.close();} 示例代码二如下： 123456789101112131415/** * 可以改变输出语句的目的地(打印流的流向) * 输出语句,默认在控制台输出 * 使用 System.setOut 方法改变输出语句的目的地改为参数中传递的打印流的目的地 * static void setOut(PrintStream out) : 重新分配“标准”输出流。 */public static void main(String[] args) throws FileNotFoundException { System.out.println(\"我是在控制台输出\"); PrintStream ps = new PrintStream(\"F:\\\\print-out.txt\"); System.setOut(ps); // 把输出语句的目的地改变为打印流的目的地 System.out.println(\"我在打印流的目的地中输出\"); // 不会在控制台显示，会在 print-out.txt 文件里显示 ps.close();} Java 中的 IO 流到此结束了，欢迎评论区留言！！！","link":"/Java-IO.html"},{"title":"Java 基础（中篇）","text":"API 与 Scanner 类API 的概述API(Application Programming Interface) ，应用程序编程接口 。JavaAPI 是一本程序员的字典，是 JDK 中提供给我们使用的 类的说明文档 。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。所以我们可以通过查询 API 的方式，来学习 Java 提供的类，并得知如何使用它们。 API 的使用步骤 API 的使用步骤： 1、打开帮助文档。 2、点击显示，找到索引，看到输入框。 3、你要找谁？在输入框里输入，然后回车。 4、看包。java.lang 下的类不需要导包，其他需要。 5、看类的解释和说明。 6、学习构造方法和使用成员方法。 什么是 Scanner 类Scanner 类： 一个可以解析基本类型和字符串的简单 文本扫描器 。例如，以下代码使用户能够从 System.in 中读取一个数： 12Scanner sc = new Scanner(System.in); // System.in 系统输入指的是通过键盘录入数据。int i = sc.nextInt(); // 把输入的数值赋值给变量 i 引用类型使用步骤第一步：导包 。使用 import 关键字导包，在类的所有代码之前导包。java.lang 包下的所有类无需导包就可使用 。格式和举例如下： 12345// 导包格式import 包名.类名;// 导包举例，导入 Scanner 类的包import java.util.Scanner; 第二步：创建对象。 使用该类的构造方法，创建一个该类的对象。格式和举例如下： 12345// 创建对象格式数据类型 变量名 = new 数据类型(参数列表);// 创建对象举例Scanner sc = new Scanner(System.in); 第三步： 调用方法。 调用该类的成员方法，完成指定功能。格式和举例如下： 12345// 调用方法格式变量名.方法名();// 调用方法举例int i = sc.nextInt(); // 接收一个键盘录入的整数 Scanner 练习： 使用 Scanner 类，完成接收键盘录入数据的操作 。代码如下： 1234567891011121314151617181920212223// 导包语句需放在类代码的上方，即在类的所有代码之前导包import java.util.Scanner;public class RandomTest { /** * 查看类 java.util.Scanner ：该类需要 import 导入后使用。 * 查看构造方法 public Scanner(InputStream source):构造一个新的 Scanner ，它生成的值是从指定的输入流扫描的。 * 查看成员方法 public int nextInt()：将输入信息的下一个标记扫描为一个值。 */ public static void main(String[] args) { // 1、创建键盘录入数据的对象 Scanner sc = new Scanner(System.in); // 2、接收数据 System.out.println(\"请录入一个整数：\"); int i = sc.nextInt(); // 3、输出数据 System.out.println(\"i = \" + i); }} 匿名对象匿名对象： 没有变量名的对象。创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用场景非常有限：作为方法的参数和作为返回值 。 创建匿名对象的格式以及举例如下： 12345// 创建匿名对象的格式new 类名(参数列表);// 创建匿名对象的举例new Scanner(System.in); 创建匿名对象直接调用方法，没有变量名。一旦调用两次方法 ，就是创建了两个对象，造成浪费。如以下代码： 12new Scanner(System.in).nextInt();new Scanner(System.in).nextInt(); 匿名对象 作为方法的参数 ，代码如下： 12345678910111213141516public class Test { public static void main(String[] args) { // 普通方式 Scanner sc = new Scanner(System.in); show(sc); // 匿名对象作为方法接收的参数 show(new Scanner(System.in)); } public static void show(Scanner sc) { System.out.println(sc); }} 匿名对象 作为返回值 ，代码如下： 1234567891011121314151617public class Test { public static void main(String[] args) { Scanner sc = getScanner(); System.out.println(sc); } public static Scanner getScanner() { // 普通方式// Scanner sc = new Scanner(System.in);// return sc; // 匿名对象作为方法返回值 return new Scanner(System.in); }} Random 类Random 类概述Random 类 的实例用于 生成伪随机数 ，该类需要 import 导包后才能使用。其 构造方法 public Random() 用于创建一个新的随机数生成器。常用 成员方法 public int nextInt(int n) 返回一个伪随机数，范围在0（包括）和指定 n （不包括）之间【左闭右开】 。现在使用 Random 类，完成 生成 20 个 100 以内的随机整数 的操作，代码如下： 1234567891011121314import java.util.Random;public class RandomTest { public static void main(String[] args) { Random r = new Random(); for (int i = 0; i &lt; 20; i++) { int number = r.nextInt(100); System.out.println(\"number: \" + number); } }} TIPS： 创建一个 Random 对象，每次调用 nextInt() 方法，都会生成一个随机数。 获取随机数获取 1~50 之间的随机数，包含 50 ，代码如下： 1234567891011import java.util.Random;public class RandomTest { public static void main(String[] args) { Random r = new Random(); int number = r.nextInt(50) + 1; System.out.println(\"number: \" + number); }} 猜数字小游戏游戏开始时，会随机生成一个 1~100 之间的整数 number 。玩家猜测一个数字 guestNumber ，会与 number 作比较，系统提示大了或者小了，直到玩家猜中，游戏结束。代码如下： 12345678910111213141516171819202122232425262728293031import java.util.Random;import java.util.Scanner;public class GuestNumber { public static void main(String[] args) { // 生产 1~100 的随机数 Random r = new Random(); int number = r.nextInt(100) + 1; while (true) { // 键盘录入我们要猜的数据 Scanner sc = new Scanner(System.in); System.out.println(\"请输入你要猜的数字(1~100)：\"); int guessNumber = sc.nextInt(); // 比较这两个数据(用 if 语句) if (guessNumber &gt; number) { System.out.println(\"你猜的数据\" + guessNumber + \"大了\"); } else if (guessNumber &lt; number) { System.out.println(\"你猜的数据\" + guessNumber + \"小了\"); } else { System.out.println(\"恭喜你,猜中了\"); break; } } }} ArrayList 类ArrayList 引入如何存储多个对象呢？例如 存储三个学生对象 。这个时候就要用到 ArrayList 类了。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.ArrayList;public class ArrayListTest { public static void main(String arg[]) { // 01-创建 ArrayList 对象 ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); // 02-创建学生对象 Student stu1 = new Student(\"洪七公\", 20); Student stu2 = new Student(\"欧阳锋\", 21); Student stu3 = new Student(\"黄药师\", 22); Student stu4 = new Student(\"段智兴\", 23); // 03-把学生对象加入到集合中，即存储学生对象 list.add(stu1); list.add(stu2); list.add(stu3); list.add(stu4); // 04-遍历集合，取出学生对象 for (int i = 0; i &lt; list.size(); i++) { Student stu = list.get(i); System.out.println(\"姓名：\" + stu.getName() + \" &lt;==&gt; 年龄：\" + stu.getAge()); } }}class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 什么是 ArrayList 类ArrayList 是一个集合，类似于数组，都属于容器。详情及特性参照如下注释，代码如下： 1234567891011121314151617181920212223242526272829303132import java.util.ArrayList;/** * 1、数组的长度不可以发生改变。但是 ArrayList 集合的长度是可以随意变化的。 * 2、对于 ArrayList 来说，有一个尖括号 &lt;E&gt; 代表泛型。 * 3、泛型：也就是装在集合当中的所有元素，全都是统一的类型。注意：泛型只能是引用类型，不能是基本类型。 * 4、注意事项： * 1、对于 ArrayList 集合来说，直接打印得到的不是地址值，而是内容。 * 2、如果内容是空，得到的是空的中括号：[] */public class ArrayListTest { public static void main(String[] args) { // 创建一个 ArrayList 集合，名字为 list，里面装的全都是 String 类型的数据。注意：从 JDK 1.7+ 开始，右侧的尖括号内部可以不写内容，但是 &lt;&gt; 本身还是要写的。 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); System.out.println(list); // [] // 向集合当中添加一些数据，需要用到 add 方法 list.add(\"赵丽颖\"); System.out.println(list); // [赵丽颖] list.add(\"迪丽热巴\"); list.add(\"古力娜扎\"); list.add(\"玛尔扎哈\"); System.out.println(list); // [赵丽颖, 迪丽热巴, 古力娜扎, 玛尔扎哈]// list.add(100); // 错误写法！因为创建的时候尖括号泛型已经说了是 String 类型，添加进去的元素就必须都是字符串才行 }} 常用方法和遍历常用的方法 都写在注释里面了，遍历请看代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.ArrayList;/** * ArrayList 当中的常用方法有： * 1、public boolean add(E e)：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。 * 注意事项：对于 ArrayList 集合来说，add 添加动作一定是成功的，所以返回值可用可不用。但是对于其他集合（今后学习）来说，add 添加动作不一定成功。 * 2、public E get(int index)：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。 * 3、public E remove(int index)：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。 * 4、public int size()：获取集合的尺寸长度，返回值是集合中包含的元素个数。 */public class ArrayListTest { public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); System.out.println(list); // [] // 01-向集合中添加元素，使用 add() 方法 boolean success = list.add(\"柳岩\"); System.out.println(list); // [柳岩] System.out.println(\"添加的动作是否成功：\" + success); // true list.add(\"高圆圆\"); list.add(\"赵又廷\"); list.add(\"李小璐\"); list.add(\"贾乃亮\"); System.out.println(list); // [柳岩, 高圆圆, 赵又廷, 李小璐, 贾乃亮] // 02-从集合中获取元素，使用 get() 方法，索引值从 0 开始 String name = list.get(2); System.out.println(\"第2号索引位置：\" + name); // 赵又廷 // 03-从集合中删除元素，使用 remove() 方法，索引值从 0 开始。 String whoRemoved = list.remove(3); System.out.println(\"被删除的人是：\" + whoRemoved); // 李小璐 System.out.println(list); // [柳岩, 高圆圆, 赵又廷, 贾乃亮] // 04-获取集合的长度尺寸，也就是其中元素的个数 int size = list.size(); System.out.println(\"集合的长度是：\" + size); }} 如何存储基本数据类型ArrayList 对象 不能存储基本类型，只能存储引用类型的数据 。类似 &lt;int&gt; 写法是错误的，但是存储 基本数据类型对应的包装类型 是可以的。所以，想要存储基本类型数据，&lt; &gt; 中的数据类型，必须转换后才能编写，转换写法如下： 12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;/** * 如果希望向集合 ArrayList 当中存储基本类型数据，必须使用基本类型对应的“包装类”。 * * 基本类型 包装类（引用类型，包装类都位于 java.lang 包下） * byte Byte * short Short * int Integer 【特殊】 * long Long * float Float * double Double * char Character 【特殊】 * boolean Boolean * * 从 JDK 1.5+ 开始，支持自动装箱、自动拆箱。 * 自动装箱：基本类型 --&gt; 包装类型 * 自动拆箱：包装类型 --&gt; 基本类型 */public class ArrayListTest { public static void main(String[] args) { // 错误写法！泛型只能是引用类型，不能是基本类型// ArrayList&lt;int&gt; list = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(100); list.add(200); System.out.println(list); // [100, 200] int num = list.get(1); System.out.println(\"第1号元素是：\" + num); }} ArrayList 练习数值添加到集合生成 6 个 1~33 之间的随机整数 ，然后添加到集合并遍历集合。思路分析及代码如下： 1234567891011121314151617181920212223242526272829303132import java.util.ArrayList;import java.util.Random;/** * 思路分析： * 1、需要存储 6 个数字，创建一个集合，&lt;Integer&gt; * 2、产生随机数，需要用到 Random * 3、用循环 6 次，来产生 6 个随机数字：for 循环 * 4、循环内调用 nextInt(int n) 方法，参数是 33，0~32，整体 +1 才是 1~33 * 5、把数字添加到集合中：add * 6、遍历集合：for、size、get */public class RandomTest { public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Random random = new Random(); for (int i = 0; i &lt; 6; i++) { int num = random.nextInt(33) + 1; list.add(num); } // 遍历集合 for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); } }} 对象添加到集合自定义 4 个学生对象，添加到集合并遍历。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.ArrayList;public class ArrayListTest { public static void main(String arg[]) { // 01-创建 ArrayList 对象 ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); // 02-创建学生对象 Student stu1 = new Student(\"洪七公\", 20); Student stu2 = new Student(\"欧阳锋\", 21); Student stu3 = new Student(\"黄药师\", 22); Student stu4 = new Student(\"段智兴\", 23); // 03-把学生对象加入到集合中，即存储学生对象 list.add(stu1); list.add(stu2); list.add(stu3); list.add(stu4); // 04-遍历集合，取出学生对象 for (int i = 0; i &lt; list.size(); i++) { Student stu = list.get(i); System.out.println(\"姓名：\" + stu.getName() + \" &lt;==&gt; 年龄：\" + stu.getAge()); } }}class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 打印集合方法定义以指定格式打印集合的方法（ArrayList 类型作为参数） ，使用 {} 把集合元素括起来，使用 @ 符号 分隔集合里面每个元素。格式参照：{元素@元素@元素} 。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;public class RandomTest { public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"张三丰\"); list.add(\"宋远桥\"); list.add(\"张无忌\"); list.add(\"张翠山\"); System.out.println(list); // [张三丰, 宋远桥, 张无忌, 张翠山] printArrayList(list); // {张三丰@宋远桥@张无忌@张翠山} } /** * 定义方法的三要素： * 返回值类型：只是进行打印而已，没有运算，没有结果；所以用 void * 方法名称：printArrayList * 参数列表：ArrayList */ public static void printArrayList(ArrayList&lt;String&gt; list) { System.out.print(\"{\"); for (int i = 0; i &lt; list.size(); i++) { String name = list.get(i); if (i == list.size() - 1) { System.out.println(name + \"}\"); } else { System.out.print(name + \"@\"); } } }} 获取集合方法用一个 大集合存入 20 个随机数字 ，然后 筛选其中的偶数元素 ，放到小集合当中。要求： 使用自定义的方法来实现筛选。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.ArrayList;import java.util.Random;/** * 思路分析： * 1、需要创建一个大集合，用来存储 int 数字：&lt;Integer&gt; * 2、随机数字就用 Random nextInt * 3、循环 20 次，把随机数字放入大集合：for 循环、add 方法 * 4、定义一个方法，用来进行筛选。筛选：根据大集合，筛选符合要求的元素，得到小集合。 * 方法三要素： * 1、返回值类型：ArrayList 小集合（里面元素个数不确定） * 2、方法名称：getSmallList * 3、参数列表：ArrayList 大集合（装着 20 个随机数字） * 5. 判断（if）是偶数：num % 2 == 0 * 6. 如果是偶数，就放到小集合当中，否则不放。 */public class RandomTest { public static void main(String[] args) { ArrayList&lt;Integer&gt; bigList = new ArrayList&lt;&gt;(); Random random = new Random(); for (int i = 0; i &lt; 20; i++) { int num = random.nextInt(100) + 1; // 1~100 bigList.add(num); } ArrayList&lt;Integer&gt; smallList = getSmallList(bigList); System.out.println(\"偶数总共有多少个：\" + smallList.size()); for (int i = 0; i &lt; smallList.size(); i++) { System.out.println(smallList.get(i)); } } // 这个方法，接收大集合参数，返回小集合结果 public static ArrayList&lt;Integer&gt; getSmallList(ArrayList&lt;Integer&gt; bigList) { // 创建一个小集合，用来装偶数结果 ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; bigList.size(); i++) { int num = bigList.get(i); if (num % 2 == 0) { smallList.add(num); } } return smallList; }} String 类String 类的概述String 类 代表字符串，位于 java.lang 包下 。Java 程序中所有的字符串文字（例如 “abc”）都可以被看作是实现此类的实例。String 类中包括用于检查各个字符串的方法，比如用于 比较字符串，搜索字符串，提取子字符串以及创建具有翻译为大写或小写的所有字符的字符串 的各种方法。 String 类的特点第一个特点： 字符串不变。字符串的值在创建后不能被更改。代码如下： 12345String str = \"abc\";str += \"d\";System.out.println(str); // abcd// 内存中有 \"abc\"，\"abcd\" 两个对象，str 原先指向 \"abc\"，后改变指向，指向了 \"abcd\" 。 第二个特点： 共享 。因为 String 对象是不可变的，所以它们可以被共享。代码如下： 123String s1 = \"abc\";String s2 = \"abc\";// 内存中只有一个 \"abc\" 对象被创建，同时被 s1 和 s2 共享。 第三个特点： 与字符数组等效 。”abc” 等效于 char[] arr = {‘a’,’b’,’c’} 。代码如下： 123456789String str1 = \"abc\";// 相当于下面的 data[] 数组，这段代码 String 源码注释里有写char data[] = {'a', 'b', 'c'};String str2 = new String(data);System.out.println(str1.equals(str2)); // trueSystem.out.println(str1 == (str2)); // false// String 底层是靠字符数组实现的。 String 类的使用和常量池String 类的特点及创建方式都写于注释之中 ，这里就不过多介绍。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839/** * java.lang.String 类代表字符串。 * API当中说：Java 程序中的所有字符串字面值（如 \"abc\" ）都作为此类的实例实现。 * 其实就是说：程序当中所有的双引号字符串，都是 String 类的对象。（就算没有 new，也照样是） * * 字符串的特点： * 1、字符串的内容永不可变。【重点】 * 2、正是因为字符串不可改变，所以字符串是可以共享使用的。 * 3、字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。 * * 创建字符串的常见 3+1 种方式。三种构造方法： * public String()：创建一个空白字符串，不含有任何内容。 * public String(char[] array)：根据字符数组的内容，来创建对应的字符串。 * public String(byte[] array)：根据字节数组的内容，来创建对应的字符串。 * 一种直接创建：String str = \"Hello\"; 注意：直接写上双引号，就是字符串对象。 */public class StringTest { public static void main(String[] args) { // 使用空参构造 String str1 = new String(); // 小括号留空，说明字符串什么内容都没有。 System.out.println(\"第1个字符串：\" + str1); // 根据字符数组创建字符串 char[] charArray = {'A', 'B', 'C'}; String str2 = new String(charArray); System.out.println(\"第2个字符串：\" + str2); // 根据字节数组创建字符串 byte[] byteArray = {97, 98, 99}; String str3 = new String(byteArray); System.out.println(\"第3个字符串：\" + str3); // 直接创建 String str4 = \"Hello\"; System.out.println(\"第4个字符串：\" + str4); }} String 类常量池的介绍及使用都写于注释之中 ，这里就不过多介绍。代码如下： 1234567891011121314151617181920/** * 1、字符串常量池：在程序当中，直接写上双引号的字符串，就在字符串常量池中。 * 2、对于基本类型来说，== 是进行数值的比较。 * 3、对于引用类型来说，== 是进行【地址值】的比较。 */public class StringTest { public static void main(String[] args) { String str1 = \"abc\"; String str2 = \"abc\"; char[] charArray = {'a', 'b', 'c'}; String str3 = new String(charArray); System.out.println(str1 == str2); // true System.out.println(str1 == str3); // false System.out.println(str2 == str3); // false }} 常用方法内容比较功能String 类内容比较功能的介绍及使用都写于注释之中 ，这里就不过多介绍。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * == 是进行对象的地址值比较，如果确实需要字符串的内容比较，可以使用两个方法： * public boolean equals(Object obj)：参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true；否则返回false。 * 注意事项： * 1、任何对象都能用 Object 进行接收。 * 2、equals 方法具有对称性，也就是 a.equals(b) 和 b.equals(a) 效果一样。 * 3、如果比较双方一个常量一个变量，推荐把常量字符串写在前面。推荐：\"abc\".equals(str) 不推荐：str.equals(\"abc\") * public boolean equalsIgnoreCase(String str)：忽略大小写，进行内容比较。 */public class StringTest { public static void main(String[] args) { String str1 = \"Hello\"; String str2 = \"Hello\"; char[] charArray = {'H', 'e', 'l', 'l', 'o'}; String str3 = new String(charArray); System.out.println(str1.equals(str2)); // true System.out.println(str2.equals(str3)); // true System.out.println(str3.equals(\"Hello\")); // true System.out.println(\"Hello\".equals(str1)); // true String str4 = \"hello\"; System.out.println(str1.equals(str4)); // false System.out.println(\"=================\"); String str5 = null; System.out.println(\"abc\".equals(str5)); // false// System.out.println(str5.equals(\"abc\")); // 报错，空指针异常 NullPointerException System.out.println(\"=================\"); String strA = \"Java\"; String strB = \"java\"; System.out.println(strA.equals(strB)); // false，严格区分大小写 System.out.println(strA.equalsIgnoreCase(strB)); // true，忽略大小写 // 注意，只有英文字母区分大小写，其他都不区分大小写 System.out.println(\"abc一123\".equalsIgnoreCase(\"abc壹123\")); // false }} 获取功能String 类获取功能的介绍及使用都写于注释之中 ，这里就不过多介绍。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * String 当中与获取相关的常用方法有： * * public int length()：获取字符串当中含有的字符个数，拿到字符串长度。 * public String concat(String str)：将当前字符串和参数字符串拼接成为返回值新的字符串。 * public char charAt(int index)：获取指定索引位置的单个字符。（索引从 0 开始。） * public int indexOf(String str)：查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回 -1 值。 */public class StringTest { public static void main(String[] args) { // 获取字符串的长度 int length = \"asdasfeutrvauevbueyvb\".length(); System.out.println(\"字符串的长度是：\" + length); // 拼接字符串 String str1 = \"Hello\"; String str2 = \"World\"; String str3 = str1.concat(str2); System.out.println(str1); // Hello，原封不动 System.out.println(str2); // World，原封不动 System.out.println(str3); // HelloWorld，新的字符串 System.out.println(\"==============\"); // 获取指定索引位置的单个字符 char ch = \"Hello\".charAt(1); System.out.println(\"在 1 号索引位置的字符是：\" + ch); System.out.println(\"==============\"); // 查找参数字符串在本来字符串当中出现的第一次索引位置。如果没有，返回 -1 值 String original = \"HelloWorldHelloWorld\"; int index = original.indexOf(\"llo\"); System.out.println(\"第一次索引值是：\" + index); // 2 System.out.println(\"HelloWorld\".indexOf(\"abc\")); // -1 // 字符串匹配算法，以后有 “暴力匹配” 和 “KMP 算法” ，当前 matchString 是我自己写的 matchString(\"HelloWorldHelloWorld\",\"llo\"); } public static int matchString(String str1, String str2) { int i = str1.indexOf(str2); if(!(i == -1)){ System.out.println(\"match is succeed , the location is : \" + i); return i; } else { System.out.println(\"the match is failure\"); return -1; } }} 截取功能String 类截取功能的介绍及使用都写于注释之中 ，这里就不过多介绍。代码如下： 12345678910111213141516171819202122232425262728293031/** * 字符串的截取方法： * public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串。 * public String substring(int begin, int end)：截取从 begin 开始，一直到 end 结束，中间的字符串。 * 备注：[begin,end)，包含左边，不包含右边。 */public class StringTest { public static void main(String[] args) { String str1 = \"HelloWorld\"; String str2 = str1.substring(5); System.out.println(str1); // HelloWorld，原封不动 System.out.println(str2); // World，新字符串 System.out.println(\"================\"); String str3 = str1.substring(4, 7); System.out.println(str3); // oWo System.out.println(\"================\"); // 下面这种写法，字符串的内容仍然是没有改变的 // 下面有两个字符串：\"Hello\"，\"Java\" 。str 保存的是地址值。 // 假设 Hello 的地址值是 0x666 ，Java 的地址值是 0x999 。一开始 str 指向 0x666 ，后来指向了 0x999 String str = \"Hello\"; System.out.println(str); // Hello str = \"Java\"; System.out.println(str); // Java }} 转换功能String 类转换功能的介绍及使用都写于注释之中 ，这里就不过多介绍。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * String 当中与转换相关的常用方法有： * * public char[] toCharArray()：将当前字符串拆分成为字符数组作为返回值。 * public byte[] getBytes()：获得当前字符串底层的字节数组。 * public String replace(CharSequence oldString, CharSequence newString)： * 将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。 * 备注：CharSequence 意思就是说可以接受字符串类型。 */public class StringTest { public static void main(String[] args) { // 转换成为字符数组 char[] chars = \"Hello\".toCharArray(); System.out.println(chars[0]); // H System.out.println(chars.length); // 5 System.out.println(\"==============\"); // 转换成为字节数组 byte[] bytes = \"abc\".getBytes(); for (int i = 0; i &lt; bytes.length; i++) { System.out.println(bytes[i]); } System.out.println(\"==============\"); // 字符串的内容替换 String str1 = \"How do you do?\"; String str2 = str1.replace(\"o\", \"*\"); System.out.println(str1); // How do you do? System.out.println(str2); // H*w d* y*u d*? System.out.println(\"==============\"); String lang1 = \"会不会玩儿呀！你大爷的！你大爷的！你大爷的！！！\"; String lang2 = lang1.replace(\"大爷\", \"**\"); System.out.println(lang2); // 会不会玩儿呀！你**的！你**的！你**的！！！ }} 分割功能String 类分割功能的介绍及使用都写于注释之中 ，这里就不过多介绍。代码如下： 12345678910111213141516171819202122232425262728293031323334353637/** * 分割字符串的方法：public String[] split(String regex)：按照参数的规则，将字符串切分成为若干部分。 * 注意事项： * 1、split 方法的参数其实是一个 “正则表达式” ，今后学习。 * 2、如果按照英文句点 “.” 进行切分，必须写 \"\\\\.\" （两个反斜杠） */public class StringTest { public static void main(String[] args) { String str1 = \"aaa,bbb,ccc\"; String[] array1 = str1.split(\",\"); for (int i = 0; i &lt; array1.length; i++) { System.out.println(array1[i]); } System.out.println(\"===============\"); String str2 = \"aaa bbb ccc\"; String[] array2 = str2.split(\" \"); for (int i = 0; i &lt; array2.length; i++) { System.out.println(array2[i]); } System.out.println(\"===============\"); String str3 = \"XXX.YYY.ZZZ\"; String[] array3 = str3.split(\"\\\\.\"); System.out.println(array3.length); for (int i = 0; i &lt; array3.length; i++) { System.out.println(array3[i]); } }} String 类练习拼接字符串拼接字符串的介绍和思路分析都写于注释之中 ，这里就不过多介绍。代码如下： 123456789101112131415161718192021222324252627282930313233343536/** * 1、拼接字符串介绍：定义一个方法，把数组{1,2,3}按照指定格式拼接成一个字符串。格式参照如下：[word1#word2#word3]。 * 2、思路分析： * 1、首先准备一个int[]数组，内容是：1、2、3 * 2、定义一个方法，用来将数组变成字符串 * 3、方法三要素： 返回值类型：String 方法名称：fromArrayToString 参数列表：int[] * 4、用到 for 循环、字符串拼接、每个数组元素之前都有一个 word 字样、分隔使用的是 # 、区分一下是不是最后一个 * 5、调用方法，得到返回值，并打印结果字符串 */public class StringTest { public static void main(String[] args) { int[] array = {1, 2, 3, 4}; String result = fromArrayToString(array); System.out.println(result); } public static String fromArrayToString(int[] array) { String str = \"[\"; for (int i = 0; i &lt; array.length; i++) { if (i == array.length - 1) { str += \"word\" + array[i] + \"]\"; } else { str += \"word\" + array[i] + \"#\"; } } return str; }} 统计字符个数统计字符个数的介绍和思路分析都写于注释之中 ，这里就不过多介绍。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Scanner;/** * 1、统计字符个数介绍：键盘输入一个字符串，并且统计其中各种字符出现的次数。字符种类有：大写字母、小写字母、数字、其他 * 2、思路思路： * 1、既然用到键盘输入，肯定是 Scanner * 2、键盘输入的是字符串，那么：String str = sc.next(); * 3、定义四个变量，分别代表四种字符各自的出现次数。 * 4、需要对字符串一个字、一个字检查，String--&gt;char[]，方法就是 toCharArray() * 5、遍历 char[] 字符数组，对当前字符的种类进行判断，并且用四个变量进行 ++ 动作。 * 6、打印输出四个变量，分别代表四种字符出现次数。 */public class StringTest { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"请输入一个字符串：\"); String str = sc.next(); // 获取键盘输入的一个字符串 int countUpper = 0; // 大写字母 int countLower = 0; // 小写字母 int countNumber = 0; // 数字0~9 int countOther = 0; // 其他字符 char[] charArray = str.toCharArray(); for (int i = 0; i &lt; charArray.length; i++) { char ch = charArray[i]; // 当前单个字符 if ('A' &lt;= ch &amp;&amp; ch &lt;= 'Z') { countUpper++; } else if ('a' &lt;= ch &amp;&amp; ch &lt;= 'z') { countLower++; } else if ('0' &lt;= ch &amp;&amp; ch &lt;= '9') { countNumber++; } else { countOther++; } } System.out.println(\"大写字母有：\" + countUpper); System.out.println(\"小写字母有：\" + countLower); System.out.println(\"数字0~9有：\" + countNumber); System.out.println(\"其他字符有：\" + countOther); }} static 关键字static 概述static 关键字： 它可以用来修饰 成员变量 和 成员方法 ，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 static 特殊用法： 用 static 修饰内部类，普通类是不允许声明为静态的，只有内部类才可以 。被 static 修饰的内部类可以直接作为一个普通类来使用，而不需实例一个外部类。代码如下： 12345678910111213141516public class StaticTest { public static void main(String[] args) { // 直接使用，不需要创建一个外部类实例 new OuterClass.InnerClass(); }}class OuterClass { public static class InnerClass { InnerClass() { System.out.println(\"===== 我是一个内部类 InnerClass =====\"); } }} 注意啦！！！ 当一个内部类没有使用 static 修饰的时候，是不能直接使用内部类创建对象，必须要 外部类对象.new 内部类 。举例： new Outer().new Inner(); 定义和使用格式123456+++ 类变量概念当 static 修饰成员变量时，该变量称为 +类变量+ 。该类的每个对象都共享同一个类变量的值。任何对象都可以更改该 +类变量+ 的值，但也可以在不创建该类的对象的情况下对类变量进行操作。+++ 类变量定义格式static 数据类型 变量名; static 关键字 的相关代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * 如果一个成员变量使用了 static 关键字，那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享同一份数据。 */public class StaticTest { public static void main(String[] args) { Student two = new Student(\"黄蓉\", 16); two.room = \"101教室\"; System.out.println(\"姓名：\" + two.getName() + \"，年龄：\" + two.getAge() + \"，教室：\" + two.room + \"，学号：\" + two.getId()); Student one = new Student(\"郭靖\", 19); System.out.println(\"姓名：\" + one.getName() + \"，年龄：\" + one.getAge() + \"，教室：\" + one.room + \"，学号：\" + one.getId()); }}class Student { public static String room; private String name; private int age; private int id; public int getId() { return id; } public void setId(int id) { this.id = id; } public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 静态方法当 static 修饰成员方法时， 该方法称为 类方法 。静态方法在声明中有 static ，建议使用类名来调用，而不需要创建类的对象。 123456789101112+++ 静态方法的定义格式修饰符 static 返回值类型 方法名(参数列表) { // 执行语句}+++ 静态方法调用的注意事项+ 静态方法可以直接访问类变量和静态方法+ 静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法+ 静态方法中，不能使用 this 关键字+ 静态方法只能访问静态成员+++ 结束！！！ 1234567891011+++ 静态方法的调用格式被 static 修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，但是不建议这么做。原因是多个对象均属于一个类，共享同一个静态成员，从而会出现警告信息。+++ 访问类变量类名.类变量名;+++ 调用静态方法类名.静态方法名(参数);+++ 结束！！！ 静态方法的调用演示，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 1、一旦使用 static 修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。 * 2、如果没有 static 关键字，那么必须首先创建对象，然后通过对象才能使用它。 * 3、如果有了 static 关键字，那么不需要创建对象，直接就能通过类名称来使用它。 * 4、无论是成员变量，还是成员方法。如果有了 static，都推荐使用类名称进行调用。 * 1、静态变量：类名称.静态变量 * 2、静态方法：类名称.静态方法() * 5、注意事项： * 1、静态不能直接访问非静态。原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容。“先人不知道后人，但是后人知道先人。” * 2、静态方法当中不能用 this 。原因：this 代表当前对象，通过谁调用的方法，谁就是当前对象。 */public class StaticMethodTest { public static void main(String[] args) { // 1、首先创建对象，然后才能使用没有 static 关键字的内容 MyClass obj = new MyClass(); obj.method(); // 2、对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。 obj.methodStatic(); // 正确，不推荐，这种写法在编译之后也会被 javac 翻译成为“类名称.静态方法名” MyClass.methodStatic(); // 正确，推荐 // 3、对于本类当中的静态方法，可以省略类名称 myMethod(); StaticMethodTest.myMethod(); // 完全等效 } public static void myMethod() { System.out.println(\"自己的方法！\"); }}class MyClass { public void method() { System.out.println(\"我是没有 static 修饰的方法\"); } static void methodStatic() { System.out.println(\"我是有 static 修饰的方法\"); }} 静态原理图解1234567+++ 被 static 修饰的内容的特点+ 随着类的加载而加载的，且只加载一次。+ 存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。+ 它优先于对象存在，所以，可以被所有对象共享。+++ 被 static 修饰的内容的特点 static 的原理图解如下： 静态代码块静态代码块： 执行优先级高于非静态的初始化块，它会在类初始化的时候执行一次，执行完成便销毁 。它仅能初始化类变量，即 static 修饰的数据成员。其他介绍请参阅下方代码： 12345678910111213141516171819202122232425262728293031323334/** * 1、静态代码块的格式： * public class 类名称 { * static { * // 静态代码块的内容 * } * } * * 2、静态代码块的特点：当第一次用到本类时，静态代码块执行唯一的一次。 * 3、静态内容总是优先于非静态，所以静态代码块比构造方法先执行。 * 4、静态代码块的典型用途：用来一次性地对静态成员变量进行赋值。 */public class StaticBlock { public static void main(String[] args) { Person one = new Person(); Person two = new Person(); }}class Person { // 静态代码块只会执行一次 static { System.out.println(\"静态代码块执行！\"); } public Person() { System.out.println(\"构造方法执行！\"); }} 温馨小提示： 静态代码块的执行顺序：静态代码块—–&gt;非静态代码块——–&gt;构造函数 Arrays 类Arrays 概述java.util.Arrays 类 是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。 Arrays 类 中的 常用方法 以及方法的使用都写在代码的注释里了，请参阅如下代码 ： 123456789101112131415161718192021222324252627282930import java.util.Arrays;/** * java.util.Arrays 是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。 * * public static String toString(数组)：将参数数组变成字符串（按照默认格式：[元素1, 元素2, 元素3...]） * public static void sort(数组)：按照默认升序（从小到大）对数组的元素进行排序。 * * 注意事项： * 1、如果是数值，sort 默认按照升序从小到大 * 2、如果是字符串，sort 默认按照字母升序 * 3、如果是自定义的类型，那么这个自定义的类需要有 Comparable 或者 Comparator 接口的支持。（今后学习） */public class ArraysMethods { public static void main(String[] args) { int[] arr = {10, 20, 30}; String str = Arrays.toString(arr); // 将 int[] 数组按照默认格式变成字符串 System.out.println(str); // [10, 20, 30] int[] array = {2, 1, 3, 10, 6}; Arrays.sort(array); // 对 int[] 数组进行排序 System.out.println(Arrays.toString(array)); // [1, 2, 3, 6, 10] String[] strArr = {\"bbb\", \"aaa\", \"ccc\"}; Arrays.sort(strArr); // 对 String[] 数组进行排序 System.out.println(Arrays.toString(strArr)); // [aaa, bbb, ccc] }} Arrays 练习请使用 Arrays 相关的 API ，将一个随机字符串中的所有字符升序排列，并倒序打印。 代码如下： 1234567891011121314151617181920212223import java.util.Arrays;public class ArraysPractise { public static void main(String[] args) { /** * 思路分析： * 1、如何进行升序排列：sort 方法 * 2、必须是一个数组，才能用 Arrays.sort 方法。所以需要把 String 转化成数组 * 3、转化：String --&gt; 数组，用 toCharArray 方法 */ String str = \"asv76agfqwdfvasdfvjh\"; char[] chars = str.toCharArray(); Arrays.sort(chars); // 对字符数组进行升序排列 // 倒序遍历 for (int i = chars.length - 1; i &gt;= 0; i--) { System.out.print(chars[i]); } }} Math 类Math 类概述java.util.Math 类 是一个很有用的数学帮助类，该类包含用于执行基本数学运算的方法，如 初等指数、对数、平方根和三角函数 。其使用也非常简单，但是这个类又比较特殊。首先它和 String 类一样都是用 final 修饰，所以不能有子类。还有就是它的构造方法是私有的，也就是我们不能通过 new 的方法在其它类中构造 Math 对象。 那么我们怎样调用它的方法呢？原来它的所有的方法都是静态方法，也就是可以直接使用类名就可以访问方法了。 Math 类 中的 常用方法 以及方法的使用都写在代码的注释里了，请参阅如下代码 ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * java.util.Math 类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。 * * public static double abs(double num)：获取绝对值。有多种重载。 * public static double ceil(double num)：向上取整。 * public static double floor(double num)：向下取整。 * public static long round(double num)：四舍五入。 * * Math.PI 代表近似的圆周率常量（double）。 */public static void main(String[] args) { // public static double abs(double num)：获取绝对值。有多种重载。 System.out.println(\"绝对值：\" + Math.abs( -235.345)); System.out.println(\"绝对值：\" + Math.abs(235.345)); // public static double ceil(double num)：向上取整。 System.out.println(\"---------------\"); System.out.println(\"向上取整：\" + Math.ceil(545.001)); System.out.println(\"向上取整：\" + Math.ceil(545.999)); // public static double floor(double num)：向下取整。 System.out.println(\"---------------\"); System.out.println(\"向下取整：\" +Math.floor(545.001)); System.out.println(\"向下取整：\" +Math.floor(545.999)); // public static long round(double num)：四舍五入。 System.out.println(\"---------------\"); System.out.println(\"四舍五入：\" +Math.round(545.499)); System.out.println(\"四舍五入：\" +Math.round(545.500)); System.out.println(\"四舍五入：\" +Math.round(-54.499)); System.out.println(\"四舍五入：\" +Math.round(-54.501)); System.out.println(\"四舍五入：\" +Math.round(-1.5)); System.out.println(\"四舍五入：\" +Math.round(-1.51)); // Math.PI 代表近似的圆周率常量（double），Math.E 代表自然常数（double）。 System.out.println(\"---------------\"); System.out.println(\"圆周率：\" + Math.PI); System.out.println(\"自然常数：\" + Math.E); // public static double pow(double a, double b)：返回 a 的 b 次幂的值,即 a^b System.out.println(\"---------------\"); System.out.println(\"2的10次方：\" + Math.pow(2,10)); // 余弦函数 正弦函数 正切函数 System.out.println(\"---------------\"); double degree = 45.0; // 角度为 45 度 double radians = Math.toRadians(degree); // 把 45 度转化为弧度 System.out.println(Math.cos(radians)); // cos45 System.out.println(Math.sin(radians)); // sin45 System.out.println(Math.tan(radians)); // tan45 // 开平方 开立方 System.out.println(\"---------------\"); System.out.println(\"4的平方根：\" + Math.sqrt(4)); System.out.println(\"27的立方根：\" + Math.cbrt(27)); // 随机数 public static double random()：返回带正号的 double 值，大于或等于 0.0，小于 1.0。 // 返回一个 1 ~ 100 的整数 【1-100】 System.out.println(\"生成一个1~100的随机数：\" + (int)(Math.random() * 100 + 1)); // 返回一个 0 ~ 100 的整数 【0-100】 System.out.println(\"生成一个0~100的随机数：\" + (int)(Math.random() * 101));} Math 练习计算在 -10.8 到 5.9 之间，绝对值大于 6 或者小于 2.1 的整数有多少个？ 思路分析及代码如下： 123456789101112131415161718192021222324252627282930/** * 思路分析： * 1、既然已经确定了范围，for 循环 * 2、起点位置 -10.8 应该转换成为 -10 ，两种办法： * 1、可以使用 Math.ceil 方法，向上（向正方向）取整 * 2、强转成为 int ，自动舍弃所有小数位 * 3、每一个数字都是整数，所以步进表达式应该是 num++，这样每次都是 +1 的。 * 4、如何拿到绝对值：Math.abs 方法。 * 5、一旦发现了一个数字，需要让计数器 ++ 进行统计。 * * 备注：如果使用 Math.ceil 方法，-10.8 可以变成 -10.0 。注意 double 也是可以进行 ++ 操作的。 */public static void main(String[] args) { int count = 0; // 符合要求的数量 double min = -10.8; double max = 5.9; // 这样处理，变量 i 就是区间之内所有的整数 for (int i = (int) min; i &lt; max; i++) { int abs = Math.abs(i); // 绝对值 if (abs &gt; 6 || abs &lt; 2.1) { System.out.println(i); count++; } } System.out.println(\"总共有：\" + count); // 9 } 继承继承初识继承 是 java 面向对象编程技术的一块基石，因为它允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法。 或者子类从父类继承方法，使得子类具有父类相同的行为。 继承的由来当多个类中存在相同属性和行为时，将这些相同的内容抽取到一个单独的类中 ，那么多个类无需再定义这些属性和行为，只要继承这一个类即可。其中，多个类可以称为 子类 ，单独那一个类称为 父类、超类（superclass）或者基类 。如图所示： 继承描述的是事物之间的所属关系，这种关系是：is-a 的关系。例如，图中兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。 继承的定义、好处与格式123456789101112131415161718+++ 继承的定义继承就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的\"非私有\"的属性和行为。+++ 继承的好处+ 提高代码的复用性。+ 类与类之间产生了关系，是多态的前提。+++ 继承的格式通过 extends 关键字，可以声明一个子类继承另外一个父类，定义格式如下：+ class 父类 {+ ...+ }+ + class 子类 extends 父类 {+ ...+ }+++ 结束！！！ 继承示例通过上述介绍，我们编写相关代码来实现继承操作。代码如下： 123456789101112131415161718192021222324252627282930// 01-定义 Animal 父类class Animal { public String name; public double weight; public void eat() { System.out.println(\"我要吃饭了！\"); }}// 02-定义子类 Lion 继承父类class Lion extends Animal { // 里面什么内容都不写，由于继承了父类 Animal ，所以 Lion 类拥有了父类的属性和方法}// 03-定义 ExtendsTest 测试类public class ExtendsTest { public static void main(String[] args) { Lion lion = new Lion(); String name = lion.name = \"狮子\"; double weight = lion.weight = 500; System.out.println(\"我是\" + name + \"，我的体重是 \" + weight); lion.eat(); }} 继承后的各种特点当类之间产生了关系后，其中各类中的成员变量与成员方法等等，又产生了哪些影响呢？ 成员变量不重名如果子类父类中出现不重名的成员变量，这时的访问是没有影响的。代码如下： 12345678910111213141516171819202122232425262728293031323334class Fu { // Fu 中的成员变量 int numFu = 5;}class Zi extends Fu { // Zi 中的成员变量 int numZi = 10; // Zi 中的成员方法 public void show(){ // 访问父类的成员变量 System.out.println(\"numFu = \" + numFu); // 继承而来，可以直接访问 // 访问子类自身的成员变量 System.out.println(\"numZi = \" + numZi); }}public class ExtendsTest { public static void main(String[] args) { Zi zi = new Zi(); // 创建子类对象 zi.show(); // 调用子类中的 show() 方法 }}// 演示结果：// numFu = 5// numZi = 10 成员变量重名如果子类父类中出现重名的成员变量，这时的访问是有影响的。子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量 ，super 类似于之前学过的 this 关键字。对应代码如下： 12345678910111213141516171819202122232425262728293031323334353637class Fu { int num = 10;}class Zi extends Fu { int num = 20; public void method() { int num = 30; System.out.println(num); // 30，局部变量 System.out.println(this.num); // 20，本类的成员变量 System.out.println(super.num); // 10，父类的成员变量 }}/** * 局部变量： 直接写成员变量名 * 本类的成员变量： this.成员变量名 * 父类的成员变量： super.成员变量名 */public class ExtendsTest { public static void main(String[] args) { Zi zi = new Zi(); zi.method(); }}// 演示结果：// 30// 20// 10 小提示： 父类中的成员变量是非私有的，子类中可以直接访问。若父类中的成员变量私有了，子类是不能直接访问的 。通常编码时，我们遵循封装的原则，使用 private 修饰成员变量 ，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的 getXxx 方法和 setXxx 方法。 成员方法不重名如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。 代码如下： 123456789101112131415161718192021222324252627class Fu { public void showFu(){ System.out.println(\"Fu 类方法执行！\"); }}class Zi extends Fu { public void showZi(){ System.out.println(\"Zi 类方法执行！\"); }}public class ExtendsTest { public static void main(String[] args) { Zi zi = new Zi(); //子类中没有 showFu() 方法，但是可以找到父类方法去执行 zi.showFu(); zi.showZi(); }} 成员方法重名如果子类和父类中出现重名的成员方法 ，这时的访问是一种特殊情况，叫做 方法重写(Override) ，即子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为 重写或者复写【声明不变，重新实现】 。参考代码如下： 1234567891011121314151617181920212223242526272829303132class Fu { public String method() { return null; }}class Zi extends Fu { @Override public String method() { return \"The method has been Overridden!!!\"; }}/** * 方法覆盖重写的注意事项： * 1、必须保证父子类之间方法的名称相同，参数列表也相同。 * 2、注解 @Override 写在方法前面，用来检测是不是有效的正确覆盖重写。这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。 * 3、子类方法的返回值必须【小于等于】父类方法的返回值范围。 * * 小扩展提示：java.lang.Object 类是所有类的公共最高父类（祖宗类），java.lang.String 就是 Object 的子类。 * * 4、子类方法的权限必须【大于等于】父类方法的权限修饰符。 * * 小扩展提示：public &gt; protected &gt; (default) &gt; private * 备注：(default)不是关键字 default ，而是什么都不写，留空。 */public class OverrideTest {} 重写的应用子类可以根据需要，定义特定于自己的行为。 既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。比如新的手机增加来电显示头像的功能，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 老款手机class Phone { public void call() { System.out.println(\"打电话\"); } public void send() { System.out.println(\"发短信\"); } public void show() { System.out.println(\"显示号码\"); }}// 定义一个新手机，使用老手机作为父类class NewPhone extends Phone { @Override public void show() { // 把父类的show方法拿过来重复利用 super.show(); // 自己子类再来添加更多内容 System.out.println(\"显示姓名\"); System.out.println(\"显示头像\"); }}// 定义一个测试类public class PhoneTest { public static void main(String[] args) { Phone phone = new Phone(); phone.call(); phone.send(); phone.show(); System.out.println(\"==========\"); NewPhone newPhone = new NewPhone(); newPhone.call(); newPhone.send(); newPhone.show(); }} 注意事项： 1、子类方法覆盖父类方法，必须要保证权限大于等于父类权限。2、子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。 构造方法构造方法的继承可通给 super 关键字来调用。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940/** * 继承关系中，父子类构造方法的访问特点： * 1、子类构造方法当中有一个默认隐含的 “super()” 调用，所以一定是先调用的父类构造，后执行的子类构造。 * 2、子类构造可以通过 super 关键字来调用父类重载构造。 * 3、super 的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次 super 构造。 * 4、总结：子类必须调用父类构造方法，不写则赠送 super() ；写了则用写的指定的 super 调用，super 只能有一个，还必须是第一个。 */public class ConstructorTest { public static void main(String[] args) { Zi zi = new Zi(); }}class Fu { public Fu() { System.out.println(\"父类无参构造\"); } public Fu(int num) { System.out.println(\"父类有参构造！\"); }}class Zi extends Fu { public Zi() { super(); // 在调用父类无参构造方法，不写也可以，编译器会默认加上// super(20); // 在调用父类重载的构造方法 System.out.println(\"子类构造方法！\"); } public void method() {// super(); // 错误写法！只有子类构造方法，才能调用父类构造方法。 }} Java 继承的特点 Java 继承的特点： 1、子类拥有父类非 private 的属性、方法。2、子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。3、子类可以用自己的方式实现父类的方法。4、Java 的继承是单继承，也可以多重继承，但是不能是多继承。 单继承 就是一个子类只能继承一个父类，多重继承 就是：例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。图如下： 5 提高了类之间的耦合性（继承的缺点 ，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 super 和 this父类空间优先于子类对象产生，在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。 目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。 super 关键字super 的三种用法如下： 1234567+++ super 关键字的用法有三种：+ 1、在子类的成员方法中，访问父类的成员变量。+ 2、在子类的成员方法中，访问父类的成员方法。+ 3、在子类的构造方法中，访问父类的构造方法。+++ 结束！！！ super 的代码演示如下： 12345678910111213141516171819202122232425262728293031323334353637public class SuperTest { public static void main(String[] args) { Zi zi = new Zi(); zi.method(); zi.methodZi(); }}class Fu { int num = 10; public void method() { System.out.println(\"父类方法\"); }}class Zi extends Fu { int num = 20; public Zi() { super(); // 访问父类的构造方法 } public void methodZi() { System.out.println(super.num); // 父类中的 num } public void method() { super.method(); // 访问父类中的 method System.out.println(\"子类方法\"); }} this 关键字this 的三种用法如下： 123456789101112+++ 开始……+++ super 关键字用来访问父类内容，而 this 关键字用来访问本类内容。用法也有三种：+ 1、在本类的成员方法中，访问本类的成员变量。+ 2、在本类的成员方法中，访问本类的另一个成员方法。+ 3、在本类的构造方法中，访问本类的另一个构造方法。+++ 在第三种用法当中要注意：+ 1、this(...) 调用也必须是构造方法的第一个语句，唯一一个。+ 2、super 和 this 两种构造调用，不能同时使用。+++ 结束！！！ this 的代码演示如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ThisTest { public static void main(String[] args) { Zi zi = new Zi(); zi.showNum(); zi.methodB(); }}class Fu { int num = 30; Fu() { System.out.println(\"father\"); }}class Zi extends Fu { int num = 20; public Zi() {// super(); // 这一行不再赠送 this(123); // 本类的无参构造，调用本类的有参构造// this(1, 2); // 错误写法！ } public Zi(int n) { this(n, 2); } public Zi(int n, int m) { System.out.println(n + m); } public void showNum() { int num = 10; System.out.println(num); // 局部变量 System.out.println(this.num); // 本类中的成员变量 System.out.println(super.num); // 父类中的成员变量 } public void methodA() { System.out.println(\"AAA\"); } public void methodB() { this.methodA(); System.out.println(\"BBB\"); }} 注意一下： 两个方法不能相互调用，会出现死循环，导致的结果是栈内存溢出。 如下代码： 123456789101112131415161718192021222324252627public class Test { public static void main(String[] args) { Zi zi = new Zi(); zi.method01(); }}// 父类class Fu {}// 子类class Zi extends Fu { public void method01(){ this.method02(); System.out.println(\"Hello\"); } public void method02(){ this.method01(); System.out.println(\"World\"); }} 上述的 method01() 方法和 method02()方法 相互调用后，出现 栈内存溢出【StackOverflowError】 。如下所示： 12345678910Exception in thread \"main\" java.lang.StackOverflowError at Zi.method02(Test.java:28) at Zi.method01(Test.java:23) at Zi.method02(Test.java:28) at Zi.method01(Test.java:23) at Zi.method02(Test.java:28) at Zi.method01(Test.java:23) at Zi.method02(Test.java:28) at Zi.method01(Test.java:23) …… 注意啦！！！ 子类的每个构造方法中均有默认的 super() ，调用父类的空参构造。手动调用父类构造会覆盖默认的 super() 。super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 两者的内存图super 和 this 的内存图如下【您品，您细品】： 抽象类抽象类概述父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把 没有方法主体的方法 称为 抽象方法 。Java 语法规定，包含抽象方法的类 就是 抽象类 。【注意哦！抽象类不一定有抽象方法，但包含抽象方法的类就是抽象类】 代码演示如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 抽象方法：就是加上 abstract 关键字、然后去掉大括号、直接分号结束的方法。 * 抽象类：抽象方法所在的类，必须是抽象类才行。在 class 之前写上 abstract 即可。 * 使用抽象类和抽象方法： * 1、不能直接 new 抽象类对象。 * 2、必须用一个子类来继承抽象父类。 * 3、子类必须覆盖重写抽象父类当中所有的抽象方法。覆盖重写（实现）：子类去掉抽象方法的 abstract 关键字，然后补上方法体大括号。 * 4、创建子类对象进行使用。 */// 抽象类 Animalabstract class Animal { // 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。 public abstract void eat(); // 这是普通的成员方法 public void normalMethod() { System.out.println(\"normal method\"); }}// 抽象类 Animal 的实现类 Catclass Cat extends Animal { @Override public void eat() { System.out.println(\"猫吃鱼\"); }}// 测试类public class AbstractTest { public static void main(String[] args) {// Animal animal = new Animal(); // 错误写法！不能直接创建抽象类对象 Cat cat = new Cat(); cat.eat(); }} 注意事项关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。 123456789101112131415+++ 注意事项- 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。+ 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。- 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。+ 理解：子类的构造方法中，有默认的 super() ，需要访问父类构造方法。- 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。+ 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。- 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。+ 理解：假设子类不重写所有抽象方法，则子类中可能包含抽象方法。那么在子类创建对象后，调用抽象的方法，没有意义。+++ 注意事项 综合案例案例描述12345678+++ 案例描述+ 某群有多名成员，群主给成员发普通红包。普通红包的规则：- 1、群主的一笔金额，从群主余额中扣除，平均分成n等份，让成员领取。- 2、成员领取红包后，保存到成员余额中。+ 请根据描述，完成案例中所有类的定义以及指定类之间的继承关系，并完成发红包的操作。+++ 案例描述 案例分析根据描述分析，得出如下继承体系： 代码实现定义 User 用户类， 代码如下： 1234567891011121314151617181920212223242526272829303132333435public class User { private String name; // 姓名 private int money; // 余额，也就是当前用户拥有的钱数 public User() { } public User(String name, int money) { this.name = name; this.money = money; } // 展示一下当前用户有多少钱 public void show() { System.out.println(\"我叫：\" + name + \"，我有多少钱：\" + money); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getMoney() { return money; } public void setMoney(int money) { this.money = money; }} 定义 Manager 群主类， 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.ArrayList;// 群主的类public class Manager extends User { public Manager() { } public Manager(String name, int money) { super(name, money); } public ArrayList&lt;Integer&gt; send(int totalMoney, int count) { // 首先需要一个集合，用来存储若干个红包的金额 ArrayList&lt;Integer&gt; redList = new ArrayList&lt;&gt;(); // 首先看一下群主自己有多少钱 int leftMoney = super.getMoney(); // 群主当前余额 if (totalMoney &gt; leftMoney) { System.out.println(\"余额不足\"); return redList; // 返回空集合 } // 扣钱，其实就是重新设置余额 super.setMoney(leftMoney - totalMoney); // 发红包需要平均拆分成为count份 int avg = totalMoney / count; int mod = totalMoney % count; // 余数，也就是甩下的零头 // 除不开的零头，包在最后一个红包当中 // 下面把红包一个一个放到集合当中 for (int i = 0; i &lt; count - 1; i++) { redList.add(avg); } // 最后一个红包 int last = avg + mod; redList.add(last); return redList; }} 定义 Member 群成员类， 代码如下： 123456789101112131415161718192021222324252627282930import java.util.ArrayList;import java.util.Random;// 普通成员public class Member extends User { public Member() { } public Member(String name, int money) { super(name, money); } public void receive(ArrayList&lt;Integer&gt; list) { // 从多个红包当中随便抽取一个，给我自己。 // 随机获取一个集合当中的索引编号 int index = new Random().nextInt(list.size()); // 根据索引，从集合当中删除，并且得到被删除的红包，给我自己 int delta = list.remove(index); // 当前成员自己本来有多少钱： int money = super.getMoney(); // 加法，并且重新设置回去 super.setMoney(money + delta); }} 定义 LuckMoneyTest 测试类， 代码如下： 1234567891011121314151617181920212223242526272829303132import java.util.ArrayList;public class LuckMoneyTest { public static void main(String[] args) { Manager manager = new Manager(\"群主\", 100); Member one = new Member(\"成员A\", 0); Member two = new Member(\"成员B\", 0); Member three = new Member(\"成员C\", 0); manager.show(); // 100 one.show(); // 0 two.show(); // 0 three.show(); // 0 System.out.println(\"===============\"); // 群主总共发 20 块钱，分成 3 个红包 ArrayList&lt;Integer&gt; redList = manager.send(20, 3); // 三个普通成员收红包 one.receive(redList); two.receive(redList); three.receive(redList); manager.show(); // 100 - 20 = 80 // 6、6、8，随机分给三个人 one.show(); two.show(); three.show(); }} 最后的随机测试结果如下 【随机的不唯一】 ： 123456789我叫：群主，我有多少钱：100我叫：成员A，我有多少钱：0我叫：成员B，我有多少钱：0我叫：成员C，我有多少钱：0===========================我叫：群主，我有多少钱：50我叫：成员A，我有多少钱：16我叫：成员B，我有多少钱：16我叫：成员C，我有多少钱：18 接口接口的概述接口 是 Java 语言中的一种 引用数据类型 ，是方法的集合。如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含 抽象方法（JDK7及以前），默认方法和静态方法（JDK8），私有方法（JDK9）。 接口的定义，它与定义类方式相似，但是使用 interface 关键字来定义一个接口。它也会被编译成 .class 文件 ，但一定要明确它并不是类，而是另外一种引用数据类型。 接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法， 创建该类对象，就可以调用方法了，否则它必须是一个抽象类。 生活中接口和 Java 中接口对比： 引用数据类型： 数组，类，接口等等 接口的定义格式接口的定义格式，代码如下： 12345678public interface 接口名称 { //抽象方法 //默认方法 //静态方法 //私有方法} 接口的定义的示例代码如下【下面的过程中会使用到】： 12345678910111213141516// 接口的定义public interface MyInterfaceAbstract { // 01-定义一个抽象方法 public abstract void methodAbs1(); // 02-这也是抽象方法，省略了 public abstract void methodAbs2(); // 03-这也是抽象方法，省略了 abstract public void methodAbs3(); // 04-这也是抽象方法，省略了 public 和 abstract void methodAbs4();} 抽象方法抽象方法的定义抽象方法的定义 和相关介绍如下： 1234567891011+++ 抽象方法的定义+ 在任何版本的 Java 中，接口都能定义抽象方法。+ 抽象方法定义格式：public abstract 返回值类型 方法名称(参数列表);- 注意事项：+ 1、接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract+ 2、这两个关键字修饰符，可以选择性地省略。（如果是刚学，不推荐省略。）+ 3、方法的三要素，可以随意定义。+++ 抽象方法的定义 抽象方法的使用第一步： 先定义 MyInterfaceAbstract 接口 的实现类，代码如下： 123456789101112131415161718192021222324// MyInterfaceAbstract 接口的实现类public class MyInterfaceAbstractImpl implements MyInterfaceAbstract { @Override public void methodAbs1() { System.out.println(\"这是第一个方法！\"); } @Override public void methodAbs2() { System.out.println(\"这是第二个方法！\"); } @Override public void methodAbs3() { System.out.println(\"这是第三个方法！\"); } @Override public void methodAbs4() { System.out.println(\"这是第四个方法！\"); }} 第二步： 使用抽象方法 ，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738/** * 接口就是多个类的公共规范，是一种引用数据类型。最重要的内容就是其中的抽象方法。 * 如何定义一个接口的格式： * public interface 接口名称 { * // 接口内容 * } * * 备注：换成了关键字 interface 之后，编译生成的字节码文件仍然是：.java --&gt; .class。 * 如果是 Java 7，那么接口中可以包含的内容有：1、常量 2、抽象方法 * 如果是 Java 8，还可以额外包含有： 3、默认方法 4、静态方法 * 如果是 Java 9，还可以额外包含有： 5、私有方法 * * 接口使用步骤： * 1、接口不能直接使用，必须有一个 “实现类” 来 “实现” 该接口。 * 实现类的格式： * public class 实现类名称 implements 接口名称 { * // ... * } * 2、接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。实现的过程就是去掉 abstract 关键字，加上方法体大括号。 * 3、创建实现类的对象，进行使用。 * 注意事项：如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。 */// 抽象方法测试类public class AbstractMethodTest { public static void main(String[] args) { // 错误写法！不能直接 new 接口对象使用 // MyInterfaceAbstract inter = new MyInterfaceAbstract(); // 创建实现类的对象使用 MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl(); impl.methodAbs1(); impl.methodAbs2(); }} 默认方法默认方法的定义默认方法的定义 和相关介绍如下： 123456789101112+++ 默认方法的定义+ 从 Java 8 开始，接口里允许定义默认方法。+ 默认方法的格式：+ public default 返回值类型 方法名称(参数列表) {+ // 内容+ }- 默认方法用处：接口当中的默认方法，可以解决接口升级的问题。 +++ 默认方法的定义 默认方法的使用第一步： 先定义 MyInterfaceDefault 接口，代码如下： 123456789101112131415// 定义 MyInterfaceDefault 接口public interface MyInterfaceDefault { // 抽象方法 public abstract void methodAbs(); // 新添加了一个抽象方法// public abstract void methodAbs2(); // 新添加的方法，改成默认方法 public default void methodDefault() { System.out.println(\"这是新添加的默认方法\"); }} 第二步： 定义 MyInterfaceDefault 接口 的两个实现类，代码如下： 123456789101112131415161718192021222324// 定义 MyInterfaceDefault 接口实现类 Apublic class MyInterfaceDefaultA implements MyInterfaceDefault { @Override public void methodAbs() { System.out.println(\"实现了抽象方法，AAA\"); }}// 定义 MyInterfaceDefault 接口实现类 Bpublic class MyInterfaceDefaultB implements MyInterfaceDefault { @Override public void methodAbs() { System.out.println(\"实现了抽象方法，BBB\"); } @Override public void methodDefault() { System.out.println(\"实现类B覆盖重写了接口的默认方法\"); }} 第三步： 定义测试类 ，代码如下： 12345678910111213141516171819202122/** * 定义测试类 * 1、接口的默认方法，可以通过接口实现类对象直接调用。 * 2、接口的默认方法，也可以被接口实现类进行覆盖重写。 */public class DefaultMethodTest { public static void main(String[] args) { // 创建了实现类的对象 MyInterfaceDefaultA a = new MyInterfaceDefaultA(); a.methodAbs(); // 调用抽象方法，实际运行的是右侧实现类。 // 调用默认方法，如果实现类当中没有，会向上找接口 a.methodDefault(); // 这是新添加的默认方法 System.out.println(\"==========\"); MyInterfaceDefaultB b = new MyInterfaceDefaultB(); b.methodAbs(); b.methodDefault(); // 实现类 B 覆盖重写了接口的默认方法 }} 静态方法静态方法的定义123456789101112+++ 静态方法的定义+ 从 Java 8 开始，接口当中允许定义静态方法。+ 静态方法的格式：+ public static 返回值类型 方法名称(参数列表) {+ 方法体+ }+ 提示：就是将 abstract 或者 default 换成 static 即可，带上方法体。+++ 静态方法的定义 静态方法的使用第一步： 定义 MyInterfaceStatic 接口 ，代码如下： 12345678// 定义接口public interface MyInterfaceStatic { public static void methodStatic() { System.out.println(\"这是接口的静态方法！\"); }} 第二步： 定义 MyInterfaceStatic 接口 的实现类，代码如下： 123public class MyInterfaceStaticImpl implements MyInterfaceStatic { // 接口的静态方法不需要使用到接口实现类，只要接口名调用静态方法就可以了。} 第三步： 定义测试类 ，代码如下： 1234567891011121314151617181920/** * 定义测试类： * 注意事项：不能通过接口实现类的对象来调用接口当中的静态方法。 * 正确用法：通过接口名称，直接调用其中的静态方法。 * 调用格式：接口名称.静态方法名(参数); */public class StaticMethodTest { public static void main(String[] args) { // 创建了实现类对象 MyInterfaceStaticImpl impl = new MyInterfaceStaticImpl(); // 错误写法！// impl.methodStatic(); // 直接通过接口名称调用静态方法 MyInterfaceStatic.methodStatic(); }} 私有方法私有方法的定义123456789101112131415161718+++ 私有方法的定义+ 问题描述：我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。但是这个共有方法不应该让实现类使用，应该是私有化的。+ 解决方案：从 Java 9 开始，接口当中允许定义私有方法。+ - 1、普通私有方法，解决多个默认方法之间重复代码问题+ 普通私有方法的格式：+ private 返回值类型 方法名称(参数列表) {+ 方法体+ }+ - 2、静态私有方法，解决多个静态方法之间重复代码问题+ 静态私有方法的格式：+ private static 返回值类型 方法名称(参数列表) {+ 方法体+ }+++ 私有方法的定义 私有方法的使用第一步： 定义两个接口：MyInterfacePrivateA 和 MyInterfacePrivateB ，代码如下： 1234567891011121314151617181920// 定义接口 Apublic interface MyInterfacePrivateA { public default void methodDefault1() { System.out.println(\"默认方法1\"); methodCommon(); } public default void methodDefault2() { System.out.println(\"默认方法2\"); methodCommon(); } private void methodCommon() { System.out.println(\"AAA\"); System.out.println(\"BBB\"); System.out.println(\"CCC\"); }} 1234567891011121314151617181920// 定义接口 Bpublic interface MyInterfacePrivateB { public static void methodStatic1() { System.out.println(\"静态方法1\"); methodStaticCommon(); } public static void methodStatic2() { System.out.println(\"静态方法2\"); methodStaticCommon(); } private static void methodStaticCommon() { System.out.println(\"AAA\"); System.out.println(\"BBB\"); System.out.println(\"CCC\"); }} 第二步： 定义接口实现类 ，代码如下： 123456789// 定义接口实现类public class MyInterfacePrivateAImpl implements MyInterfacePrivateA { public void methodAnother() { // 直接访问到了接口中的默认方法，这样是错误的！// methodCommon(); }} 第二步： 定义测试类 ，代码如下： 1234567891011// 定义测试类public class PrivateMethodTest { public static void main(String[] args) { MyInterfacePrivateB.methodStatic1(); MyInterfacePrivateB.methodStatic2(); // 错误写法！// MyInterfacePrivateB.methodStaticCommon(); }} 常量定义和使用123456789101112+++ 常量定义和使用+ 接口当中也可以定义“成员变量”，但是必须使用 public static final 三个关键字进行修饰。从效果上看，这其实就是接口的【常量】。+ 格式：public static final 数据类型 常量名称 = 数据值;+ 备注：一旦使用 final 关键字进行修饰，说明不可改变。- 注意事项：+ 1、接口当中的常量，可以省略 public static final，注意：不写也照样是这样。+ 2、接口当中的常量，必须进行赋值；不能不赋值。+ 3、接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则，并非强制）+++ 常量定义和使用 常量定义和使用 的代码演示如下： 1234567891011121314151617// 定义接口interface MyInterfaceConst { // 这其实就是一个常量，一旦赋值，不可以修改 public static final int NUM_OF_MY_CLASS = 12;}// 定义测试类public class InterfaceConstTest { public static void main(String[] args) { // 访问接口当中的常量 System.out.println(MyInterfaceConst.NUM_OF_MY_CLASS); }} 接口的内容小结接口的内容小结如下： 123456789101112131415161718192021+++ 接口的内容小结+ 在 Java 9+ 版本中，接口的内容可以有：+ 1、成员变量其实是常量，格式：[public] [static] [final] 数据类型 常量名称 = 数据值;- 注意：常量必须进行赋值，而且一旦赋值不能改变。常量名称完全大写，用下划线进行分隔。+ 2、接口中最重要的就是抽象方法，格式：[public] [abstract] 返回值类型 方法名称(参数列表);- 注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。+ 3、从 Java 8 开始，接口里允许定义默认方法，格式：[public] default 返回值类型 方法名称(参数列表) { 方法体 }- 注意：默认方法也可以被覆盖重写。+ 4、从Java 8开始，接口里允许定义静态方法，格式：[public] static 返回值类型 方法名称(参数列表) { 方法体 }- 注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法+ 5、从 Java 9 开始，接口里允许定义私有很乏，格式：+ 普通私有方法：private 返回值类型 方法名称(参数列表) { 方法体 }+ 静态私有方法：private static 返回值类型 方法名称(参数列表) { 方法体 }- 注意：private 的方法只有接口自己才能调用，不能被实现类或别人使用。+++ 接口的内容小结 继承并实现多个接口继承并实现多个接口 的代码演示如下： 123456789101112131415161718192021public interface MyInterfaceA { // 错误写法！接口不能有静态代码块// static {//// } // 错误写法！接口不能有构造方法// public MyInterfaceA() {//// } public abstract void methodA(); public abstract void methodAbs(); public default void methodDefault() { System.out.println(\"默认方法AAA\"); }} 123456789101112131415161718192021public interface MyInterfaceB { // 错误写法！接口不能有静态代码块// static {//// } // 错误写法！接口不能有构造方法// public MyInterfaceA() {//// } public abstract void methodB(); public abstract void methodAbs(); public default void methodDefault() { System.out.println(\"默认方法BBB\"); }} 1234567public interface MyInterface { public default void method() { System.out.println(\"接口的默认方法\"); }} 123456789101112131415161718192021222324public class MyInterfaceImpl /*extends Object*/ implements MyInterfaceA, MyInterfaceB { @Override public void methodA() { System.out.println(\"覆盖重写了A方法\"); } @Override public void methodB() { System.out.println(\"覆盖重写了B方法\"); } @Override public void methodAbs() { System.out.println(\"覆盖重写了AB接口都有的抽象方法\"); } @Override public void methodDefault() { System.out.println(\"对多个接口当中冲突的默认方法进行了覆盖重写\"); }} 1234567public class Fu { public void method() { System.out.println(\"父类方法\"); }} 123public class Zi extends Fu implements MyInterface {} 123456789101112131415161718192021/* * 使用接口的时候，需要注意： * 1、接口是没有静态代码块或者构造方法的。 * 2、一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。 * 实现多个接口格式如下： * public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB { * // 覆盖重写所有抽象方法 * } * 3、如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。 * 4、如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。 * 5、如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。 * 6、一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。 */public class ExtendsAndImplementsTest { public static void main(String[] args) { Zi zi = new Zi(); zi.method(); }} 接口之间的多继承接口之间的 多继承 的代码实现如下： 1234567891011public interface MyInterfaceA { public abstract void methodA(); public abstract void methodCommon(); public default void methodDefault() { System.out.println(\"AAA\"); }} 1234567891011public interface MyInterfaceB { public abstract void methodB(); public abstract void methodCommon(); public default void methodDefault() { System.out.println(\"BBB\"); }} 1234567891011121314151617/** * 这个子接口当中有几个方法？答：4个。 * methodA 来源于接口 A * methodB 来源于接口 B * methodCommon 同时来源于接口 A 和 B * method 来源于我自己 */public interface MyInterface extends MyInterfaceA, MyInterfaceB { public abstract void method(); @Override public default void methodDefault() { }} 1234567891011121314151617181920212223public class MyInterfaceImpl implements MyInterface { @Override public void method() { } @Override public void methodA() { } @Override public void methodB() { } @Override public void methodCommon() { }} 123456789101112/** * 1、类与类之间是单继承的。直接父类只有一个。 * 2、类与接口之间是多实现的。一个类可以实现多个接口。 * 3、接口与接口之间是多继承的。 * * 注意事项： * 1、多个父接口当中的抽象方法如果重复，没关系。 * 2、多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着 default 关键字】。 */public class Demo01Relations {} 多态多态的概述多态 是指同一行为，具有多个不同表现形式，是 封装 、继承 之后，面向对象的第三大特性。 在生活中，比如跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也是不一样的。可见，同一行为，在不同的事物中，可以体现出来的不同的形态。 多态描述的就是这样的状态。 多态的前提： 1、继承或者实现【二选一】 2、方法的重写【意义体现：不重写，无意义】 3、父类引用指向子类对象【格式体现】 多态的体现1234567# 多态体现的格式# 父类类型：指子类对象继承的父类类型，或者实现的父接口类型。父类类型 变量名 = new 子类对象;变量名.方法名();# 多态体现的格式 多态体现的格式 相关代码如下： 1234567891011121314151617181920212223242526272829303132333435363738class Fu { public void method() { System.out.println(\"父类方法\"); } public void methodFu() { System.out.println(\"父类特有方法\"); }}class Zi extends Fu { @Override // 重写了父类的 method() 方法 public void method() { System.out.println(\"子类方法\"); }}/* * 代码当中体现多态性，其实就是一句话：父类引用指向子类对象。 * 格式：父类名称 对象名 = new 子类名称(); * 或者：接口名称 对象名 = new 实现类名称(); */ // 测试类public class Demo01Multi { public static void main(String[] args) { // 使用多态的写法：左侧父类的引用，指向了右侧子类的对象 Fu obj = new Zi(); obj.method(); obj.methodFu(); }} 引用类型转换向上转型向上转型： 多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。当父类引用指向子类对象时，便是向上转型。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Fu /*extends Object*/ { int num = 10; public void showNum() { System.out.println(num); } public void method() { System.out.println(\"父类方法\"); } public void methodFu() { System.out.println(\"父类特有方法\"); }}class Zi extends Fu { int num = 20; int age = 16; @Override public void showNum() { System.out.println(num); } @Override public void method() { System.out.println(\"子类方法\"); } public void methodZi() { System.out.println(\"子类特有方法\"); }}/* * 访问成员变量的两种方式： * 1、直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。 * 2、间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。 */public class Demo01MultiField { public static void main(String[] args) { // 使用多态的写法，父类引用指向子类对象 Fu obj = new Zi(); System.out.println(obj.num); // 父：10// System.out.println(obj.age); // 错误写法！ System.out.println(\"=============\"); // 子类没有覆盖重写，就是父：10 // 子类如果覆盖重写，就是子：20 obj.showNum(); }}/* * 在多态的代码当中，成员方法的访问规则是：看 new 的是谁，就优先用谁，没有则向上找。口诀：编译看左边，运行看右边。 * 对比一下： * 成员变量：编译看左边，运行还看左边。 * 成员方法：编译看左边，运行看右边。 */public class Demo02MultiMethod { public static void main(String[] args) { Fu obj = new Zi(); // 多态 obj.method(); // 父子都有，优先用子 obj.methodFu(); // 子类没有，父类有，向上找到父类 // 编译看左边，左边是 Fu，Fu 当中没有 methodZi 方法，所以编译报错。// obj.methodZi(); // 错误写法！ }} 向下转型向下转型： 父类类型向子类类型向下转换的过程，这个过程是强制的。 相关代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public abstract class Animal { public abstract void eat();}class Cat extends Animal { @Override public void eat() { System.out.println(\"猫吃鱼\"); } // 子类特有方法 public void catchMouse() { System.out.println(\"猫抓老鼠\"); }}public class Dog extends Animal { @Override public void eat() { System.out.println(\"狗吃SHIT\"); } public void watchHouse() { System.out.println(\"狗看家\"); }}/* * 向上转型一定是安全的，没有问题的，正确的。但是也有一个弊端：对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。 * 解决方案：用对象的向下转型【还原】。 */public class Demo01Main { public static void main(String[] args) { // 对象的向上转型，就是：父类引用指向之类对象。 Animal animal = new Cat(); // 本来创建的时候是一只猫 animal.eat(); // 猫吃鱼// animal.catchMouse(); // 错误写法！ // 向下转型，进行“还原”动作 Cat cat = (Cat) animal; cat.catchMouse(); // 猫抓老鼠 // 下面是错误的向下转型，本来 new 的时候是一只猫，现在非要当做狗 // 错误写法！编译不会报错，但是运行会出现异常：java.lang.ClassCastException，类转换异常 Dog dog = (Dog) animal; }}/* * 如何才能知道一个父类引用的对象，本来是什么子类？ * 格式：对象 instanceof 类名称 * 这将会得到一个 boolean 值结果，也就是判断前面的对象能不能当做后面类型的实例。 */public class Demo02Instanceof { public static void main(String[] args) { Animal animal = new Dog(); // 本来是一只狗 animal.eat(); // 狗吃SHIT // 如果希望掉用子类特有方法，需要向下转型 // 判断一下父类引用 animal 本来是不是 Dog if (animal instanceof Dog) { Dog dog = (Dog) animal; dog.watchHouse(); } // 判断一下 animal 本来是不是 Cat if (animal instanceof Cat) { Cat cat = (Cat) animal; cat.catchMouse(); } giveMeAPet(new Dog()); } public static void giveMeAPet(Animal animal) { if (animal instanceof Dog) { Dog dog = (Dog) animal; dog.watchHouse(); } if (animal instanceof Cat) { Cat cat = (Cat) animal; cat.catchMouse(); } }} 为什么要转型123456+++ 为什么要转型+ 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有而父类没有的方法。+ 编译都错误，更别说运行了。这也是多态给我们带来的一点\"小麻烦\"。所以，想要调用子类特有的方法，必须做向下转型。+++ 为什么要转型 多态综合案例案例描述笔记本电脑（laptop）通常具备使用 USB 设备的功能。在生产时，笔记本都预留了可以插入 USB 设备的 USB 接口，但具体是什么 USB 设备，笔记本厂商并不关心，只要符合 USB 规格的设备都可以。所以定义 USB 接口，必须具备最基本的开启功能和关闭功能。 鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守 USB 规范，实现 USB 接口，否则鼠标和键盘的生产出来也无法使用。 案例分析要实现上述案例，需要经过如下分析： 123456789++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 进行描述笔记本类，实现笔记本使用 USB 鼠标、USB 键盘等 USB 设备。+ USB 接口： 包含开启功能、关闭功能+ 笔记本类： 包含运行功能、关机功能、使用 USB 设备功能+ 鼠标类： 要实现 USB 接口，并具备点击的方法+ 键盘类： 要实现 USB 接口，具备敲击的方法+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 代码实现为了完成上述案例，我们需要定义如下几个类或接口。 代码如下： USB.java123456public interface USB { public abstract void open(); // 打开设备 public abstract void close(); // 关闭设备} Mouse.java12345678910111213141516// 鼠标就是一个 USB 设备，所以需要实现 USB 接口public class Mouse implements USB { @Override public void open() { System.out.println(\"打开鼠标\"); } @Override public void close() { System.out.println(\"关闭鼠标\"); } public void click() { System.out.println(\"鼠标点击\"); }} Keyboard.java12345678910111213141516// 键盘也是一个 USB 设备，也需要实现 USB 接口public class Keyboard implements USB { @Override public void open() { System.out.println(\"打开键盘\"); } @Override public void close() { System.out.println(\"关闭键盘\"); } public void type() { System.out.println(\"键盘输入\"); }} Computer.java123456789101112131415161718192021222324public class Computer { public void powerOn() { System.out.println(\"笔记本电脑开机\"); } public void powerOff() { System.out.println(\"笔记本电脑关机\"); } // 使用 USB 设备的方法，使用接口作为方法的参数 public void useDevice(USB usb) { usb.open(); // 打开设备 if (usb instanceof Mouse) { // 一定要先判断 Mouse mouse = (Mouse) usb; // 向下转型 mouse.click(); } else if (usb instanceof Keyboard) { // 先判断 Keyboard keyboard = (Keyboard) usb; // 向下转型 keyboard.type(); } usb.close(); // 关闭设备 }} 定义完上面的类和接口之后，就编写测试类。 代码如下： DemoMain.java1234567891011121314151617181920212223242526272829303132333435public class DemoMain { public static void main(String[] args) { // 首先创建一个笔记本电脑 Computer computer = new Computer(); computer.powerOn(); // 准备一个鼠标，供电脑使用// Mouse mouse = new Mouse(); // 首先进行向上转型 USB usbMouse = new Mouse(); // 多态写法 // 参数是USB类型，我正好传递进去的就是USB鼠标 computer.useDevice(usbMouse); // 创建一个USB键盘 Keyboard keyboard = new Keyboard(); // 没有使用多态写法 // 方法参数是USB类型，传递进去的是实现类对象 computer.useDevice(keyboard); // 正确写法！也发生了向上转型 // 使用子类对象，匿名对象，也可以// computer.useDevice(new Keyboard()); // 也是正确写法 computer.powerOff(); System.out.println(\"==================\"); method(10.0); // 正确写法，double --&gt; double method(20); // 正确写法，int --&gt; double int a = 30; method(a); // 正确写法，int --&gt; double } public static void method(double num) { System.out.println(num); }} TIPS： 到此，多态学习结束！！！ final 关键字final 概述学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？ 显然这是不合适的。为了避免这种随意改写的情况，Java提供了 final 关键字，用于修饰不可改变的内容。 具体介绍如下： 12345678+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ final 关键字：意为不可改变。可以用于修饰类、方法和变量。+ 类： 被修饰的类，不能被继承。+ 方法： 被修饰的方法，不能被重写。+ 变量： 被修饰的变量，不能被重新赋值。++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 使用方式第一种： final 修饰类。被修饰的这个类无法被继承。 代码如下： 12345678910111213141516/* * 当 final 关键字用来修饰一个类的时候，格式： * public final class 类名称 { * // ... * } * * 含义：被修饰的这个类不能有任何的子类。（太监类） * 注意：一个类如果是 final 修饰的，那么其中所有的成员方法都无法进行覆盖重写（因为没儿子。） */public final class MyFinalClass /*extends Object*/ { public void method() { System.out.println(\"方法执行！\"); }} 第二种： final 修饰方法。被修饰的这个方法不能被重写。 代码如下： 123456789101112131415161718192021222324252627282930313233/* * 当 final 关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。格式如下： * 修饰符 final 返回值类型 方法名称(参数列表) { * // 方法体 * } * * 注意事项：对于类、方法来说，abstract 关键字和 final 关键字不能同时使用，因为矛盾。 */public abstract class Fu { public final void method() { System.out.println(\"父类方法执行！\"); } // 加上 final 就是错误的写法 public abstract /*final*/ void methodAbs() ;}public class Zi extends Fu { @Override public void methodAbs() { } // 错误写法！不能覆盖重写父类当中 final 的方法// @Override// public void method() {// System.out.println(\"子类覆盖重写父类的方法！\");// }} 第三种： final 修饰变量。被修饰的这个变量，不能被重新赋值，即成为了常量。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * final 关键字代表最终、不可改变的。 * 常见四种用法： * 1、可以用来修饰一个类 * 2、可以用来修饰一个方法 * 3、还可以用来修饰一个局部变量 * 4、还可以用来修饰一个成员变量 */public class Demo01Final { public static void main(String[] args) { int num1 = 10; System.out.println(num1); // 10 num1 = 20; System.out.println(num1); // 20 // 一旦使用 final 用来修饰局部变量，那么这个变量就不能进行更改。 “一次赋值，终生不变” final int num2 = 200; System.out.println(num2); // 200// num2 = 250; // 错误写法！不能改变！// num2 = 200; // 错误写法！ // 正确写法！只要保证有唯一一次赋值即可 final int num3; num3 = 30; // 对于基本类型来说，不可变说的是变量当中的数据不可改变 // 对于引用类型来说，不可变说的是变量当中的地址值不可改变 Student stu1 = new Student(\"赵丽颖\"); System.out.println(stu1); System.out.println(stu1.getName()); // 赵丽颖 stu1 = new Student(\"霍建华\"); System.out.println(stu1); System.out.println(stu1.getName()); // 霍建华 System.out.println(\"===============\"); final Student stu2 = new Student(\"高圆圆\"); // 错误写法！final 的引用类型变量，其中的地址不可改变// stu2 = new Student(\"赵又廷\"); System.out.println(stu2.getName()); // 高圆圆 stu2.setName(\"高圆圆圆圆圆圆\"); System.out.println(stu2.getName()); // 高圆圆圆圆圆圆 }} TIPS： 到此，final 关键字学习结束！！！ 权限修饰符权限修饰符概述在 Java 中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限。 具体介绍如下： 1234567891011121314151617++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ public【公共的】+ public 是权限最大的修饰符，他可以修饰类，成员变量，成员方法，构造方法。被 public 修饰后，可以在任何一个类中，不管同不同包，任意使用。+++ protected【受保护的】+ protected 可以修饰成员变量，成员方法，构造方法，但不能修饰类【此处指的是外部类，内部类不加以考虑】。+ 被 protected 修饰后，只能被同包下的其他类访问。如果不同包下的类要访问被 protected 修饰的成员，这个类必须是其子类。 +++ 【default：默认的】+ defalut 即不写任何关键字，它可以修饰类，成员变量，成员方法，构造方法。被默认权限修饰后，其只能被本类以及同包下的其他类访问。 +++ private 【私有的】+ private 可以修饰成员变量，成员方法，构造方法，不能修饰类【此刻指的是外部类，内部类不加以考虑】。+ 被 private 修饰的成员只能在其修饰的本类中访问，在其他类中不能调用。如果一定要访问，那么可以通过 set 和 get 方法向外界提供访问方式。+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 访问能力上面已经介绍过了四种权限修饰符，那么接下来介绍它们各自的访问能力。 如下： 123456789101112######################################################################################################### Java 中有四种权限修饰符，其访问能力如下：public &gt; protected &gt; (default) &gt; private YES YES YES YES 同一个类 YES YES YES NO 同一个包【子类与其他类】 YES YES NO NO 不同包子类 YES NO NO NO 不同包非子类# 注意事项：(default)并不是关键字 “default” ，而是什么都不写。例如：int i = 0; 这个就是 default 。######################################################################################################## 代码模板介绍完四种权限修饰符的访问能力之后，我们就使用代码测试以下。 第一个包中的代码： 1234567891011121314package edu.jgsu.demo02;// demo02 包中的 MyAnother 类public class MyAnother { public void anotherMethod() {// System.out.println(new MyClass().num); }}// demo02 包中的 Demo01Main 类public class Demo01Main {} 第二个包中的代码： 1234567891011121314151617181920212223package edu.jgsu.demo02.sub;import cn.itcast.day11.demo02.MyClass;public class MySon extends MyClass { public void methodSon() {// System.out.println(super.num); }}package edu.jgsu.demo02.sub;import cn.itcast.day11.demo02.MyClass;public class Stranger { public void methodStrange() { System.out.println(new MyClass().num); }} TIPS： 到此，权限修饰符学习结束！！！ 内部类内部类概述什么是内部类将一个类 A 定义在另一个类 B 里面，里面的那个类 A 就称为内部类，类 B 则称为外部类。具体解释及内部类分类都写在代码注释中了： 1234567891011121314151617181920212223242526272829303132333435363738/*如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。例如：身体和心脏的关系。又如：汽车和发动机的关系。分类：1. 成员内部类2. 局部内部类（包含匿名内部类）成员内部类的定义格式：修饰符 class 外部类名称 { 修饰符 class 内部类名称 { // ... } // ...}注意：内用外，随意访问；外用内，需要内部类对象。==========================如何使用成员内部类？有两种方式：1. 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。2. 直接方式，公式：类名称 对象名 = new 类名称();【外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();】 */public class Demo01InnerClass { public static void main(String[] args) { Body body = new Body(); // 外部类的对象 // 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart body.methodBody(); System.out.println(\"=====================\"); // 按照公式写： Body.Heart heart = new Body().new Heart(); heart.beat(); }} 成员内部类相关代码： 1234567891011121314151617181920212223242526272829public class Body { // 外部类 public class Heart { // 成员内部类 // 内部类的方法 public void beat() { System.out.println(\"心脏跳动：蹦蹦蹦！\"); System.out.println(\"我叫：\" + name); // 正确写法！ } } // 外部类的成员变量 private String name; // 外部类的方法 public void methodBody() { System.out.println(\"外部类的方法\"); new Heart().beat(); } public String getName() { return name; } public void setName(String name) { this.name = name; }} 12345678910111213141516171819// 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名public class Outer { int num = 10; // 外部类的成员变量 public class Inner /*extends Object*/ { int num = 20; // 内部类的成员变量 public void methodInner() { int num = 30; // 内部类方法的局部变量 System.out.println(num); // 局部变量，就近原则 System.out.println(this.num); // 内部类的成员变量 System.out.println(Outer.this.num); // 外部类的成员变量 } }} 内部类的访问： 123456789public class Demo02InnerClass { public static void main(String[] args) { // 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); Outer.Inner obj = new Outer().new Inner(); obj.methodInner(); }} 局部内部类如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。只有当前所属的方法才能使用它，出了这个方法外面就不能用了。代码如下： 1234567891011121314151617181920212223242526272829303132333435/*如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。定义格式：修饰符 class 外部类名称 { 修饰符 返回值类型 外部类方法名称(参数列表) { class 局部内部类名称 { // ... } }}小节一下类的权限修饰符：public &gt; protected &gt; (default) &gt; private定义一个类的时候，权限修饰符规则：1. 外部类：public / (default)2. 成员内部类：public / protected / (default) / private3. 局部内部类：什么都不能写 */class Outer { public void methodOuter() { class Inner { // 局部内部类 int num = 10; public void methodInner() { System.out.println(num); // 10 } } Inner inner = new Inner(); inner.methodInner(); }} 123456789101112131415161718192021222324/*局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。原因：1. new出来的对象在堆内存当中。2. 局部变量是跟着方法走的，在栈内存当中。3. 方法运行结束之后，立刻出栈，局部变量就会立刻消失。4. 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。 */public class MyOuter { public void methodOuter() { int num = 10; // 所在方法的局部变量 class MyInner { public void methodInner() { System.out.println(num); } } }} 12345678public class DemoMain { public static void main(String[] args) { Outer obj = new Outer(); obj.methodOuter(); }} 匿名内部类12 常用 API 由于本文过长，请阅读： Java 常用 API到此为止，Java 基础（中篇）就结束了。接下来就是 Java 重点内容，集合与 IO 流 以及异常多线程。","link":"/JavaSE-02.html"},{"title":"Java 基础（下篇）","text":"Collection 集合集合概述在 Java 基础（中篇） 已经学习过并使用过集合 ArrayList&lt;E&gt; ,那么集合到底是什么呢?集合是 java 中提供的一种容器，可以用来存储多个数据。那么集合和数组既然都是容器，它们之间有什么区别呢？ 数组和集合的区别： 1、数组的长度是固定的。集合的长度是可变的。 2、数组中存储的是同一类型的元素，可以存储基本数据类型值，也可以存储对象。集合存储的都是对象，而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。 来看下图，了解集合： 集合框架JavaSE 提供了满足各种需求的 API，在使用这些 API 前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合 java.util.Collection 和双列集合 java.util.Map 。 Collection 集合： 1、Collection 集合：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是 List 和 Set 。 2、List 集合：List 的特点是 元素有序、元素可重复。List 的主要实现类有 ArrayList 和 LinkedList。 3、Set 集合：Set 的特点是 元素无序，而且不可重复。Set 的主要实现类有 HashSet 和 TreeSet。 从上面的描述可以看出 JDK 中提供了丰富的集合类库，为了便于进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 其中，橙色框代表接口类型，而蓝色框代表具体的实现类。集合本身是一个工具，它存放在 java.util 包中。在 Collection 接口中定义着单列集合框架中最最共性的内容。 Collection 常用功能Collection 是所有单列集合的父接口，因此在 Collection 中定义了单列集合( List 和 Set ) 通用 的一些方法，这些方法可用于操作所有的单列集合。这些通用方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 代码实例演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// java.util.Collection 接口,所有单列集合的最顶层的接口,里边定义了所有单列集合共性的方法,任意的单列集合都可以使用 Collection 接口中的方法public static void main(String[] args) { // 01-创建集合对象,可以使用多态,只要实现了 Collection 接口的实现类都可以，如 ArrayList、hashSet、LinkedList 等等 Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();// Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); System.out.println(collection); // 结果：，说明重写了 toString 方法 // 02-添加操作，把给定的对象添加到当前集合中,返回值是一个 boolean 值,一般都返回 true ,所以可以不用接收 boolean bool01 = collection.add(\"张三\"); System.out.println(bool01); System.out.println(collection); collection.add(\"李四\"); collection.add(\"李四\"); collection.add(\"王五\"); collection.add(\"赵六\"); System.out.println(collection); // 03-删除操作，把给定的对象在当前集合中删除。返回值是一个 boolean 值,集合中存在元素,删除元素,返回 true，集合中不存在元素,删除失败,返回 false boolean bool02 = collection.remove(\"Jack\"); System.out.println(bool02); // 元素不存在，返回 false boolean bool03 = collection.remove(\"李四\"); System.out.println(bool03); // 元素存在，返回 true System.out.println(collection); // 04-是否包含，判断当前集合中是否包含给定的对象。包含返回 true，不包含返回 false boolean bool04 = collection.contains(\"Jack\"); System.out.println(bool04); // 不包含，返回 false boolean bool05 = collection.contains(\"张三\"); System.out.println(bool05); // 包含，返回 true // 05-是否为空，集合为空返回 true,集合不为空返回 false boolean isEmpty = collection.isEmpty(); System.out.println(isEmpty); // 06-集合大小，返回集合中元素的个数。 int size = collection.size(); System.out.println(size); System.out.println(collection); // 07-集合转数组，把集合中的元素，存储到数组中。 Object[] objects = collection.toArray(); for (int i = 0; i &lt; objects.length; i++) { System.out.println(objects[i]); } // 08-清空集合操作，清空集合中所有的元素。但是不删除集合,集合还存在 collection.clear(); System.out.println(collection); System.out.println(collection.isEmpty());} 迭代器知识迭代器介绍在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK 专门提供了一个接口 java.util.Iterator。Iterator 接口也是 Java 集合中的一员，但它与 Collection、Map 接口有所不同，Collection 接口与 Map 接口主要用于存储元素，而 Iterator 主要用于迭代访问（即遍历）Collection 中的元素，因此 Iterator 对象也被称为迭代器。想要遍历 Collection 集合，那么就要获取该集合迭代器完成迭代操作。 迭代的概念： 迭代是集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator 接口的常用方法如下： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 迭代器使用接下来我们通过代码学习如何使用 Iterator 迭代集合中元素，使用代码把上述介绍的方法过一遍： 1234567891011121314151617181920212223242526272829public static void main(String[] args) { // 01-创建集合对象 Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); // 02-往集合添加元素 collection.add(\"Lisa\"); collection.add(\"Jack\"); collection.add(\"Tom\"); collection.add(\"Jerry\"); // 03-创建迭代器，注意：Iterator&lt;E&gt; 接口也是有泛型的,迭代器的泛型跟着集合走,集合是什么泛型,迭代器就是什么泛型 Iterator&lt;String&gt; iterator = collection.iterator(); // 04-使用迭代器遍历集合 while (iterator.hasNext()){ System.out.println(iterator.next()); } // 05-知识拓展：使用 for 遍历集合 System.out.println(\"===========\"); // 这个 for 循环有点儿特殊 for (Iterator&lt;String&gt; it = collection.iterator(); it.hasNext();){ System.out.println(it.next()); } // 06-如果集合中没有元素，那么会抛出异常 Exception in thread \"main\" java.util.NoSuchElementException Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); Iterator&lt;String&gt; iterator1 = coll.iterator(); System.out.println(iterator1.next());} 迭代器原理我们在上述案例已经完成了 Iterator 遍历集合的整个过程。当遍历集合时，首先通过调用集合的 iterator() 方法获得迭代器对象，然后使用 hashNext() 方法判断集合中是否存在下一个元素，如果存在，则调用 next() 方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。Iterator 迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了能更好地理解迭代器的工作原理，接下来通过一个图例来演示 Iterator 对象迭代元素的过程： 在调用 Iterator 的 next 方法之前，迭代器的索引位于第一个元素之前，即上图的 -1 位置，不指向任何元素，当第一次调用迭代器的 next 方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用 next 方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到 hasNext 方法返回 false ，表示到达了集合的末尾，终止对元素的遍历。 增强 for 循环所有的解释都在注释里面了，请看代码： 12345678910111213141516171819202122232425262728293031323334/** * 增强 for 循环（foreach） 特点： * 1、增强 for 循环:底层使用的也是迭代器,使用 for 循环的格式,简化了迭代器的书写 * 2、此 fo r循环必须有被遍历的目标，目标只能是 Collection 或者是数组。 * 3、是 JDK1.5 之后出现的新特性 * 4、Collection&lt;E&gt;extends Iterable&lt;E&gt;:所有的单列集合都可以使用增强 for * 5、 public interface Iterable&lt;T&gt;实现这个接口允许对象成为 \"foreach\" 语句的目标。 * 6、格式： * for(集合/数组的数据类型 变量名: 集合名/数组名){ * sout(变量名); * } */public static void main(String[] args) { // 01-创建集合 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); // 02-添加数据 list.add(\"abc\"); list.add(\"def\"); list.add(\"ghi\"); list.add(\"jkl\"); // 03-增强 for 循环遍历集合 for (String str : list) { System.out.println(str); } // 04-知识拓展：增强 for 遍历数组 System.out.println(\"=====\"); int[] arr = {1, 2, 3, 4, 5}; for(int i : arr){ System.out.println(i); }} 泛型泛型的概述Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？答案是可以使用 Java 泛型。使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。 看一张图，了解泛型： 泛型的好处 泛型的好处： 1、将运行时期的 ClassCastException，转移到了编译时期变成了编译失败。 2、避免了类型强转的麻烦。 通过如下代码体验一下泛型： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void main(String[] args) { // 01-不使用泛型案例 //listDemoFirst(); // 02-使用泛型案例 listDemoSecond();}/** * 创建集合对象，使用泛型： * 好处：1、避免了类型转换的麻烦,存储的是什么类型,取出的就是什么类型；2、把运行期异常(代码运行之后会抛出的异常),提升到了编译期(写代码的时候会报错) * 弊端：泛型是什么类型,只能存储什么类型的数据 */private static void listDemoSecond() { // 01-创建集合并添加数据 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(\"Tom\"); arrayList.add(\"Lisa\"); arrayList.add(\"Jack\");// arrayList.add(1); //直接编译不通过，报错信息：add(java.lang.String)in ArrayList cannot be applied to (int) // 02-迭代器遍历集合 Iterator&lt;String&gt; it = arrayList.iterator(); while (it.hasNext()){ String string = it.next(); System.out.println(string + \" --&gt; \" + string.length()); }}/** * 创建集合对象，不使用泛型： * 好处：集合不使用泛型，默认类型就是 Object 类型，可以存储任意类型的数据 * 弊端：不安全，会引发异常 */private static void listDemoFirst() { // 01-创建集合并添加数据 ArrayList list = new ArrayList(); list.add(\"Jack\"); list.add(37); // 02-迭代器遍历集合 Iterator iterator = list.iterator(); while (iterator.hasNext()){ // 03-取出的元素是 Object 类型的 Object object = iterator.next(); System.out.println(object); // 04-想要使用 String 类特有的方法,length 获取字符串的长度;不能使用多态 Object obj = \"abc\"; // 05-需要向下转型才能使用相关类方法，然而结果抛出 ClassCastException 类型转换异常,不能把 Integer 类型转换为 String 类型，这就是弊端 String str = (String)object; System.out.println(str.length()); }} tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。 泛型的定义和使用我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 有泛型的类例如，API 中的 ArrayList 集合： 1234567// 含有泛型的类的定义格式：修饰符 class 类名&lt;代表泛型的变量&gt; { }class ArrayList&lt;E&gt;{ public boolean add(E e){ } public E get(int index){ } ....} 实际代码如下： 1234567891011121314151617/** * 定义一个含有泛型的类,模拟 ArrayList 集合 * 泛型是一个未知的数据类型,当我们不确定什么什么数据类型的时候,可以使用泛型 * 泛型可以接收任意的数据类型,可以使用 Integer,String,Student... * 创建对象的时候确定泛型的数据类型 */public class MyArrayList&lt;E&gt; { private E name; public E getName() { return name; } public void setName(E name) { this.name = name; }} 使用自定义的泛型类： 即什么时候确定泛型。 1234567891011121314151617public static void main(String[] args) { // 01-创建 MyArrayList 对象，不写泛型，默认为 Object 类型 MyArrayList myArrayList = new MyArrayList(); myArrayList.setName(\"Jack\"); Object object = myArrayList.getName(); System.out.println(object); //02-创建 MyArrayList 对象，泛型使用 Integer 类型 MyArrayList&lt;Integer&gt; integerMyArrayList = new MyArrayList&lt;&gt;(); integerMyArrayList.setName(520); System.out.println(integerMyArrayList.getName()); // 03-创建 MyArrayList 对象，泛型使用 String 类型 MyArrayList&lt;String&gt; stringMyArrayList = new MyArrayList&lt;&gt;(); stringMyArrayList.setName(\"Tom\"); System.out.println(stringMyArrayList.getName());} 有泛型的方法例如： 12345678910// 有泛型的方法的定义格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){ }public class MyGenericMethod { public &lt;MVP&gt; void show(MVP mvp) { System.out.println(mvp.getClass()); } public &lt;MVP&gt; MVP show2(MVP mvp) { return mvp; }} 具体定义代码如下： 1234567891011121314151617/** * 定义含有泛型的方法：泛型定义在方法的修饰符和返回值类型之间 * 格式: 修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型)){ * 方法体; * } * 含有泛型的方法,在调用方法的时候确定泛型的数据类型 ，传递什么类型的参数,泛型就是什么类 */// 01-定义一个含有泛型的方法public &lt;M&gt; void method01(M m){ System.out.println(m);}// 02-定义一个含有泛型的静态方法public static &lt;S&gt; void method02(S s){ System.out.println(s);} 使用格式：调用方法时，确定泛型的类型 ，相关代码如下： 1234567891011121314151617181920212223242526public class GenericMethod { public static void main(String[] args) { // 01-创建 GenericMethod 对象 GenericMethod genericMethod = new GenericMethod(); // 02-调用含有泛型的方法 method01，传递什么类型,泛型就是什么类型 genericMethod.method01(10); genericMethod.method01(\"abc\"); genericMethod.method01(3.14); genericMethod.method01(true); // 03-调用静态方法,通过类名.方法名(参数)可以直接使用 GenericMethod.method02(\"静态方法\"); GenericMethod.method02(1.732); } // 01-定义一个含有泛型的方法 public &lt;M&gt; void method01(M m){ System.out.println(m); } // 02-定义一个含有泛型的静态方法 public static &lt;S&gt; void method02(S s){ System.out.println(s); }} 有泛型的接口定义格式及示例如下： 123456// 定义格式：修饰符 interface接口名&lt;代表泛型的变量&gt; { }public interface MyGenericInterface&lt;E&gt;{ public abstract void add(E e); public abstract E getE(); } 含有泛型的接口的具体代码如下： 1234// 定义含有泛型的接口public interface GenericInterface&lt;E&gt; { public abstract void method(E e);} 泛型接口的第一种实现代码如下： 12345678910111213141516/** * 含有泛型的接口,第一种使用方式:定义接口的实现类,实现接口,指定接口的泛型 * public interface Iterator&lt;E&gt; { * E next(); * } * Scanner类实现了 Iterator 接口,并指定接口的泛型为 String , 所以重写的 next 方法泛型默认就是 String * public final class Scanner implements Iterator&lt;String&gt;{ * public String next() {} * } */public class GenericInterfaceImpl1 implements GenericInterface&lt;String&gt;{ @Override public void method(String str) { System.out.println(str); }} 泛型接口的第二种实现代码如下： 123456789101112131415161718/** * 含有泛型的接口第二种使用方式:接口使用什么泛型,实现类就使用什么泛型,类跟着接口走 * 就相当于定义了一个含有泛型的类,创建对象的时候确定泛型的类型 * public interface List&lt;E&gt;{ * boolean add(E e); * E get(int index); * } * public class ArrayList&lt;E&gt; implements List&lt;E&gt;{ * public boolean add(E e) {} * public E get(int index) {} * } */public class GenericInterfaceImpl2&lt;E&gt; implements GenericInterface&lt;E&gt; { @Override public void method(E e) { System.out.println(e); }} 测试代码如下： 1234567891011121314// 测试含有泛型的接口public class Demo04GenericInterface { public static void main(String[] args) { // 01-创建 GenericInterfaceImpl1 对象 GenericInterfaceImpl1 gi1 = new GenericInterfaceImpl1(); gi1.method(\"字符串\"); // 02-创建 GenericInterfaceImpl2 对象 GenericInterfaceImpl2&lt;Integer&gt; gi2 = new GenericInterfaceImpl2&lt;&gt;(); gi2.method(10); GenericInterfaceImpl2&lt;Double&gt; gi3 = new GenericInterfaceImpl2&lt;&gt;(); gi3.method(8.8); }} 泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符 &lt;?&gt; 表示。但是一旦使用泛型的通配符后，只能使用 Object 类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用 ?, ? 表示未知通配符。此时只能接受数据,不能往该集合中存储数据。举个例子大家理解使用即可： 123456789public static void main(String[] args) { Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);}// ? 代表可以接收任意类型public static void getElement(Collection&lt;?&gt; coll){} 具体实际代码如下： 12345678910111213141516171819202122232425262728293031public static void main(String[] args) { /** * 泛型的通配符: ? 代表任意的数据类型 * 使用方式: 1、不能创建对象使用；2、只能作为方法的参数使用 */ ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;(); list01.add(1); list01.add(2); ArrayList&lt;String&gt; list02 = new ArrayList&lt;&gt;(); list02.add(\"a\"); list02.add(\"b\"); printArray(list01); printArray(list02);}/** * 定义一个方法,能遍历所有类型的 ArrayList 集合 * 这时候我们不知道 ArrayList 集合使用什么数据类型 ,可以泛型的通配符 ? 来接收数据类型 * 注意: 泛型没有继承概念的 */private static void printArray(ArrayList&lt;?&gt; list) { // 使用迭代器遍历集合 Iterator&lt;?&gt; iterator = list.iterator(); while (iterator.hasNext()){ System.out.println(iterator.next()); }} tips:泛型不存在继承关系 Collection&lt;Object&gt; list = new ArrayList&lt;String&gt;(); 这种是错误的。 通配符高级之受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在 Java 的泛型中可以指定一个泛型的 上限 和 下限 。 泛型的上限： 1、格式： 类型名称 &lt; ? extends xxx类 &gt; 对象名称 2、意义： 只能接收 xxx类型 及其子类 泛型的下限： 1、格式： 类型名称 &lt; ? super xxx类 &gt; 对象名称 2、意义： 只能接收 xxx类型 及其父类型 比如：现已知 Object 类，String 类，Number 类，Integer 类，其中 Number 是 Integer 的父类 12345678910111213141516171819202122public static void main(String[] args) { Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement1(list1); getElement1(list2); // 报错 getElement1(list3); getElement1(list4); // 报错 getElement2(list1); // 报错 getElement2(list2); // 报错 getElement2(list3); getElement2(list4);}// 泛型的上限：此时的泛型?，必须是 Number 类型或者 Number 类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll){}// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll){} 斗地主案例(单列)案例介绍按照斗地主的规则，完成洗牌发牌的动作。具体规则：使用 54 张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人 17 张牌，最后三张留作底牌。 案例分析 准备牌： 牌可以设计为一个 ArrayList ,每个字符串为一张牌。 每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。 牌由 Collections 类的 shuffle 方法进行随机排序。 发牌： 将每个人以及底牌设计为 ArrayList , 将最后 3 张牌直接存放于底牌，剩余牌通过对 3 取模依次发牌。 看牌： 直接打印每个集合。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class DouDiZhu { // 斗地主综合案例：1、准备牌 2、洗牌 3、发牌 4、看牌 public static void main(String[] args) { // 01-准备牌：定义一个存储 54 张牌的 ArrayList 集合,泛型使用 String ArrayList&lt;String&gt; poker = new ArrayList&lt;&gt;(); // 02-定义两个数组,一个数组存储牌的花色,一个数组存储牌的序号 String[] colors = {\"♠\",\"♥\",\"♣\",\"♦\"}; String[] numbers = {\"2\",\"A\",\"K\",\"Q\",\"J\",\"10\",\"9\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\"}; // 03-先把大王和小王存储到 poker 集合中 poker.add(\"大王\"); poker.add(\"小王\"); // 05-循环嵌套遍历两个数组,组装 52 张牌 for(String number : numbers){ for (String color : colors) { // 06-把组装好的牌存储到 poker 集合中 poker.add(color + number); } } // 07-洗牌：使用集合的工具类 Collections 中的方法 static void shuffle(List&lt;?&gt; list) 使用默认随机源对指定列表进行置换。 Collections.shuffle(poker); // 08-发牌：定义 4 个集合,存储玩家的牌和底牌 ArrayList&lt;String&gt; player01 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; player02 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; player03 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; diPai = new ArrayList&lt;&gt;(); /** * 1、遍历 poker 集合,获取每一张牌 * 2、使用 poker 集合的索引 % 3 给 3 个玩家轮流发牌 * 剩余 3 张牌给底牌。注意:先判断底牌(i&gt;=51),否则牌就发没了 */ for (int i = 0; i &lt; poker.size() ; i++) { // 获取每一张牌 String p = poker.get(i); // 轮流发牌 if(i &gt;= 51){ // 给底牌发牌 diPai.add(p); }else if(i % 3 == 0){ // 给 玩家1 发牌 player01.add(p); }else if(i % 3 == 1){ // 给 玩家2 发牌 player02.add(p); }else if(i % 3 == 2){ // 给 玩家3 发牌 player03.add(p); } } // 09-看牌 System.out.println(\"刘德华:\" + player01); System.out.println(\"周润发:\" + player02); System.out.println(\"周星驰:\" + player03); System.out.println(\"底牌:\" + diPai); }} Java 数据结构栈 栈（stack）： 1、概念：栈又称堆栈，它是运算受限的线性表，仅允许在一端进行插入和删除操作，不允许在其他任何位置进行添加、删除等操作。 2、特点：先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。 3、举例：子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先打出上面的子弹，然后才能打出下面的子弹。 4、出入口：栈的入口、出口的都是栈的顶端位置。 5、压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。 6、弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。 队列 队列（queue）： 1、概念：队列简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。 2、特点：先进先出（即，先存进去的元素先取出来，后存进去的元素后取出） 3、举例：例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。 4、出入口：队列的入口、出口各占一侧。就像管道一样，一边进一边出。 数组 数组（Array）： 1、概念：是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。 2、特点：查找元素快（通过索引，可以快速访问指定位置的元素），增删元素慢。 3、举例：就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。 链表 链表（linked list）： 1、概念：链表由一系列结点 node（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 2、特点：查找元素慢（想查找某个元素，需要通过连接的节点，依次向后查找指定元素）。增删元素快，增加元素：只需要修改连接下个元素的地址即可。删除元素：只需要修改连接下个元素的地址即可。 3、举例：多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。 红黑树 二叉树（binary tree）： 1、二叉树概念：二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。 2、红黑树概念：红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。 2、红黑树特点：速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍。 红黑树约束： 1、节点可以是红色的或者黑色的 2、根节点是黑色的 3、叶子节点(特指空节点)是黑色的 4、每个红色节点的子节点都是黑色的 5、任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同 这里写的数据结构只作为了解和参考，并没有什么实际用途。此处也没有写非常详细的东西，所以不要太在意错误或者其他无法理解的地方。如果要看数据结构，很详细的数据结构，请移步： 数据结构入门 List 集合我们掌握了 Collection 接口的使用后，再来看看 Collection 接口中的子类，他们都具备那些特性呢？接下来，我们一起学习 Collection 中的常用几个子类（java.util.List集合、java.util.Set集合）。 List接口介绍java.util.List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地会将实现了List接口的对象称为 List 集合。在 List 集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List 集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 看完API，我们总结一下 List 接口特点： 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 tips:我们已经学习过 List 接口的子类 java.util.ArrayList 类，该类中的方法都是来自 List 中定义。 List 中常用方法List 作为 Collection 集合的子接口，不但继承了 Collection 接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下： public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 List集合特有的方法都是跟索引相关，我们已经都学习过，那么我们再来复习一遍吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* java.util.List接口 extends Collection接口 List接口的特点: 1.有序的集合,存储元素和取出元素的顺序是一致的(存储123 取出123) 2.有索引,包含了一些带索引的方法 3.允许存储重复的元素 List接口中带索引的方法(特有) - public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 - public E get(int index):返回集合中指定位置的元素。 - public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 - public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 注意: 操作索引的时候,一定要防止索引越界异常 IndexOutOfBoundsException:索引越界异常,集合会报 ArrayIndexOutOfBoundsException:数组索引越界异常 StringIndexOutOfBoundsException:字符串索引越界异常 */public class Demo01List { public static void main(String[] args) { //创建一个List集合对象,多态 List&lt;String&gt; list = new ArrayList&lt;&gt;(); //使用add方法往集合中添加元素 list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"a\"); //打印集合 System.out.println(list);//[a, b, c, d, a] 不是地址重写了toString //public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 //在c和d之间添加一个itheima list.add(3,\"itheima\");//[a, b, c, itheima, d, a] System.out.println(list); //public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 //移除元素 String removeE = list.remove(2); System.out.println(\"被移除的元素:\"+removeE);//被移除的元素:c System.out.println(list);//[a, b, itheima, d, a] //public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 //把最后一个a,替换为A String setE = list.set(4, \"A\"); System.out.println(\"被替换的元素:\"+setE);//被替换的元素:a System.out.println(list);//[a, b, itheima, d, A] //List集合遍历有3种方式 //使用普通的for循环 for(int i=0; i&lt;list.size(); i++){ //public E get(int index):返回集合中指定位置的元素。 String s = list.get(i); System.out.println(s); } System.out.println(\"-----------------\"); //使用迭代器 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext()){ String s = it.next(); System.out.println(s); } System.out.println(\"-----------------\"); //使用增强for for (String s : list) { System.out.println(s); } String r = list.get(5);//IndexOutOfBoundsException: Index 5 out-of-bounds for length 5 System.out.println(r); }} ArrayList 集合java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。许多程序员开发时非常随意地使用 ArrayList 完成任何需求，并不严谨，这种用法是不提倡的。 想要了解更多的信息，请参阅 API 或者查看他人博客。也可看先前文章：https://guoshizhan.club/JavaSE-02.html LinkedList 集合java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可） 方法演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/* java.util.LinkedList集合 implements List接口 LinkedList集合的特点: 1.底层是一个链表结构:查询慢,增删快 2.里边包含了大量操作首尾元素的方法 注意:使用LinkedList集合特有的方法,不能使用多态 - public void addFirst(E e):将指定元素插入此列表的开头。 - public void addLast(E e):将指定元素添加到此列表的结尾。 - public void push(E e):将元素推入此列表所表示的堆栈。 - public E getFirst():返回此列表的第一个元素。 - public E getLast():返回此列表的最后一个元素。 - public E removeFirst():移除并返回此列表的第一个元素。 - public E removeLast():移除并返回此列表的最后一个元素。 - public E pop():从此列表所表示的堆栈处弹出一个元素。 - public boolean isEmpty()：如果列表不包含元素，则返回true。 */public class Demo02LinkedList { public static void main(String[] args) { show03(); } /* - public E removeFirst():移除并返回此列表的第一个元素。 - public E removeLast():移除并返回此列表的最后一个元素。 - public E pop():从此列表所表示的堆栈处弹出一个元素。此方法相当于 removeFirst */ private static void show03() { //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); System.out.println(linked);//[a, b, c] //String first = linked.removeFirst(); String first = linked.pop(); System.out.println(\"被移除的第一个元素:\"+first); String last = linked.removeLast(); System.out.println(\"被移除的最后一个元素:\"+last); System.out.println(linked);//[b] } /* - public E getFirst():返回此列表的第一个元素。 - public E getLast():返回此列表的最后一个元素。 */ private static void show02() { //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); //linked.clear();//清空集合中的元素 在获取集合中的元素会抛出NoSuchElementException //public boolean isEmpty()：如果列表不包含元素，则返回true。 if(!linked.isEmpty()){ String first = linked.getFirst(); System.out.println(first);//a String last = linked.getLast(); System.out.println(last);//c } } /* - public void addFirst(E e):将指定元素插入此列表的开头。 - public void addLast(E e):将指定元素添加到此列表的结尾。 - public void push(E e):将元素推入此列表所表示的堆栈。此方法等效于 addFirst(E)。 */ private static void show01() { //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); System.out.println(linked);//[a, b, c] //public void addFirst(E e):将指定元素插入此列表的开头。 //linked.addFirst(\"www\"); linked.push(\"www\"); System.out.println(linked);//[www, a, b, c] //public void addLast(E e):将指定元素添加到此列表的结尾。此方法等效于 add() linked.addLast(\"com\"); System.out.println(linked);//[www, a, b, c, com] }} Vector 集合这个集合比较老了，是从 JDK1.0 版本就有的。在此只是去知道它的存在，具体用法差不多，不懂就查 Java 编程手册。 Map 集合Map 概述现实生活中，我们常会看到这样的一种集合：IP 地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java 提供了专门的集合类用来存放这种对象关系的对象，即 java.util.Map 接口。 Map 常用子类通过查看 Map 接口描述，看到 Map 有多个子类，这里我们主要讲解常用的 HashMap 集合、LinkedHashMap 集合。 HashMap：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 LinkedHashMap：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 tips：Map 接口中的集合都有两个泛型变量,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量的数据类型可以相同，也可以不同。 Map 的常用方法Map 的代码演示如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/* java.util.Map&lt;k,v&gt;集合 Map集合的特点: 1.Map集合是一个双列集合,一个元素包含两个值(一个key,一个value) 2.Map集合中的元素,key和value的数据类型可以相同,也可以不同 3.Map集合中的元素,key是不允许重复的,value是可以重复的 4.Map集合中的元素,key和value是一一对应 java.util.HashMap&lt;k,v&gt;集合 implements Map&lt;k,v&gt;接口 HashMap集合的特点: 1.HashMap集合底层是哈希表:查询的速度特别的快 JDK1.8之前:数组+单向链表 JDK1.8之后:数组+单向链表|红黑树(链表的长度超过8):提高查询的速度 2.hashMap集合是一个无序的集合,存储元素和取出元素的顺序有可能不一致 java.util.LinkedHashMap&lt;k,v&gt;集合 extends HashMap&lt;k,v&gt;集合 LinkedHashMap的特点: 1.LinkedHashMap集合底层是哈希表+链表(保证迭代的顺序) 2.LinkedHashMap集合是一个有序的集合,存储元素和取出元素的顺序是一致的 */public class Demo01Map { public static void main(String[] args) { show04(); } /* boolean containsKey(Object key) 判断集合中是否包含指定的键。 包含返回true,不包含返回false */ private static void show04() { //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); boolean b1 = map.containsKey(\"赵丽颖\"); System.out.println(\"b1:\"+b1);//b1:true boolean b2 = map.containsKey(\"赵颖\"); System.out.println(\"b2:\"+b2);//b2:false } /* public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 返回值: key存在,返回对应的value值 key不存在,返回null */ private static void show03() { //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); Integer v1 = map.get(\"杨颖\"); System.out.println(\"v1:\"+v1);//v1:165 Integer v2 = map.get(\"迪丽热巴\"); System.out.println(\"v2:\"+v2);//v2:null } /* public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 返回值:V key存在,v返回被删除的值 key不存在,v返回null */ private static void show02() { //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); System.out.println(map);//{林志玲=178, 赵丽颖=168, 杨颖=165} Integer v1 = map.remove(\"林志玲\"); System.out.println(\"v1:\"+v1);//v1:178 System.out.println(map);//{赵丽颖=168, 杨颖=165} //int v2 = map.remove(\"林志颖\");//自动拆箱 NullPointerException Integer v2 = map.remove(\"林志颖\"); System.out.println(\"v2:\"+v2);//v2:null System.out.println(map);//{赵丽颖=168, 杨颖=165} } /* public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 返回值:v 存储键值对的时候,key不重复,返回值V是null 存储键值对的时候,key重复,会使用新的value替换map中重复的value,返回被替换的value值 */ private static void show01() { //创建Map集合对象,多态 Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); String v1 = map.put(\"李晨\", \"范冰冰1\"); System.out.println(\"v1:\"+v1);//v1:null String v2 = map.put(\"李晨\", \"范冰冰2\"); System.out.println(\"v2:\"+v2);//v2:范冰冰1 System.out.println(map);//{李晨=范冰冰2} map.put(\"冷锋\",\"龙小云\"); map.put(\"杨过\",\"小龙女\"); map.put(\"尹志平\",\"小龙女\"); System.out.println(map);//{杨过=小龙女, 尹志平=小龙女, 李晨=范冰冰2, 冷锋=龙小云} }} tips:使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中；若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 Map 遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* Map集合的第一种遍历方式:通过键找值的方式 Map集合中的方法: Set&lt;K&gt; keySet() 返回此映射中包含的键的 Set 视图。 实现步骤: 1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中 2.遍历set集合,获取Map集合中的每一个key 3.通过Map集合中的方法get(key),通过key找到value */public class Demo02KeySet { public static void main(String[] args) { //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); //1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中 Set&lt;String&gt; set = map.keySet(); //2.遍历set集合,获取Map集合中的每一个key //使用迭代器遍历Set集合 Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()){ String key = it.next(); //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); } System.out.println(\"-------------------\"); //使用增强for遍历Set集合 for(String key : set){ //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); } System.out.println(\"-------------------\"); //使用增强for遍历Set集合 for(String key : map.keySet()){ //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); } }} Entry键值对对象1234567891011121314151617181920212223242526272829303132333435363738394041/* Map集合遍历的第二种方式:使用Entry对象遍历 Map集合中的方法: Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的 Set 视图。 实现步骤: 1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中 2.遍历Set集合,获取每一个Entry对象 3.使用Entry对象中的方法getKey()和getValue()获取键与值 */public class Demo03EntrySet { public static void main(String[] args) { //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); //1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet(); //2.遍历Set集合,获取每一个Entry对象 //使用迭代器遍历Set集合 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = set.iterator(); while(it.hasNext()){ Map.Entry&lt;String, Integer&gt; entry = it.next(); //3.使用Entry对象中的方法getKey()和getValue()获取键与值 String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key+\"=\"+value); } System.out.println(\"-----------------------\"); for(Map.Entry&lt;String,Integer&gt; entry:set){ //3.使用Entry对象中的方法getKey()和getValue()获取键与值 String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key+\"=\"+value); } }} HashMap 存储自定义类型键值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(name, age); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* HashMap存储自定义类型键值 Map集合保证key是唯一的: 作为key的元素,必须重写hashCode方法和equals方法,以保证key唯一 */public class Demo01HashMapSavePerson { public static void main(String[] args) { show02(); } /* HashMap存储自定义类型键值 key:Person类型 Person类就必须重写hashCode方法和equals方法,以保证key唯一 value:String类型 可以重复 */ private static void show02() { //创建HashMap集合 HashMap&lt;Person,String&gt; map = new HashMap&lt;&gt;(); //往集合中添加元素 map.put(new Person(\"女王\",18),\"英国\"); map.put(new Person(\"秦始皇\",18),\"秦国\"); map.put(new Person(\"普京\",30),\"俄罗斯\"); map.put(new Person(\"女王\",18),\"毛里求斯\"); //使用entrySet和增强for遍历Map集合 Set&lt;Map.Entry&lt;Person, String&gt;&gt; set = map.entrySet(); for (Map.Entry&lt;Person, String&gt; entry : set) { Person key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\"--&gt;\"+value); } } /* HashMap存储自定义类型键值 key:String类型 String类重写hashCode方法和equals方法,可以保证key唯一 value:Person类型 value可以重复(同名同年龄的人视为同一个) */ private static void show01() { //创建HashMap集合 HashMap&lt;String,Person&gt; map = new HashMap&lt;&gt;(); //往集合中添加元素 map.put(\"北京\",new Person(\"张三\",18)); map.put(\"上海\",new Person(\"李四\",19)); map.put(\"广州\",new Person(\"王五\",20)); map.put(\"北京\",new Person(\"赵六\",18)); //使用keySet加增强for遍历Map集合 Set&lt;String&gt; set = map.keySet(); for (String key : set) { Person value = map.get(key); System.out.println(key+\"--&gt;\"+value); } }} LinkedHashMap我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。 1234567891011121314151617181920212223/* java.util.LinkedHashMap&lt;K,V&gt; entends HashMap&lt;K,V&gt; Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。 底层原理: 哈希表+链表(记录元素的顺序) */public class Demo01LinkedHashMap { public static void main(String[] args) { HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(\"a\",\"a\"); map.put(\"c\",\"c\"); map.put(\"b\",\"b\"); map.put(\"a\",\"d\"); System.out.println(map);// key不允许重复,无序 {a=d, b=b, c=c} LinkedHashMap&lt;String,String&gt; linked = new LinkedHashMap&lt;&gt;(); linked.put(\"a\",\"a\"); linked.put(\"c\",\"c\"); linked.put(\"b\",\"b\"); linked.put(\"a\",\"d\"); System.out.println(linked);// key不允许重复,有序 {a=d, c=c, b=b} }} 123456789101112131415161718192021222324252627/* java.util.Hashtable&lt;K,V&gt;集合 implements Map&lt;K,V&gt;接口 Hashtable:底层也是一个哈希表,是一个线程安全的集合,是单线程集合,速度慢 HashMap:底层是一个哈希表,是一个线程不安全的集合,是多线程的集合,速度快 HashMap集合(之前学的所有的集合):可以存储null值,null键 Hashtable集合,不能存储null值,null键 Hashtable和Vector集合一样,在jdk1.2版本之后被更先进的集合(HashMap,ArrayList)取代了 Hashtable的子类Properties依然活跃在历史舞台 Properties集合是一个唯一和IO流相结合的集合 */public class Demo02Hashtable { public static void main(String[] args) { HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(null,\"a\"); map.put(\"b\",null); map.put(null,null); System.out.println(map);//{null=null, b=null} Hashtable&lt;String,String&gt; table = new Hashtable&lt;&gt;(); //table.put(null,\"a\");//NullPointerException //table.put(\"b\",null);//NullPointerException table.put(null,null);//NullPointerException }} 12 Map集合练习123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 练习: 计算一个字符串中每个字符出现次数 分析: 1.使用Scanner获取用户输入的字符串 2.创建Map集合,key是字符串中的字符,value是字符的个数 3.遍历字符串,获取每一个字符 4.使用获取到的字符,去Map集合判断key是否存在 key存在: 通过字符(key),获取value(字符个数) value++ put(key,value)把新的value存储到Map集合中 key不存在: put(key,1) 5.遍历Map集合,输出结果 */public class Demo03MapTest { public static void main(String[] args) { //1.使用Scanner获取用户输入的字符串 Scanner sc = new Scanner(System.in); System.out.println(\"请输入一个字符串:\"); String str = sc.next(); //2.创建Map集合,key是字符串中的字符,value是字符的个数 HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); //3.遍历字符串,获取每一个字符 for(char c :str.toCharArray()){ //4.使用获取到的字符,去Map集合判断key是否存在 if(map.containsKey(c)){ //key存在 Integer value = map.get(c); value++; map.put(c,value); }else{ //key不存在 map.put(c,1); } } //5.遍历Map集合,输出结果 for(Character key :map.keySet()){ Integer value = map.get(key); System.out.println(key+\"=\"+value); } }} JDK9 新特性12345678910111213141516171819202122232425262728/* JDK9的新特性: List接口,Set接口,Map接口:里边增加了一个静态的方法of,可以给集合一次性添加多个元素 static &lt;E&gt; List&lt;E&gt; of​(E... elements) 使用前提: 当集合中存储的元素的个数已经确定了,不在改变时使用 注意: 1.of方法只适用于List接口,Set接口,Map接口,不适用于接接口的实现类 2.of方法的返回值是一个不能改变的集合,集合不能再使用add,put方法添加元素,会抛出异常 3.Set接口和Map接口在调用of方法的时候,不能有重复的元素,否则会抛出异常 */public class Demo01JDK9 { public static void main(String[] args) { List&lt;String&gt; list = List.of(\"a\", \"b\", \"a\", \"c\", \"d\"); System.out.println(list);//[a, b, a, c, d] //list.add(\"w\");//UnsupportedOperationException:不支持操作异常 //Set&lt;String&gt; set = Set.of(\"a\", \"b\", \"a\", \"c\", \"d\");//IllegalArgumentException:非法参数异常,有重复的元素 Set&lt;String&gt; set = Set.of(\"a\", \"b\", \"c\", \"d\"); System.out.println(set); //set.add(\"w\");//UnsupportedOperationException:不支持操作异常 //Map&lt;String, Integer&gt; map = Map.of(\"张三\", 18, \"李四\", 19, \"王五\", 20,\"张三\",19);////IllegalArgumentException:非法参数异常,有重复的元素 Map&lt;String, Integer&gt; map = Map.of(\"张三\", 18, \"李四\", 19, \"王五\", 20); System.out.println(map);//{王五=20, 李四=19, 张三=18} //map.put(\"赵四\",30);//UnsupportedOperationException:不支持操作异常 }} Debug 调试1234567891011121314151617181920212223242526272829303132333435363738/* Debug调试程序: 可以让代码逐行执行,查看代码执行的过程,调试程序中出现的bug 使用方式: 在行号的右边,鼠标左键单击,添加断点(每个方法的第一行,哪里有bug添加到哪里) 右键,选择Debug执行程序 程序就会停留在添加的第一个断点处 执行程序: f8:逐行执行程序 f7:进入到方法中 shift+f8:跳出方法 f9:跳到下一个断点,如果没有下一个断点,那么就结束程序 ctrl+f2:退出debug模式,停止程序 Console:切换到控制台 */public class Demo01Debug { public static void main(String[] args) { /*int a = 10; int b = 20; int sum = a + b; System.out.println(sum);*/ /*for (int i = 0; i &lt;3 ; i++) { System.out.println(i); }*/ print(); } private static void print() { System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); }} 斗地主案例(双列)案例介绍按照斗地主的规则，完成洗牌发牌的动作。具体规则如下： 组装 54 张扑克牌将 54 张牌顺序打乱 三个玩家参与游戏，三人交替摸牌，每人 17 张牌，最后三张留作底牌。 查看三人各自手中的牌（按照牌的大小排序）、底牌 规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3 案例分析 准备牌：完成数字与纸牌的映射关系：使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。 洗牌：通过数字完成洗牌发牌 发牌：将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。存放的过程中要求数字大小与斗地主规则的大小对应。将代表不同纸牌的数字分配给不同的玩家与底牌。 看牌：通过Map集合找到对应字符展示。通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/* 斗地主综合案例:有序版本 1.准备牌 2.洗牌 3.发牌 4.排序 5.看牌 */public class DouDiZhu { public static void main(String[] args) { //1.准备牌 //创建一个Map集合,存储牌的索引和组装好的牌 HashMap&lt;Integer,String&gt; poker = new HashMap&lt;&gt;(); //创建一个List集合,存储牌的索引 ArrayList&lt;Integer&gt; pokerIndex = new ArrayList&lt;&gt;(); //定义两个集合,存储花色和牌的序号 List&lt;String&gt; colors = List.of(\"♠\", \"♥\", \"♣\", \"♦\"); List&lt;String&gt; numbers = List.of(\"2\", \"A\", \"K\", \"Q\", \"J\", \"10\", \"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\"); //把大王和小王存储到集合中 //定义一个牌的索引 int index = 0; poker.put(index,\"大王\"); pokerIndex.add(index); index++; poker.put(index,\"小王\"); pokerIndex.add(index); index++; //循环嵌套遍历两个集合,组装52张牌,存储到集合中 for (String number : numbers) { for (String color : colors) { poker.put(index,color+number); pokerIndex.add(index); index++; } } //System.out.println(poker); //System.out.println(pokerIndex); /* 2.洗牌 使用Collections中的方法shuffle(List) */ Collections.shuffle(pokerIndex); //System.out.println(pokerIndex); /* 3.发牌 */ //定义4个集合,存储玩家牌的索引,和底牌的索引 ArrayList&lt;Integer&gt; player01 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; player02 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; player03 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; diPai = new ArrayList&lt;&gt;(); //遍历存储牌索引的List集合,获取每一个牌的索引 for (int i = 0; i &lt;pokerIndex.size() ; i++) { Integer in = pokerIndex.get(i); //先判断底牌 if(i&gt;=51){ //给底牌发牌 diPai.add(in); }else if(i%3==0){ //给玩家1发牌 player01.add(in); }else if(i%3==1){ //给玩家2发牌 player02.add(in); }else if(i%3==2){ //给玩家3发牌 player03.add(in); } } /* 4.排序 使用Collections中的方法sort(List) 默认是升序排序 */ Collections.sort(player01); Collections.sort(player02); Collections.sort(player03); Collections.sort(diPai); /* 5.看牌 调用看牌的方法 */ lookPoker(\"刘德华\",poker,player01); lookPoker(\"周润发\",poker,player02); lookPoker(\"周星驰\",poker,player03); lookPoker(\"底牌\",poker,diPai); } /* 定义一个看牌的方法,提高代码的复用性 参数: String name:玩家名称 HashMap&lt;Integer,String&gt; poker:存储牌的poker集合 ArrayList&lt;Integer&gt; list:存储玩家和底牌的List集合 查表法: 遍历玩家或者底牌集合,获取牌的索引 使用牌的索引,去Map集合中,找到对应的牌 */ public static void lookPoker(String name,HashMap&lt;Integer,String&gt; poker,ArrayList&lt;Integer&gt; list){ //输出玩家名称,不换行 System.out.print(name+\":\"); //遍历玩家或者底牌集合,获取牌的索引 for (Integer key : list) { //使用牌的索引,去Map集合中,找到对应的牌 String value = poker.get(key); System.out.print(value+\" \"); } System.out.println();//打印完每一个玩家的牌,换行 }} 异常处理异常概念异常 ：就是不正常的意思，指的是程序在执行过程中，出现的非正常的情况，最终会导致 JVM 的非正常停止。在 Java 等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java 处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行。 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是 java.lang.Throwable ，其下有两个子类：java.lang.Error 与 java.lang.Exception ，平常所说的异常指 java.lang.Exception 。如下图： Throwable 常用方法以下三个方法都是为了获取异常信息： public void printStackTrace() : 打印异常的详细信息。包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用 printStackTrace。public String getMessage():获取发生异常的原因。提示给用户的时候,就提示错误原因。public String toString():获取异常的类型和异常描述信息(不用)。 异常分类 编译时期异常 : checked 异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)运行时期异常 : runtime 异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) 异常处理Java异常处理的五个关键字：try、catch、finally、throw、throws 抛出异常 throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。在 java 中，提供了一个 throw 关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 1、创建一个异常对象。封装一些提示信息(信息可以自己编写)。 2、需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字 throw 就可以完成。throw 异常对象。throw 用在方法内 ，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： 1throw new 异常类名(参数); 例如： 123throw new NullPointerException(\"要访问的arr数组不存在\");throw new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\"); 学习完抛出异常的格式后，我们通过下面程序演示下 throw 的使用。 12345678910111213141516171819202122public class ThrowDemo { public static void main(String[] args) { // 创建一个数组 int[] arr = {2,4,52,2}; // 根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println(\"over\"); } // 根据 索引找到数组中对应的元素 public static int getElement(int[] arr,int index){ // 判断索引是否越界 if(index&lt;0 || index&gt;arr.length-1){ // 判断条件如果满足，当执行完 throw 抛出异常对象后，方法已经无法继续运算。这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 throw new ArrayIndexOutOfBoundsException(\"哥们，角标越界了~~~\"); } int element = arr[index]; return element; }} 注意：如果产生了问题，我们就会 throw 将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用 throws 声明处理。 声明异常 throws声明异常：将问题标识出来，报告给调用者。如果方法内通过 throw 抛出了编译时异常，而没有捕获处理（下面讲解该方式），那么必须通过 throws 进行声明，让调用者去处理。关键字 throws 运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{ } 声明异常的代码演示： 12345678910111213public class ThrowsDemo { public static void main(String[] args) throws FileNotFoundException { read(\"a.txt\"); } // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException { if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); } }} throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 123456789101112131415public class ThrowsDemo2 { public static void main(String[] args) throws IOException { read(\"a.txt\"); } public static void read(String path)throws FileNotFoundException, IOException { if (!path.equals(\"a.txt\")) { // 如果不是 a.txt这个文件 // 如果不是 a.txt ，认为该文件不存在，是一个异常 throw throw new FileNotFoundException(\"文件不存在\"); } if (!path.equals(\"b.txt\")) { throw new IOException(); } }} 捕获异常 try_catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 1、该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 2、如果要处理，那就在方法中使用 try-catch 的语句块来捕获异常。 try-catch 的方式就是捕获异常【Java 中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理】，语法如下： 123456try{ 编写可能会出现异常的代码}catch(异常类型 e){ 处理异常的代码 // 记录日志/打印异常信息/继续抛出异常} try：在该代码块中，编写可能产生异常的代码。catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。注意 : try 和 catch 都不能单独使用,必须连用。 演示如下： 1234567891011121314151617public class TryCatchDemo { public static void main(String[] args) { try { // 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(\"b.txt\"); } catch (FileNotFoundException e) { // 括号中需要定义什么呢？ // try 中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); } System.out.println(\"over\"); } // 当前的这个方法中有异常 有编译期异常 public static void read(String path) throws FileNotFoundException { if (!path.equals(\"a.txt\")) { throw new FileNotFoundException(\"文件不存在\"); } }} finally 代码块finally ：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而 finally 就是解决这个问题的，在 finally 代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？当我们在 try 语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally 的语法 : try…catch….finally:自身需要处理异常,最终还得关闭资源。 finally 代码参考如下： 12345678910111213141516171819public class TryCatchDemo4 { public static void main(String[] args) { try { read(\"a.txt\"); } catch (FileNotFoundException e) { // 抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); } finally { System.out.println(\"不管程序怎样，这里都将会被执行。\"); } System.out.println(\"over\"); } public static void read(String path) throws FileNotFoundException { if (!path.equals(\"a.txt\")) { throw new FileNotFoundException(\"文件不存在\"); } }} 注意事项：1、 finally 不能单独使用。2、 当只有在 try 或者 catch 中调用退出 JVM 的相关方法,此时 finally 才不会执行,否则 finally 永远会执行。 异常注意事项 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： 123456789try{ // 编写可能会出现异常的代码}catch(异常类型A e){ // 当try中出现A类型异常,就用该catch来捕获. // 处理异常的代码 // 记录日志/打印异常信息/继续抛出异常}catch(异常类型B e){ // 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 // 记录日志/打印异常信息/继续抛出异常} 注意事项： 1、这种异常处理方式，要求多个 catch 中的异常不能相同，并且若 catch 中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的 catch 处理，父类异常在下面的 catch 处理。2、运行时异常被抛出可以不处理。即不捕获也不声明抛出。3、如果 finally 有 return 语句,永远返回 finally 中的结果,避免该情况。4、如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。5、父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。 自定义异常自定义异常概述为什么需要自定义异常类: 我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: RegisterException。一个注册异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类并继承于 java.lang.Exception 。 自定义一个运行时期的异常类:自定义类 并继承于 java.lang.RuntimeException 。 自定义异常的练习要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类 RegisterException： 1234567891011// 业务逻辑异常public class RegisterException extends Exception { // 空参构造 public RegisterException() { } // @param message 表示异常提示 public RegisterException(String message) { super(message); }} 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 123456789101112131415161718192021222324252627public class Demo { // 模拟数据库中已存在账号 private static String[] names = {\"bill\",\"hill\",\"jill\"}; public static void main(String[] args) { // 调用方法 try{ // 可能出现异常的代码 checkUsername(\"nill\"); System.out.println(\"注册成功\");//如果没有异常就是注册成功 }catch(RegisterException e){ // 处理异常 e.printStackTrace(); } } // 判断当前注册账号是否存在 // 因为是编译期异常，又想调用者去处理 所以声明该异常 public static boolean checkUsername(String uname) throws LoginException{ for (String name : names) { if(name.equals(uname)){ // 如果名字在这里面 就抛出登陆异常 throw new RegisterException(\"亲\" + name + \"已经被注册了！\"); } } return true; }} 多线程了解概念并发和并行 并发：指两个或多个事件在同一个时间段内发生。例如：一个手机同时玩王者和吃鸡，只能交替进行。并行：指两个或多个事件在同一时刻发生（同时发生）。例如：边打游戏边听歌，同时进行。 在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 线程调度: 分时调度 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 设置线程的优先级 抢占式调度详解 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 多线程原理 常用方法 设置线程的名称 多线程休眠方法有点意思，每隔一秒执行，打印一分钟 Runnable接口创建线程对象 Runnable接口创建线程对象和thread创建对象的区别 线程安全 买票重复，出现-1 解决线程安全的三种方法 线程池线程池介绍涉及到一个概念，面向接口编程，就是返回对象是接口类型，不用管接口的实现类 concurrent executors Lambda 表达式函数式编程思想概述 在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以什么形式做。 面向对象的思想:做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情. 函数式编程思想:只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程 冗余的 Runnable 代码传统写法当需要启动一个线程去完成任务时，通常会通过java.lang.Runnable接口来定义任务内容，并使用java.lang.Thread类来启动该线程。代码如下： 123456789101112public class Demo01Runnable { public static void main(String[] args) { // 匿名内部类 Runnable task = new Runnable() { @Override public void run() { // 覆盖重写抽象方法 System.out.println(\"多线程任务执行！\"); } }; new Thread(task).start(); // 启动线程 }} 本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个Runnable接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。 代码分析对于Runnable的匿名内部类用法，可以分析出几点内容： Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心； 为了指定run的方法体，不得不需要Runnable接口的实现类； 为了省去定义一个RunnableImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 而实际上，似乎只有方法体才是关键所在。 编程思想转换做什么，而不是怎么做我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而不得不创建一个对象。我们真正希望做的事情是：将run方法体内的代码传递给Thread类知晓。 传递一段代码——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。 生活举例当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。 而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了Lambda表达式的重量级新特性，为我们打开了新世界的大门。 体验Lambda的更优写法借助Java 8的全新语法，上述Runnable接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效： 12345public class Demo02LambdaRunnable { public static void main(String[] args) { new Thread(() -&gt; System.out.println(\"多线程任务执行！\")).start(); // 启动线程 }} 这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。 不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！ 回顾匿名内部类Lambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容： 1() -&gt; System.out.println(\"多线程任务执行！\") 为了理解Lambda的语义，我们需要从传统的代码起步。 使用实现类要启动一个线程，需要创建一个Thread类的对象并调用start方法。而为了指定线程执行的内容，需要调用Thread类的构造方法： public Thread(Runnable target) 为了获取Runnable接口的实现对象，可以为该接口定义一个实现类RunnableImpl： 123456public class RunnableImpl implements Runnable { @Override public void run() { System.out.println(\"多线程任务执行！\"); }} 然后创建该实现类的对象作为Thread类的构造参数： 123456public class Demo03ThreadInitParam { public static void main(String[] args) { Runnable task = new RunnableImpl(); new Thread(task).start(); }} 使用匿名内部类这个RunnableImpl类只是为了实现Runnable接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类： 12345678910public class Demo04ThreadNameless { public static void main(String[] args) { new Thread(new Runnable() { @Override public void run() { System.out.println(\"多线程任务执行！\"); } }).start(); }} 匿名内部类的好处与弊端一方面，匿名内部类可以帮我们省去实现类的定义；另一方面，匿名内部类的语法——确实太复杂了！ 语义分析仔细分析该代码中的语义，Runnable接口只有一个run方法的定义： public abstract void run(); 即制定了一种做事情的方案（其实就是一个函数）： 无参数：不需要任何条件即可执行该方案。 无返回值：该方案不产生任何结果。 代码块（方法体）：该方案的具体执行步骤。 同样的语义体现在Lambda语法中，要更加简单： 1() -&gt; System.out.println(\"多线程任务执行！\") 前面的一对小括号即run方法的参数（无），代表不需要任何条件； 中间的一个箭头代表将前面的参数传递给后面的代码； 后面的输出语句即业务逻辑代码。 Lambda标准格式Lambda省去面向对象的条条框框，格式由3个部分组成： 一些参数 一个箭头 一段代码 Lambda表达式的标准格式为： 1(参数类型 参数名称) -&gt; { 代码语句 } 格式说明： 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。 -&gt;是新引入的语法格式，代表指向动作。 大括号内的语法与传统方法体要求基本一致。 练习：使用Lambda标准格式（无参无返回）题目给定一个厨子Cook接口，内含唯一的抽象方法makeFood，且无参数、无返回值。如下： 123public interface Cook { void makeFood();} 在下面的代码中，请使用Lambda的标准格式调用invokeCook方法，打印输出“吃饭啦！”字样： 123456789public class Demo05InvokeCook { public static void main(String[] args) { // TODO 请在此使用Lambda【标准格式】调用invokeCook方法 } private static void invokeCook(Cook cook) { cook.makeFood(); }} 解答12345public static void main(String[] args) { invokeCook(() -&gt; { System.out.println(\"吃饭啦！\"); });} 备注：小括号代表Cook接口makeFood抽象方法的参数为空，大括号代表makeFood的方法体。 Lambda的参数和返回值123需求: 使用数组存储多个Person对象 对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序 下面举例演示java.util.Comparator&lt;T&gt;接口的使用场景代码，其中的抽象方法定义为： public abstract int compare(T o1, T o2); 当需要对一个对象数组进行排序时，Arrays.sort方法需要一个Comparator接口实例来指定排序的规则。假设有一个Person类，含有String name和int age两个成员变量： 123456public class Person { private String name; private int age; // 省略构造器、toString方法与Getter Setter } 传统写法如果使用传统的代码对Person[]数组进行排序，写法如下： 12345678910111213141516171819202122232425import java.util.Arrays;import java.util.Comparator;public class Demo06Comparator { public static void main(String[] args) { // 本来年龄乱序的对象数组 Person[] array = { new Person(\"古力娜扎\", 19), new Person(\"迪丽热巴\", 18), new Person(\"马尔扎哈\", 20) }; // 匿名内部类 Comparator&lt;Person&gt; comp = new Comparator&lt;Person&gt;() { @Override public int compare(Person o1, Person o2) { return o1.getAge() - o2.getAge(); } }; Arrays.sort(array, comp); // 第二个参数为排序规则，即Comparator接口实例 for (Person person : array) { System.out.println(person); } }} 这种做法在面向对象的思想中，似乎也是“理所当然”的。其中Comparator接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。 代码分析下面我们来搞清楚上述代码真正要做什么事情。 为了排序，Arrays.sort方法需要排序规则，即Comparator接口的实例，抽象方法compare是关键； 为了指定compare的方法体，不得不需要Comparator接口的实现类； 为了省去定义一个ComparatorImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象compare方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 实际上，只有参数和方法体才是关键。 Lambda写法123456789101112131415161718import java.util.Arrays;public class Demo07ComparatorLambda { public static void main(String[] args) { Person[] array = { new Person(\"古力娜扎\", 19), new Person(\"迪丽热巴\", 18), new Person(\"马尔扎哈\", 20) }; Arrays.sort(array, (Person a, Person b) -&gt; { return a.getAge() - b.getAge(); }); for (Person person : array) { System.out.println(person); } }} 练习：使用Lambda标准格式（有参有返回）题目给定一个计算器Calculator接口，内含抽象方法calc可以将两个int数字相加得到和值： 123public interface Calculator { int calc(int a, int b);} 在下面的代码中，请使用Lambda的标准格式调用invokeCalc方法，完成120和130的相加计算： 12345678910public class Demo08InvokeCalc { public static void main(String[] args) { // TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß } private static void invokeCalc(int a, int b, Calculator calculator) { int result = calculator.calc(a, b); System.out.println(\"结果是：\" + result); }} 解答12345public static void main(String[] args) { invokeCalc(120, 130, (int a, int b) -&gt; { return a + b; });} 备注：小括号代表 Calculator 接口 calc 抽象方法的参数，大括号代表calc的方法体。 Lambda 省略格式可推导即可省略Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法： 123public static void main(String[] args) { invokeCalc(120, 130, (a, b) -&gt; a + b);} 省略规则在Lambda标准格式的基础上，使用省略写法的规则为： 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。 练习：使用 Lambda 省略格式题目仍然使用前文含有唯一 makeFood 抽象方法的厨子 Cook 接口，在下面的代码中，请使用 Lambda 的省略格式调用 invokeCook 方法，打印输出“吃饭啦！”字样： 123456789public class Demo09InvokeCook { public static void main(String[] args) { // TODO 请在此使用Lambda【省略格式】调用invokeCook方法 } private static void invokeCook(Cook cook) { cook.makeFood(); }} 解答123public static void main(String[] args) { invokeCook(() -&gt; System.out.println(\"吃饭啦！\"));} Lambda 的使用前提Lambda 的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 使用 Lambda 必须具有接口，且要求接口中有且仅有一个抽象方法。无论是 JDK 内置的 Runnable 、Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用 Lambda。 使用 Lambda 必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为“函数式接口”。 Java 中的 IO 流 IO 流知识 由于本篇过长，IO 流独立成篇：Java 中的 IO 流","link":"/JavaSE-03.html"},{"title":"Java 基础（尾篇）","text":"内容概要： 网络编程入门 函数式编程 基础加强 网络编程入门软件结构C/S 结构C/S 结构 全称为 Client/Server 结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。结构如下图： B/S 结构B/S 结构 全称为 Browser/Server 结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。结构如下图： 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。从而有了网络编程这个概念。网络编程：就是在一定的协议下，实现两台计算机的通信的程序。 网络通信协议 网络通信协议： 通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则。这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。 TCP/IP 协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)是 Internet 中最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都需要它的下一层所提供的协议来完成自己的需求。 上图中，TCP/IP 协议中的四层分别是 应用层、传输层、网络层和链路层 ，每层分别负责不同的通信功能。 链路层： 链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。 网络层： 网络层是整个 TCP/IP 协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。 传输层： 主要使网络程序进行通信，在进行网络通信时，可以采用 TCP 协议，也可以采用 UDP 协议。 应用层： 主要负责应用程序的协议，例如 HTTP 协议、FTP 协议等。 协议分类通信的协议是比较复杂的，java.net 包中的类和接口，它们提供低层次的通信细节。所以我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。java.net 包中提供了两种常见的网络协议的支持： UDP 协议： UDP 协议即用户数据报协议(User Datagram Protocol)，是面向无连接的通信协议。即在数据传输时，数据的发送端和接收端都不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。由于使用 UDP 协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用 UDP 协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用 UDP 协议传送数据时，由于 UDP 的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用 UDP 协议。 UDP 的交换过程如下图所示： UDP 协议特点: 数据被限制在 64kb 以内，超出这个范围就不能发送了。 数据报(Datagram): 网络传输的基本单位。 TCP 协议： TCP 协议即传输控制协议 (Transmission Control Protocol)，是面向连接的通信协议。即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 在 TCP 连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过 &quot;三次握手&quot; ：即 TCP 协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 三次握手： 第一次握手：客户端向服务器端发出连接请求，等待服务器确认。 第二次握手：服务器端向客户端回送一个响应，通知客户端收到了连接请求。 第三次握手：客户端再次向服务器端发送确认信息，确认连接。 三次握手 的整个交互过程如下图所示： 完成三次握手并连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP 协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。 网络编程三要素协议 协议： 协议：计算机网络通信必须遵守的规则称之为协议。 IP地址IP地址： 指互联网协议地址（Internet Protocol Address），俗称 IP 。IP 地址用来给一个网络中的计算机设备做唯一的编号。假如我们把 个人电脑 比作 一台手机 的话，那么 IP 地址 就相当于 电话号码 。IP 地址分类有如下两种： IPv4： IPv4 是一个 32 位的二进制数，通常被分为 4 个字节，表示成 `a.b.c.d` 的形式，例如 `192.168.65.100` 。其中 a、b、c、d 都是 0~255 之间的十进制整数，那么最多可以表示 42 亿个。 IPv6： 由于互联网的蓬勃发展，IP 地址的需求量愈来愈大，但是网络地址资源有限，使得 IP 的分配越发紧张。为了扩大地址空间，拟通过 IPv6 重新定义地址空间，采用 128 位地址长度，每 16 个字节一组，分成 8 组十六进制数，IPV6 具体的表示方法如下所示： `ABCD:EF01:2345:6789:ABCD:EF01:2345:6789` ，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。 一些相关的常用命令： 123456# 查看本机IP地址，在控制台输入ipconfig# 检查网络是否连通，在控制台输入ping 空格 IP地址ping 220.181.57.216 特殊的IP地址： 本机IP地址：127.0.0.1 、localhost 。 端口号网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？如果说 IP 地址 可以唯一标识网络中的设备，那么 端口号 就可以唯一标识设备中的进程（应用程序）了。 端口号： 用两个字节表示的整数，它的取值范围是 0~65535 。其中，0~1023 之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用 1024 以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。 利用 协议 + IP地址 + 端口号 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。 TCP 通信程序 TCP 通信概述TCP 通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。 两端通信时步骤： 1、服务端程序，需要事先启动，等待客户端的连接。 2、客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。 在 Java 中，提供了两个类用于实现TCP通信程序： 1、客户端：java.net.Socket 类表示。创建 Socket 对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。 2、服务端：java.net.ServerSocket 类表示。创建 ServerSocket 对象，相当于开启一个服务，并等待客户端的连接。 Socket 类Socket 类： 该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。 构造方法： 1、方法：public Socket(String host, int port) 2、作用：创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的 host 是 null ，则相当于指定地址为回送地址。 小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。 成员方法： 1、public InputStream getInputStream() ： 返回此套接字的输入流。 &nbsp;&nbsp;&nbsp;&nbsp;如果此 Scoket 具有相关联的通道，则生成的 InputStream 的所有操作也关联该通道。 &nbsp;&nbsp;&nbsp;&nbsp;关闭生成的 InputStream 也将关闭相关的 Socket。 2、public OutputStream getOutputStream() ： 返回此套接字的输出流。 &nbsp;&nbsp;&nbsp;&nbsp;如果此 Scoket 具有相关联的通道，则生成的 OutputStream 的所有操作也关联该通道。 &nbsp;&nbsp;&nbsp;&nbsp;关闭生成的 OutputStream 也将关闭相关的 Socket。 3、public void close() ：关闭此套接字。 &nbsp;&nbsp;&nbsp;&nbsp;一旦一个 socket 被关闭，它不可再使用。关闭此socket也将关闭相关的 InputStream 和 OutputStream 。 4、public void shutdownOutput() ： 禁用此套接字的输出流。任何先前写出的数据将被发送，随后终止输出流。 ServerSocket 类ServerSocket 类： 这个类实现了服务器套接字，该对象等待通过网络的请求。 构造方法： 1、方法：public ServerSocket(int port) 2、作用：使用该构造方法在创建 ServerSocket 对象时，就可以将其绑定到一个指定的端口号上，参数 port 就是端口号。 成员方法： 1、方法：public Socket accept() 2、作用：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 简单的TCP网络程序 TCP 通信步骤分析： 1、【服务端】启动,创建 ServerSocket 对象，等待连接。 2、【客户端】启动,创建 Socket 对象，请求连接。 3、【服务端】接收连接,调用 accept 方法，并返回一个 Socket 对象。 4、【客户端】Socket 对象，获取 OutputStream，向服务端写出数据。 5、【服务端】Scoket 对象，获取 InputStream，读取客户端发送的数据。 到此为止，客户端向服务端发送数据成功。接下来，服务端将向客户端回写数据。 TCP 服务器端回写数据： 6、【服务端】Socket 对象，获取 OutputStream，向客户端回写数据。 7、【客户端】Scoket 对象，获取 InputStream，解析回写数据。 8、【客户端】释放资源，断开连接。 客户端向服务器发送数据服务端实现代码如下： 123456789101112131415161718192021public static void main(String[] args) throws IOException { System.out.println(\"服务端启动 , 等待连接 .... \"); // 1、创建 ServerSocket 对象，绑定端口，开始等待连接 ServerSocket server = new ServerSocket(6666); // 2、接收连接 accept 方法, 返回 socket 对象. Socket socket = server.accept(); // 3、通过 socket 获取输入流 InputStream is = socket.getInputStream(); // 4、一次性读取数据 byte[] bytes = new byte[1024]; int len = is.read(bytes)； String msg = new String(bytes, 0, len); System.out.println(msg); // 5、关闭资源. is.close(); server.close();} 客户端实现代码如下： 123456789101112131415public static void main(String[] args) throws Exception { System.out.println(\"客户端 发送数据\"); // 1、创建 Socket ( ip , port ) , 确定连接到哪里 Socket client = new Socket(\"localhost\", 6666); // 2、获取输出流对象 OutputStream os = client.getOutputStream(); // 3、写出数据. os.write(\"你好么? tcp ,我来了\".getBytes()); // 4、关闭资源 os.close(); client.close();} 服务器向客户端回写数据服务端代码实现： 1234567891011121314151617181920212223242526272829public static void main(String[] args) throws IOException { System.out.println(\"服务端启动 , 等待连接 .... \"); // 1、创建 ServerSocket对象，绑定端口，开始等待连接 ServerSocket server = new ServerSocket(6666); // 2、接收连接 accept 方法, 返回 socket 对象. Socket socket = server.accept(); // 3、通过 socket 获取输入流 InputStream is = socket.getInputStream(); // 4、一次性读取数据 byte[] bytes = new byte[1024]; int len = is.read(bytes)； String msg = new String(bytes, 0, len); System.out.println(msg); // =================回写数据======================= // 5、通过 socket 获取输出流 OutputStream out = socket.getOutputStream(); // 6、回写数据 out.write(\"我很好,谢谢你\".getBytes()); // 7、关闭资源 out.close(); is.close(); server.close();} 客户端代码实现： 12345678910111213141516171819202122232425public static void main(String[] args) throws Exception { System.out.println(\"客户端 发送数据\"); // 1、创建 Socket ( ip , port ) , 确定连接到哪里 Socket client = new Socket(\"localhost\", 6666); // 2、通过 Scoket , 获取输出流对象 OutputStream os = client.getOutputStream(); // 3、写出数据 os.write(\"你好么? tcp ,我来了\".getBytes()); // ==============解析回写========================= // 4、通过 Scoket,获取输入流对象 InputStream in = client.getInputStream(); // 5、读取数据数据 byte[] b = new byte[100]; int len = in.read(b); System.out.println(new String(b, 0, len)); // 6、关闭资源 in.close(); os.close(); client.close();} 文件上传案例 文件上传分析图解 【客户端】输入流，从硬盘读取文件数据到程序中。 【客户端】输出流，写出文件数据到服务端。 【服务端】输入流，读取文件数据到服务端程序。 【服务端】输出流，写出文件数据到服务器硬盘中。 服务端代码实现： 12345678910111213141516171819202122232425public static void main(String[] args) throws IOException { System.out.println(\"服务器启动.....\"); // 1、创建服务端 ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2、建立连接 Socket accept = serverSocket.accept(); // 3、创建输入流对象,读取文件数据 和 创建输出流,保存到本地 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.jpg\")); // 4、读写数据 byte[] bytes = new byte[1024 * 8]; int len; while ((len = bis.read(bytes)) != -1) { bos.write(bytes, 0, len); } //5、关闭资源 bos.close(); bis.close(); accept.close(); System.out.println(\"文件上传已保存\");} 客户端代码实现： 123456789101112131415161718192021public static void main(String[] args) throws IOException { // 1、创建输入流对象,读取文件数据 和 创建输出流,保存到本地 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"test.jpg\")); Socket socket = new Socket(\"localhost\", 6666); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); // 2、写出数据 byte[] b = new byte[1024 * 8 ]; int len ; while (( len = bis.read(b))!=-1) { bos.write(b, 0, len); bos.flush(); } System.out.println(\"文件发送完毕\"); // 3、释放资源 bos.close(); socket.close(); bis.close(); System.out.println(\"文件上传完毕 \");} 文件上传优化分析1、文件名称写死的问题 服务端代码中，保存文件的名称如果写死，那么最终只会保留一个文件。通过使用系统时间优化，保证文件名称唯一，代码如下： 12FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + \".jpg\") // 文件名称BufferedOutputStream bos = new BufferedOutputStream(fis); 2、循环接收的问题 服务端代码中，保存一个文件就关闭了，之后的用户无法再上传。通过使用循环改进，可以不断的接收不同用户的文件，代码如下： 12345// 每次接收新的连接,创建一个 Socketwhile（true）{ Socket accept = serverSocket.accept(); ......} 3、效率问题 服务端代码中，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传。所以，使用多线程技术优化，代码如下： 123456789while（true）{ Socket accept = serverSocket.accept(); // accept 交给子线程处理. new Thread(() -&gt; { ...... InputStream bis = accept.getInputStream(); ...... }).start();} 优化实现12345678910111213141516171819202122232425262728293031323334353637public static void main(String[] args) throws IOException { System.out.println(\"服务器启动.....\"); // 1、创建服务端 ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2、循环接收,建立连接 while (true) { Socket accept = serverSocket.accept(); // 3、socket 对象交给子线程处理,进行读写操作。Runnable接口中,只有一个run方法,使用lambda表达式简化格式 new Thread(() -&gt; { try ( // 3.1 获取输入流对象 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); // 3.2 创建输出流对象, 保存到本地 FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(fis);) { // 3.3 读写数据 byte[] bytes = new byte[1024 * 8]; int len; while ((len = bis.read(bytes)) != -1) { bos.write(bytes, 0, len); } // 4、关闭资源 bos.close(); bis.close(); accept.close(); System.out.println(\"文件上传已保存\"); } catch (IOException e) { e.printStackTrace(); } }).start(); }} 信息回写分析图解前四步与基本文件上传一致，后两步如下： 1、【服务端】获取输出流，回写数据。2、【客户端】获取输入流，解析回写数据。 服务器端代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243public static void main(String[] args) throws IOException { System.out.println(\"服务器 启动..... \"); // 1、创建服务端 ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2、循环接收,建立连接 while (true) { Socket accept = serverSocket.accept(); // 3、socket 对象交给子线程处理,进行读写操作。Runnable接口中,只有一个run方法,使用lambda表达式简化格式 new Thread(() -&gt; { try ( // 3.1 获取输入流对象 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); // 3.2 创建输出流对象, 保存到本地 FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(fis);) { // 3.3 读写数据 byte[] bytes = new byte[1024 * 8]; int len; while ((len = bis.read(bytes)) != -1) { bos.write(bytes, 0, len); } // 4、===============信息回写=================== System.out.println(\"back ........\"); OutputStream out = accept.getOutputStream(); out.write(\"上传成功\".getBytes()); out.close(); // 5、关闭资源 bos.close(); bis.close(); accept.close(); System.out.println(\"文件上传已保存\"); } catch (IOException e) { e.printStackTrace(); } }).start(); }} 客户端代码实现： 12345678910111213141516171819202122232425262728public static void main(String[] args) throws IOException { // 1.创建输入流对象，读取本地文件。 创建输出流,写到服务端 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"test.jpg\")); Socket socket = new Socket(\"localhost\", 6666); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); // 2、写出数据 byte[] bytes = new byte[1024 * 8 ]; int len ; while (( len = bis.read(bytes)) != -1) { bos.write(bytes, 0, len); } // 3、关闭输出流,通知服务端,写出数据完毕 socket.shutdownOutput(); System.out.println(\"文件发送完毕\"); // 4、=======解析回写========= InputStream in = socket.getInputStream(); byte[] back = new byte[20]; in.read(back); System.out.println(new String(back)); in.close(); // 5、释放资源 socket.close(); bis.close();} 模拟 B/S 服务器模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。分析如下图： 案例分析1、准备页面数据，web 文件夹，复制到 Module 中，如下图所示： 2、我们模拟服务器端，ServerSocket 类监听端口，使用浏览器访问，如下图： 123456789101112public static void main(String[] args) throws IOException { ServerSocket server = new ServerSocket(8000); Socket socket = server.accept(); InputStream in = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = in.read(bytes); System.out.println(new String(bytes, 0, len)); socket.close(); server.close();} 服务器程序中字节输入流可以读取到浏览器发来的请求信息，如下图： GET/web/index.html HTTP/1.1 是浏览器的请求消息。/web/index.html 为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。 12345678910// 转换流,读取浏览器请求第一行BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream()));String requst = readWb.readLine();// 取出请求资源的路径String[] strArr = requst.split(\" \");// 去掉 web 前面的 /String path = strArr[1].substring(1);System.out.println(path); 案例实现服务端代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) throws IOException { System.out.println(\"服务端启动 , 等待连接 ....\"); // 创建 ServerSocket 对象 ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); // 转换流读取浏览器的请求消息 BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream())); String requst = readWb.readLine(); // 取出请求资源的路径 String[] strArr = requst.split(\" \"); // 去掉web前面的 / String path = strArr[1].substring(1); // 读取客户端请求的资源文件 FileInputStream fis = new FileInputStream(path); byte[] bytes= new byte[1024]; int len = 0 ; // 字节输出流,将文件写会客户端 OutputStream out = socket.getOutputStream(); // 写入 HTTP 协议响应头,固定写法 out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); out.write(\"Content-Type:text/html\\r\\n\".getBytes()); // 必须要写入空行,否则浏览器不解析 out.write(\"\\r\\n\".getBytes()); while((len = fis.read(bytes)) != -1){ out.write(bytes, 0, len); } fis.close(); out.close(); readWb.close(); socket.close(); server.close();} 访问效果火狐浏览器中访问，如下图： 小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。 发现浏览器中出现了的问题,浏览器没有读取到图片信息。这是为什么呢？原因：浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此需要在服务器端加入线程技术。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void main(String[] args) throws IOException { ServerSocket server = new ServerSocket(8888); while(true){ Socket socket = server.accept(); new Thread(new Web(socket)).start(); }}static class Web implements Runnable{ private Socket socket; public Web(Socket socket){ this.socket=socket; } public void run() { try{ //转换流,读取浏览器请求第一行 BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream())); String requst = readWb.readLine(); //取出请求资源的路径 String[] strArr = requst.split(\" \"); System.out.println(Arrays.toString(strArr)); String path = strArr[1].substring(1); System.out.println(path); FileInputStream fis = new FileInputStream(path); System.out.println(fis); byte[] bytes= new byte[1024]; int len = 0 ; //向浏览器 回写数据 OutputStream out = socket.getOutputStream(); out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); out.write(\"Content-Type:text/html\\r\\n\".getBytes()); out.write(\"\\r\\n\".getBytes()); while((len = fis.read(bytes))!=-1){ out.write(bytes,0,len); } fis.close(); out.close(); readWb.close(); socket.close(); }catch(Exception ex){ } }} 再次浏览器进行访问，如下图： 函数式编程暂时预留一个位置…… JUnit 单元测试什么是 JUnit在平时的开发当中，一个项目往往包含了大量的方法，可能有成千上万个。如何去保证这些方法产生的结果是我们想要的呢？ 当然了，最容易想到的一个方式，就是我们通过 System.out 来输出我们的结果，看看是不是满足我们的需求，但是项目中这些成千上万个方法，我们总不能在每一个方法中都去输出一遍嘛。这也太枯燥了。这时候用我们的单元测试框架 JUnit 就可以很好地解决这个问题。 JUnit 如何解决这个问题的呢？答案在于内部提供了一个 断言机制 ， 他能够将我们预期的结果和实际的结果进行比对，判断出是否满足我们的期望。相信到这，你已经迫不及待的想认识一下 JUnit ，下面我们就对 JUnit 进行简单的介绍以及使用。 JUnit 简介： JUnit 是一个 Java 编程语言的单元测试框架。JUnit 在测试驱动的开发方面有很重要的发展，是起源于 JUnit 的一个统称为 xUnit 的单元测试框架之一。JUnit 促进了“先测试后编码”的理念，强调建立测试数据的一段代码，可以先测试，然后再应用。 这个方法就好比“测试一点，编码一点，测试一点，编码一点……”，增加了程序员的产量和程序的稳定性，可以减少程序员的压力和花费在排错上的时间。单元测试是一个对单一实体（类或方法）的测试。单元测试是每个软件公司提高产品质量、满足客户需求的重要环节。 单元测试分类单元测试分类主要有两种： 黑盒测试 和 白盒测试 。黑盒测试 不用写代码，只需要输入相关的值，看程序是否能够输出期望的值即可。而 白盒测试 是需要写代码的，且关注程序具体的执行流程。其他介绍如下图： JUnit 注解以下是 JUnit 测试中常用的注解。 相关介绍如下： 123456789101112################################################################################################################## JUnit 注解 注解作用@Test # 标识一条测试用例。可加参数： (A) (expected=XXEception.class) (B) (timeout=xxx)@Ignore # 有时候我们想暂时不运行某些测试方法\\测试类，可以在方法前加上这个注解。@Before # 在每一个测试方法执行之前运行。@After # 每一个测试方法执行完成之后运行。@BefreClass # 所有测试开始之前运行。@AfterClass # 所有测试结果之后运行。################################################################################################################# JUnit 使用了解完 JUnit ，我们就来使用一下。第一步： 查看 JUnit 的大致使用步骤。 如下： 1234567891011121314# JUnit 属于白盒测试，需要编写一点代码。其使用步骤如下：1、定义一个测试类(测试用例) 测试类名：被测试的类名Test 例如：CalculatorTest 包名：xxx.xx.test 例如：com.demo2、定义测试方法：可以独立运行 方法名：test测试的方法名 例如：testAdd() 返回值：void 修饰符： JUnit4 需要加 public ，JUnit5 就可省略 参数列表：空参3、给方法加上 @Test 注解4、导入 JUnit 依赖环境# 判定结果：红色 --&gt; 失败， 绿色 --&gt; 成功一般我们会使用断言操作来处理结果：Assert.assertEquals(期望的结果,运算的结果)# JUnit 的使用步骤到此结束！！！ 第二步： 新建一个需要被测试的类。 代码如下： Calculator.java1234567891011121314151617181920package JunitTest;/** * @Author: guoshizhan * @Create: 2020/5/2 21:12 * @Description: Calculator 类 */public class Calculator { // add 方法实现两个数相加操作 public static int add(int a, int b){ return a + b; } // sub 方法实现两个数相减操作 public static int sub(int a, int b){ return a - b; }} 第三步： 编写测试类。注意：@Test 注解 需要导包，需要把 Junit 包添加到类路径下【IDEA 会给出提示】。 代码如下： CalculatorTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package JunitTest;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;/** * @Author: guoshizhan * @Create: 2020/5/2 21:37 * @Description: CalculatorTest 类 */public class CalculatorTest { /** * 这个是初始化方法，在测试方法之前执行。方法体内大部分为公共部分，例如对象的创建等等。 */ @Before public void init() { Calculator calculator = new Calculator(); System.out.println(\"初始化方法执行了……\"); } /** * 测试 add 方法 */ @Test public void addTest() { Calculator calculator = new Calculator(); int result = calculator.add(1, 2); // 进行断言操作，如果期待结果和实际结果一样，那么测试通过 Assert.assertEquals(3, result); } /** * 测试 sub 方法 */ @Test public void subTest() { Calculator calculator = new Calculator(); int result = calculator.sub(1, 2); System.out.println(\"测试 sub 方法执行了……\"); // 进行断言操作，如果期待结果和实际结果一样，那么测试通过 Assert.assertEquals(3, result); } /** * 这是一个结束方法，在测试方法之后执行。方法体内一般涉及一些需要最后执行的代码。例如：流的关闭等等 */ @After public void destory() { System.out.println(\"销毁方法执行了……\"); } } 第四步： 执行我们需要进行测试的方法【我执行的是 subTest 方法】。 结果如下图： TIPS： 到此为止，JUnit 就说完了。这里的所说的 JUnit 是 JUnit4 ，如果以后有时间，JUnit5 也可安排一下。 反射相关知识反射： 是将类的各个组成部分封装为其他对象，这就是反射机制。 但使用反射的 前提条件 是： 必须先得到字节码的 Class ，Class 类用于表示 .class 文件【即我们常说的字节码文件】。 下图是我们 Java 代码的三个阶段： 反射的概述JAVA 反射机制 是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。 要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是 Class类 中的方法，所以先要获取到每一个字节码文件对应的 Class 类型的对象。 那么我们使用反射有什么好处呢？ 其好处如下： 1234567# 反射的好处1、可以在程序运行过程中，操作这些对象。2、可以解耦，提高程序的可扩展性。3、反射是框架设计的灵魂。# 反射的好处 获取对象字节码我们可以通过反射技术来 获取到对象的字节码文件。 那就开始操作吧。 第一步： 新建 Person 类。 代码如下： Person.java1234567891011121314151617181920212223242526272829303132333435package domain;/** * @Author: guoshizhan * @Create: 2020/5/3 22:41 * @Description: Person 实体类 */public class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 第二步： 新建 PersonReflectTest 类，然后编写代码来获取 Person 类的字节码文件。 代码如下： PersonReflectTest.java12345678910111213141516171819202122232425262728293031323334353637package domain;/** * @Author: guoshizhan * @Create: 2020/5/3 22:41 * @Description: PersonReflectTest 类 */public class PersonReflectTest { public static void main(String[] args) throws Exception { /** * 获取 Class 对象的三种方式： * 1、Class.forName(\"全类名\")：将字节码文件加载进内存，返回 Class 对象。使用场合：多用于配置文件，将类名定义在配置文件中。读取文件，加载类 * 2、类名.class：通过类名的属性 class 获取。使用场合：多用于参数的传递 * 3、对象.getClass()：getClass() 方法在 Object 类中定义着。使用场合：多用于对象的获取字节码的方式 * 4、得出的结论：同一个字节码文件 (*.class) 在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的 Class 对象都是同一个。 */ // 1、Class.forName(\"全类名\") Class clazz01 = Class.forName(\"domain.Person\"); System.out.println(clazz01); // 2、类名.class Class clazz02 = Person.class; System.out.println(clazz02); // 3、对象.getClass() Person p = new Person(); Class clazz03 = p.getClass(); System.out.println(clazz03); // == 比较三个对象 System.out.println(clazz01 == clazz02); // true System.out.println(clazz01 == clazz03); // true }} 第三步： 执行上述代码，查看输出结果。 结果如下： 12345678910################################################################################################# 输出结果：class domain.Personclass domain.Personclass domain.Persontruetrue################################################################################################ Class 对象功能获取成员变量Class 对象具有 获取成员变量 的功能。具体操作： 新建一个反射测试类，用于作为反射的字节码对象。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package domain;/** * @Author: guoshizhan * @Create: 2020/5/3 23:16 * @Description: 反射测试类 */public class ReflectTest { public String a; protected String b; String c; private String d; @Override public String toString() { return \"ReflectTest{\" + \"a='\" + a + '\\'' + \", b='\" + b + '\\'' + \", c='\" + c + '\\'' + \", d='\" + d + '\\'' + '}'; } public String getA() { return a; } public void setA(String a) { this.a = a; } public ReflectTest() { } public ReflectTest(String a, String b, String c, String d) { this.a = a; this.b = b; this.c = c; this.d = d; } public String getB() { return b; } public void setB(String b) { this.b = b; } public String getC() { return c; } public void setC(String c) { this.c = c; } public String getD() { return d; } public void setD(String d) { this.d = d; } public void eat(){ System.out.println(\"吃饭……\"); } public void eat(String food){ System.out.println(\"吃饭……\" + food); }} 获取成员变量功能的方法和解释都在代码的注释里面了，这里就不过多介绍。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 获取成员变量们 * Field[] getFields() 获取所有 public 修饰的成员变量 * Field getField(String name) 获取指定名称的 public 修饰的成员变量 * Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 * Field getDeclaredField(String name) 获取单个成员变量，不考虑修饰符，如果被 private 修饰，需要进行暴力反射 */public static void main(String[] args) throws Exception { // 0、获取 ReflectTest 的 Class 对象 Class reflectTestClass = ReflectTest.class; // 1、Field[] getFields() ：获取所有 public 修饰的成员变量 Field[] fields = reflectTestClass.getFields(); for (Field field : fields) { System.out.println(field); } System.out.println(\"------------\"); // 2、Field getField(String name) Field a = reflectTestClass.getField(\"a\"); // 获取成员变量 a 的值 ReflectTest reflectTest = new ReflectTest(); Object value = a.get(reflectTest); System.out.println(value); a.set(reflectTest, \"张三\"); // 设置 a 的值 System.out.println(reflectTest); System.out.println(\"===================\"); // 3、Field[] getDeclaredFields() ：获取所有的成员变量，不考虑修饰符 Field[] declaredFields = reflectTestClass.getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(declaredField); } // 4、Field getDeclaredField(String name) Field d = reflectTestClass.getDeclaredField(\"d\"); // 忽略访问权限修饰符的安全检查 d.setAccessible(true); // 暴力反射 Object value2 = d.get(reflectTest); System.out.println(value2);} 最后，我们查看一下上述代码的执行结果。 结果如下： 123456789101112131415################################################################################################# 输出结果：public java.lang.String domain.ReflectTest.a-------------------------------------------------------nullReflectTest{a='张三', b='null', c='null', d='null'}-------------------------------------------------------public java.lang.String domain.ReflectTest.aprotected java.lang.String domain.ReflectTest.bjava.lang.String domain.ReflectTest.cprivate java.lang.String domain.ReflectTest.dnull################################################################################################ 获取构造方法Class 对象也具有 获取构造方法 的功能。此功能的方法和解释都在代码的注释里面了，这里就不过多介绍。 代码如下： 12345678910111213141516171819202122232425262728293031/** * 获取构造方法 * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() */public static void main(String[] args) throws Exception { // 获取 ReflectTest 的 Class 对象 Class reflectTestClass = ReflectTest.class; // Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) Constructor constructor = reflectTestClass.getConstructor(String.class,String.class,String.class,String.class); System.out.println(constructor); // 创建对象 Object test = constructor.newInstance(\"第一个\", \"第二个\", \"第三个\", \"第四个\"); System.out.println(test); System.out.println(\"-------------------------------------------------------\"); Constructor constructor2 = reflectTestClass.getConstructor(); System.out.println(constructor2); // 如果使用空参数构造方法创建对象，操作可以简化：使用 newInstance 方法 Object cons = constructor2.newInstance(); System.out.println(cons); Object o = reflectTestClass.newInstance(); System.out.println(o); //constructor1.setAccessible(true);} 我们运行上述代码，查看一下执行的结果。 结果如下： 1234567891011################################################################################################# 输出结果：public domain.ReflectTest(java.lang.String,java.lang.String,java.lang.String,java.lang.String)ReflectTest{a='第一个', b='第二个', c='第三个', d='第四个'}-------------------------------------------------------public domain.ReflectTest()ReflectTest{a='null', b='null', c='null', d='null'}ReflectTest{a='null', b='null', c='null', d='null'}################################################################################################ 获取成员方法和类名Class 对象也具有 获取成员方法和类名 的功能。此功能的方法和解释都在代码的注释里面了，这里就不过多介绍。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738/** * 获取成员方法 * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) * * 获取类名 * String getName() */public static void main(String[] args) throws Exception { // 获取 ReflectTest 的 Class 对象 Class reflectTestClass = ReflectTest.class; // 获取指定名称的方法 Method eat_method = reflectTestClass.getMethod(\"eat\"); ReflectTest reflectTest = new ReflectTest(); eat_method.invoke(reflectTest); // 执行方法 Method eat_method2 = reflectTestClass.getMethod(\"eat\", String.class); eat_method2.invoke(reflectTest,\"水果\"); // 执行方法 System.out.println(\"-------------------------------------------------------\"); // 获取所有 public 修饰的方法 Method[] methods = reflectTestClass.getMethods(); for (Method method : methods) { System.out.println(method); String name = method.getName(); System.out.println(name); //method.setAccessible(true); } // 获取类名 String className = reflectTestClass.getName(); System.out.println(className); // domain.ReflectTest} 我们运行上述代码，查看一下执行的结果。 结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647################################################################################################# 输出结果：吃饭……吃饭……水果-----------------public java.lang.String domain.ReflectTest.toString()toStringpublic java.lang.String domain.ReflectTest.getA()getApublic void domain.ReflectTest.setA(java.lang.String)setApublic void domain.ReflectTest.setB(java.lang.String)setBpublic java.lang.String domain.ReflectTest.getC()getCpublic void domain.ReflectTest.setC(java.lang.String)setCpublic java.lang.String domain.ReflectTest.getD()getDpublic void domain.ReflectTest.eat()eatpublic void domain.ReflectTest.eat(java.lang.String)eatpublic void domain.ReflectTest.setD(java.lang.String)setDpublic java.lang.String domain.ReflectTest.getB()getBpublic final void java.lang.Object.wait() throws java.lang.InterruptedExceptionwaitpublic final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionwaitpublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionwaitpublic boolean java.lang.Object.equals(java.lang.Object)equalspublic native int java.lang.Object.hashCode()hashCodepublic final native java.lang.Class java.lang.Object.getClass()getClasspublic final native void java.lang.Object.notify()notifypublic final native void java.lang.Object.notifyAll()notifyAlldomain.ReflectTest################################################################################################ TIPS： 到此为止，反射基本就介绍完了。接下来做一个反射小案例。 反射小案例案例需求： 编写一个 “框架” ，可以创建任意类的对象，可以执行任意方法。 前提： 不能改变该类的任何代码。 第一步： 在 domain 包下新建 Student 类。 代码如下： 12345678910111213141516package domain;/** * @Author: guoshizhan * @Create: 2020/5/3 23:16 * @Description: Student 类 */public class Student { public void eat(){ System.out.println(\"吃饭……\"); System.out.println(\"睡觉……\"); System.out.println(\"打豆豆……\"); }} 第二步： 在 src 目录 【即类路径】下新建 pro.properties 配置文件。 代码如下： pro.properties12345# 配置需要被反射的类的全类名className=domain.Student# 配置需要被反射的方法methodName=eat 第三步： 在 domain 包下编写 StudentReflectTest 类进行测试。 代码如下： StudentReflectTest.java12345678910111213141516171819202122232425262728293031323334package domain;import java.io.InputStream;import java.lang.reflect.Method;import java.util.Properties;/** * @Author: guoshizhan * @Create: 2020/8/7 10:33 * @Description: StudentReflectTest 类 */public class StudentReflectTest { public static void main(String[] args) throws Exception { // 1、创建 Properties 对象 Properties pro = new Properties(); // 2、加载配置文件，转换为一个集合 ClassLoader classLoader = StudentReflectTest.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(\"pro.properties\"); pro.load(is); // 3、获取配置文件中定义的数据 String className = pro.getProperty(\"className\"); String methodName = pro.getProperty(\"methodName\"); Class cls = Class.forName(className); // 加载该类进内存 Object obj = cls.newInstance(); // 创建该类对象 Method method = cls.getMethod(methodName); // 获取方法对象 method.invoke(obj); // 执行方法 }} 第四步： 我们运行上述代码，查看一下执行的结果。 结果如下： 12345678################################################################################################# 输出结果：吃饭……睡觉……打豆豆……################################################################################################ TIPS： 到此为止，反射知识就结束了！！！ 注解知识注解简介定义： 注解（Annotation），也叫元数据。 一种代码级别的说明。它是 JDK1.5 及以后版本引入的一个特性，与 类、接口、枚举 是在同一个层次。它可以声明在 包、类、字段、方法、局部变量、方法参数等 的前面，用来对这些元素进行说明，注释。 123456789+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 概念描述：+ 1、JDK1.5 之后的新特性+ 2、说明程序的，给计算机看的+ 3、使用注解：@注解名称++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 作用分类： ①编写文档：通过代码里标识的注解生成文档【生成文档 doc 文档】 ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】 ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 使用注解生成文档我们经常使用的 api 文档就是使用 注解 生成的， 如下图： 那么我们该如何把我们自己写的类也生成这样的一个文档呢？ 接下来我们就来操作一下。 创建一个文件夹随便在桌面上建立一个文件夹【我的叫 doc】， 里面放一个 HelloWorld.java 文件。如下图： 编辑代码编写这个 Java 文件。 代码内容如下： HelloWorld.java123456789101112131415161718/** * 注解 Javadoc 演示 * @author guoshizhan * @version 1.0 * @since 1.5 */ public class HelloWorld { /** * 打印一条语句 * @param str String * @return 无返回值 */ public void print(String str){ System.out.println(\"Hello,World\" + str); }} 这里要注意一下： 如果是 Windows 系统，此 java 文件编码必须设置为 GBK 编码，否则会导致乱码问题。 命令行执行使用 javadoc 命令生成文档，如下图： 生成之后，doc 文件夹生成了好多文件，如下图： 查看效果我们打开 index.html 即可查看效果 【和 api 文档一样哦】。如下： 预定义注解和元注解下面是 预定义注解和元注解 的相关介绍，如下： 123456789101112131415161718192021222324252627# 预定义的一些注解@Override # 检测被该注解标注的方法是否是继承自父类(接口)的@Deprecated # 该注解标注的内容，表示已过时@SuppressWarnings # 压制警告，一般传递参数 all @SuppressWarnings(\"all\") 参数：all deprecation unchecked# 元注解@Documented # 作用是能够将注解中的元素包含到 Javadoc 中去@Repeatable # JavaSE 8 加入的特性，表明被注解的注解可以多次应用于相同的声明。@Inherited # 表明注解类型可以从超类继承。当超类使用了 @Inherited 注解后，如果它的子类没有添加任何注解，那么子类会继承超类的注解。@Retention # 指定注解的存储方式：# RetentionPolicy.SOURCE - 标记的注解仅保留在源级别中，并被编译器忽略。# RetentionPolicy.CLASS - 标记的注解在编译时由编译器保留，但 Java 虚拟机（JVM）会忽略。# RetentionPolicy.RUNTIME - 标记的注解由 JVM 保留，因此运行时环境可以使用它。@Target # 限制可以应用注解的 Java 元素类型：# ElementType.ANNOTATION_TYPE 可以应用于注解类型。# ElementType.CONSTRUCTOR 可以应用于构造函数。# ElementType.FIELD 可以应用于字段或属性。# ElementType.LOCAL_VARIABLE 可以应用于局部变量。# ElementType.METHOD 可以应用于方法级注释。# ElementType.PACKAGE 可以应用于包声明。# ElementType.PARAMETER 可以应用于方法的参数。# ElementType.TYPE 可以应用于类的任何元素。# It's over!!! 预定义注解 的代码演示如下： 123456789101112131415161718192021222324252627/** * @Author: guoshizhan * @Create: 2020/5/5 19:25 * @Description: 预定义注解的使用 */@SuppressWarnings(\"all\")public class AnnotationTest { @Override public String toString() { return super.toString(); } @Deprecated public void print() { System.out.println(\"我是过时的方法……\"); } public void printNew(){ System.out.println(\"我是新的 print 方法……\"); } public void test() { print(); }} 自定义注解自定义注解 的相关介绍如下： 123456789101112######################################################################################## 1、格式：注解的定义格式 1、元注解 2、public @interface 注解名称 { 属性列表; }# 2、本质：注解本质上就是一个接口，该接口默认继承 Annotation 接口# 3、属性：接口中的抽象方法####################################################################################### 自定义注解的格式 举例如下： 1234567# 自定义注解格式举例：/** * @Author: guoshizhan * @Create: 2020/5/5 19:47 * @Description: 自定义 MyAnnotation 注解 */public @interface MyAnnotation {} 自定义注解的本质那么这个注解到底是个什么东西呢？ 我们对上述定义的 MyAnnotation 注解 进行反编译一下，如下图： 通过反编译的结果 public interface MyAnno extends java.lang.annotation.Annotation {} 可知，注解本质上就是一个接口，该接口默认继承 Annotation 接口 。 既然是我们熟悉的接口，那就更好理解一点了。 自定义注解的属性自定义注解的属性其实就是接口中的抽象方法， 只不过我们使用注解时这些方法 需要被赋值，否则会报错。 以下是 注解属性的要求： 123456789101112131415++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 属性要求：属性的返回值类型有下列取值+ 基本数据类型+ String+ 枚举+ 注解+ 以上类型的数组+++ 定义了属性，在使用时需要给属性赋值+ 1、如果定义属性时，使用 default 关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。+ 2、如果只有一个属性需要赋值，并且属性的名称是 value，则 value 可以省略，直接定义值即可。+ 3、数组赋值时，值使用 {} 包裹。如果数组中只有一个值，则 {} 可以省略+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 自定义注解的代码模板 演示如下： 1234567891011121314151617/** * @Author: guoshizhan * @Create: 2020/5/5 19:47 * @Description: 自定义 MyAnnotation 注解 */public @interface MyAnnotation { // 基本数据类型 int age(); // String 类型 String name() default \"guoshizhan\"; // 使用 default 关键字给属性默认初始化值，使用注解时，可以不进行赋值。 // 数组类型 String[] strs(); // 注解、枚举等其他类型就不举例了} 注解格式之元注解元注解： 用于描述注解的注解。 接下来就简单介绍以下四个元注解：元注解相关参考 123456789101112#######################################################################################@Target ： # 描述注解能够作用的位置。ElementType 取值有三： TYPE，METHOD，FIELD ，作用如下：# TYPE 只能作用于类上；METHOD 只能作用于方法上；FIELD 只能作用于成员变量上@Retention ： # 描述注解被保留的阶段，# 举例：@Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到 class 字节码文件中，并被 JVM 读取到@Documented ： # 描述注解是否被抽取到 api 文档中@Inherited ： # 描述注解是否被子类继承####################################################################################### 解析注解解析注解： 获取注解中定义的属性值。 具体步骤如下： 1、获取注解定义的位置的对象 （Class，Method，Field） 2、获取指定的注解 getAnnotation(Class) 3、调用注解中的抽象方法获取配置的属性值 创建注解既然要解析注解，那么就要先创建一个注解。 以下是我创建的 Pro 注解 ，代码如下： 123456789101112/** * @Author: guoshizhan * @Create: 2020/5/5 22:58 * @Description: 定义一个 Pro 注解 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Pro { String className(); String methodName();} 创建一个类，这个类会被 Pro 注解 使用。代码如下： 1234567public class ReflectTest { public void eat(){ System.out.println(\"吃饭……\"); }} 创建测试类这是 测试 Pro 注解 的测试类，代码及运行结果如下： 123456789101112131415161718192021222324252627// 我们自己定义的 Pro 注解@Pro(className = \"domain.ReflectTest\",methodName = \"eat\")public class AnnotationCustom { public static void main(String[] args) throws Exception { // 1、解析注解。获取该类的字节码文件对象 Class&lt;AnnotationCustom&gt; testClass = AnnotationCustom.class; // 2、获取注解对象,其实就是在内存中生成了一个该注解接口的子类实现对象 Pro an = testClass.getAnnotation(Pro.class); // 3、调用注解对象中定义的抽象方法，获取返回值 String className = an.className(); String methodName = an.methodName(); System.out.println(className); System.out.println(methodName); Class cls = Class.forName(className); // 4、加载该类进内存 Object obj = cls.newInstance(); // 5、创建对象 Method method = cls.getMethod(methodName); // 6、获取方法对象 method.invoke(obj); // 7、执行方法 } }// 输出结果：// domain.ReflectTest// eat// 吃饭…… 注解小案例第一步新建一个 demo 包 ，在包下建立 @Check 注解 ，代码如下： demo/Check.java1234567891011121314package demo;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)/** * 定义 @Check 注解 */public @interface Check {} 第二步在 demo 包下建立 Calculator 类 ，并使用上面的 @Check 注解 ，代码如下： demo/Calculator.java1234567891011121314151617181920212223242526272829303132333435363738package demo;/** * 定义计算器类 */public class Calculator { // 加法 @Check public void add(){ String str = null; str.toString(); System.out.println(\"1 + 0 =\" + (1 + 0)); } // 减法 @Check public void sub(){ System.out.println(\"1 - 0 =\" + (1 - 0)); } // 乘法 @Check public void mul(){ System.out.println(\"1 * 0 =\" + (1 * 0)); } // 除法 @Check public void div(){ System.out.println(\"1 / 0 =\" + (1 / 0)); } public void show(){ System.out.println(\"永无bug...\"); }} 第三步在 demo 包下建立 TestCheck 类 ，用于测试注解是否起作用。代码如下： demo/TestCheck.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package demo;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * 当主方法执行后，会自动自行被检测的所有方法(加了 @Check 注解的方法)，判断方法是否有异常，记录到文件中 */public class TestCheck { public static void main(String[] args) throws IOException { Calculator c = new Calculator(); // 创建计算器对象 Class cls = c.getClass(); // 获取字节码文件对象 Method[] methods = cls.getMethods(); // 获取所有方法 int number = 0; // 出现异常的次数 BufferedWriter bw = new BufferedWriter(new FileWriter(\"bug.txt\")); for (Method method : methods) { // 判断方法上是否有 @Check 注解 if (method.isAnnotationPresent(Check.class)) { // 有 @Check 注解的话，执行如下代码 try { method.invoke(c); } catch (Exception e) { // 捕获异常，然后记录到 bug.txt 文件中 number++; bw.write(method.getName() + \" 方法出异常了\"); bw.newLine(); bw.write(\"异常的名称:\" + e.getCause().getClass().getSimpleName()); bw.newLine(); bw.write(\"异常的原因:\" + e.getCause().getMessage()); bw.newLine(); bw.write(\"--------------------------\"); bw.newLine(); } } } bw.write(\"本次测试一共出现 \" + number + \" 次异常\"); bw.flush(); bw.close(); }} 第四步运行 TestCheck 类 ，查看生成的结果文件 bug.txt ，结果如下： bug.txt123456789add 方法出异常了异常的名称:NullPointerException异常的原因:null--------------------------div 方法出异常了异常的名称:ArithmeticException异常的原因:/ by zero--------------------------本次测试一共出现 2 次异常 案例小结 案例小结： 1、以后大多数时候，我们会使用注解，而不是自定义注解 2、注解给谁用？给编译器解析程序用 3、注解不是程序的一部分，可以理解为注解就是一个标签 JavaSE 最后总结： 到此为止，JavaSE 就完结了，以后会慢慢完善 JavaSE 的这四篇文章。这些文章都是我学习视频课程的文字版记录，为的是自己以后能够方便快速的复习。 以后我还会进行各种修改，希望能够让初学者从这四篇博文就学完 JavaSE，这是我的终极目标，也是写博客的初衷。最后，感谢大家的阅读！！！","link":"/JavaSE-04.html"},{"title":"Layui 个人博客项目","text":"前期准备 项目的技术栈： 前端： freemarker + layui + websocket后端： spring boot + mybatisplus + redis + lombok + es + shiro + tio 创建数据库对于一个项目来说，数据库的设计是很重要的。此项目数据库设计代码如下【复制到图形工具执行代码即可】： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/*SQLyog Ultimate v8.32 MySQL - 5.5.49 : Database - Layui_Blog**********************************************************************//*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=''*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;CREATE DATABASE /*!32312 IF NOT EXISTS*/`Layui_Blog` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `Layui_Blog`;/*Table structure for table `m_category` */DROP TABLE IF EXISTS `category`;CREATE TABLE `category` ( `id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '主键ID', `name` varchar(512) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '标题', `content` text COLLATE utf8mb4_unicode_ci COMMENT '内容描述', `summary` text COLLATE utf8mb4_unicode_ci, `icon` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '图标', `post_count` int(11) unsigned DEFAULT '0' COMMENT '该分类的内容数量', `order_num` int(11) DEFAULT NULL COMMENT '排序编码', `parent_id` bigint(32) unsigned DEFAULT NULL COMMENT '父级分类的ID', `meta_keywords` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'SEO关键字', `meta_description` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'SEO描述内容', `created` datetime DEFAULT NULL COMMENT '创建日期', `modified` datetime DEFAULT NULL, `status` tinyint(2) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;/*Data for the table `m_category` */insert into `category`(`id`,`name`,`content`,`summary`,`icon`,`post_count`,`order_num`,`parent_id`,`meta_keywords`,`meta_description`,`created`,`modified`,`status`) values (1,'Java 学习',NULL,NULL,NULL,8,NULL,NULL,NULL,NULL,'2020-04-28 22:36:48',NULL,0),(2,'数据结构与算法',NULL,NULL,NULL,5,NULL,NULL,NULL,NULL,'2020-04-28 22:36:48',NULL,0),(3,'数据库',NULL,NULL,NULL,3,NULL,NULL,NULL,NULL,'2020-04-28 22:36:48',NULL,0),(4,'计算机网络',NULL,NULL,NULL,2,NULL,NULL,NULL,NULL,'2020-04-28 22:36:48',NULL,0),(5,'教程工具',NULL,NULL,NULL,6,NULL,NULL,NULL,NULL,'2020-04-28 22:36:48',NULL,0),(6,'前端知识',NULL,NULL,NULL,5,NULL,NULL,NULL,NULL,'2020-04-28 22:36:48',NULL,0);/*Table structure for table `m_comment` */DROP TABLE IF EXISTS `comment`;CREATE TABLE `comment` ( `id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '主键ID', `content` longtext COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '评论的内容', `parent_id` bigint(32) DEFAULT NULL COMMENT '回复的评论ID', `post_id` bigint(32) NOT NULL COMMENT '评论的内容ID', `user_id` bigint(32) NOT NULL COMMENT '评论的用户ID', `vote_up` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '“顶”的数量', `vote_down` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '“踩”的数量', `level` tinyint(2) unsigned NOT NULL DEFAULT '0' COMMENT '置顶等级', `status` tinyint(2) DEFAULT NULL COMMENT '评论的状态', `created` datetime NOT NULL COMMENT '评论的时间', `modified` datetime DEFAULT NULL COMMENT '评论的更新时间', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;/*Data for the table `m_comment` */insert into `comment`(`id`,`content`,`parent_id`,`post_id`,`user_id`,`vote_up`,`vote_down`,`level`,`status`,`created`,`modified`) values (1,' 盗将行\\r\\n盗将行，何以停，枕风宿雪独自迎；\\r\\n红昭愿，情人念，隔却山海几时恋；\\r\\n落花情，心难平，一种相思花飘零；\\r\\n对黄昏，泪滚滚，骗过天下笑昆仑；\\r\\n多情岸，怎相盼，饮马长川痴情叹！',1,1,1,1,0,0,1,'2020-07-16 00:00:00',NULL);/*Table structure for table `m_post` */DROP TABLE IF EXISTS `post`;CREATE TABLE `post` ( `id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '主键ID', `title` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '标题', `content` longtext COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '内容', `edit_mode` varchar(32) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '0' COMMENT '编辑模式：html可视化，markdown ..', `category_id` bigint(32) DEFAULT NULL, `user_id` bigint(32) DEFAULT NULL COMMENT '用户ID', `vote_up` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '支持人数', `vote_down` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '反对人数', `view_count` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '访问量', `comment_count` int(11) NOT NULL DEFAULT '0' COMMENT '评论数量', `recommend` tinyint(1) DEFAULT NULL COMMENT '是否为精华', `level` tinyint(2) NOT NULL DEFAULT '0' COMMENT '置顶等级', `status` tinyint(2) DEFAULT NULL COMMENT '状态', `created` datetime DEFAULT NULL COMMENT '创建日期', `modified` datetime DEFAULT NULL COMMENT '最后更新日期', `avatar` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;/*Data for the table `m_post` */insert into `post`(`id`,`title`,`content`,`edit_mode`,`category_id`,`user_id`,`vote_up`,`vote_down`,`view_count`,`comment_count`,`recommend`,`level`,`status`,`created`,`modified`,`avatar`) values (1,'算法入门教程',' 你有多久没好好学习一个开源项目了？\\n\\n你是否经常为找不到好的开源项目而烦恼？\\n\\n你是否为不知道怎么入手去看一个开源项目？\\n\\n你是否想看别人的项目学习笔记？\\n\\n你是否想跟着别人的项目搭建过程一步一步跟着做项目？\\n\\n为了让更多Java的开发者能更容易找到值得学习的开源项目，我搭建了这个Java开源学习网站，宗旨梳理Java知识，共享开源项目笔记。来瞧一瞧：\\n\\nimg[//image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200414/473f73a3eb6f471e8154620a9c1d5306.png] \\n\\n网站截图中可以看出，点击筛选条件组合之后，再点击搜索就会搜索出对应的开源项目。\\n\\n比如打开renren-fast项目，可以看到具体项目的信息，以及模块解析。\\n\\nimg[//image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200414/f74740692dab4d9c937cd56336ead1b4.png]\\n\\n这样，学习一个开源项目就不再费劲，每天学习一个开源项目，在不知不觉中提升技术水平！目前网站已经收录了近100个开源项目，让Java不再难懂！\\n\\n直接扫公众号下方的二维码，回复关键字【网站】即可获得网站的域名地址！\\n\\nimg[//image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200414/f58f7c6d038c4dfb99bd9cf40935392e.png]\\n\\n关注上方的公众号二维码\\n\\n回复【网站】即可获取项目域名地址。\\n','0',2,1,0,0,15,0,1,1,NULL,'2020-04-28 14:41:41','2020-04-28 14:41:41','/res/images/avatar/5.jpg'),(2,'Spring Boot 入门教程',' 盗将行\\r\\n盗将行，何以停，枕风宿雪独自迎；\\r\\n红昭愿，情人念，隔却山海几时恋；\\r\\n落花情，心难平，一种相思花飘零；\\r\\n对黄昏，泪滚滚，骗过天下笑昆仑；\\r\\n多情岸，怎相盼，饮马长川痴情叹！','0',1,1,0,0,22,0,1,1,NULL,'2020-04-28 14:55:16','2020-04-28 14:55:16','/res/images/avatar/5.jpg'),(3,'从 0 开始搭建 Hexo 博客',' 你有多久没好好学习一个开源项目了？\\r\\n\\r\\n你是否经常为找不到好的开源项目而烦恼？\\r\\n\\r\\n你是否为不知道怎么入手去看一个开源项目？\\r\\n\\r\\n你是否想看别人的项目学习笔记？\\r\\n\\r\\n你是否想跟着别人的项目搭建过程一步一步跟着做项目？\\r\\n\\r\\n为了让更多Java的开发者能更容易找到值得学习的开源项目，我搭建了这个Java开源学习网站，宗旨梳理Java知识，共享开源项目笔记。来瞧一瞧：\\r\\n\\r\\nimg[//image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200414/473f73a3eb6f471e8154620a9c1d5306.png] \\r\\n\\r\\n网站截图中可以看出，点击筛选条件组合之后，再点击搜索就会搜索出对应的开源项目。\\r\\n\\r\\n比如打开renren-fast项目，可以看到具体项目的信息，以及模块解析。\\r\\n\\r\\nimg[//image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200414/f74740692dab4d9c937cd56336ead1b4.png]\\r\\n\\r\\n这样，学习一个开源项目就不再费劲，每天学习一个开源项目，在不知不觉中提升技术水平！目前网站已经收录了近100个开源项目，让Java不再难懂！\\r\\n\\r\\n直接扫公众号下方的二维码，回复关键字【网站】即可获得网站的域名地址！\\r\\n\\r\\nimg[//image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200414/f58f7c6d038c4dfb99bd9cf40935392e.png]\\r\\n\\r\\n关注上方的公众号二维码\\r\\n\\r\\n回复【网站】即可获取项目域名地址。\\r\\n','0',5,1,0,0,14,0,0,0,NULL,'2020-04-28 14:55:48','2020-04-28 14:55:48','/res/images/avatar/5.jpg'),(4,'Redis 入门教程',' 你有多久没好好学习一个开源项目了？\\r\\n\\r\\n你是否经常为找不到好的开源项目而烦恼？\\r\\n\\r\\n你是否为不知道怎么入手去看一个开源项目？\\r\\n\\r\\n你是否想看别人的项目学习笔记？\\r\\n\\r\\n你是否想跟着别人的项目搭建过程一步一步跟着做项目？\\r\\n\\r\\n为了让更多Java的开发者能更容易找到值得学习的开源项目，我搭建了这个Java开源学习网站，宗旨梳理Java知识，共享开源项目笔记。来瞧一瞧：\\r\\n\\r\\nimg[//image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200414/473f73a3eb6f471e8154620a9c1d5306.png] \\r\\n\\r\\n网站截图中可以看出，点击筛选条件组合之后，再点击搜索就会搜索出对应的开源项目。\\r\\n\\r\\n比如打开renren-fast项目，可以看到具体项目的信息，以及模块解析。\\r\\n\\r\\nimg[//image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200414/f74740692dab4d9c937cd56336ead1b4.png]\\r\\n\\r\\n这样，学习一个开源项目就不再费劲，每天学习一个开源项目，在不知不觉中提升技术水平！目前网站已经收录了近100个开源项目，让Java不再难懂！\\r\\n\\r\\n直接扫公众号下方的二维码，回复关键字【网站】即可获得网站的域名地址！\\r\\n\\r\\nimg[//image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200414/f58f7c6d038c4dfb99bd9cf40935392e.png]\\r\\n\\r\\n关注上方的公众号二维码\\r\\n\\r\\n回复【网站】即可获取项目域名地址。\\r\\n','0',3,1,0,0,0,0,NULL,0,NULL,'2020-07-17 00:00:00','2020-07-17 00:00:00','/res/images/avatar/5.jpg'),(5,'计算机网络入门教程','计算机网络入门……','0',4,1,0,0,0,0,NULL,0,NULL,'2020-07-18 00:00:00','2020-07-18 00:00:00','/res/images/avatar/5.jpg'),(6,'HTML 入门教程','HTML 入门……','0',6,1,0,0,0,0,NULL,0,NULL,'2020-07-19 00:00:00','2020-07-19 00:00:00','/res/images/avatar/5.jpg');/*Table structure for table `m_user` */DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '主键ID', `username` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '昵称', `password` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '密码', `email` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '邮件', `mobile` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '手机电话', `point` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '积分', `sign` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '个性签名', `gender` varchar(16) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '性别', `wechat` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '微信号', `vip_level` int(32) DEFAULT NULL COMMENT 'vip等级', `birthday` datetime DEFAULT NULL COMMENT '生日', `avatar` varchar(256) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '头像', `post_count` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '内容数量', `comment_count` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '评论数量', `status` tinyint(2) NOT NULL DEFAULT '0' COMMENT '状态', `lasted` datetime DEFAULT NULL COMMENT '最后的登陆时间', `created` datetime NOT NULL COMMENT '创建日期', `modified` datetime DEFAULT NULL COMMENT '最后修改时间', PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`) USING BTREE, UNIQUE KEY `email` (`email`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;/*Data for the table `m_user` */insert into `user`(`id`,`username`,`password`,`email`,`mobile`,`point`,`sign`,`gender`,`wechat`,`vip_level`,`birthday`,`avatar`,`post_count`,`comment_count`,`status`,`lasted`,`created`,`modified`) values (1,'guoshizhan','e10adc3949ba59abbe56e057f20f883e','12345678@qq.com',NULL,0,'关注公众号：MarkerHub，一起学Java！！','0',NULL,0,NULL,'/res/images/avatar/5.jpg',0,0,0,'2020-07-20 17:08:30','2020-04-28 14:37:24',NULL),(2,'test007','96e79218965eb72c92a549dd5a330112','1111@qq.com',NULL,0,NULL,'0',NULL,0,NULL,'/res/images/avatar/default.png',0,0,0,NULL,'2020-04-28 14:45:07',NULL),(3,'test004','96e79218965eb72c92a549dd5a330112','144d11@qq.com',NULL,0,NULL,'0',NULL,0,NULL,'/res/images/avatar/default.png',0,0,0,NULL,'2020-04-28 14:48:26',NULL),(4,'test005','96e79218965eb72c92a549dd5a330112','144d15@qq.com',NULL,0,NULL,'0',NULL,0,NULL,'/res/images/avatar/default.png',0,0,0,NULL,'2020-04-28 14:48:26',NULL),(5,'test00756','96e79218965eb72c92a549dd5a330112','45454541@qq.com',NULL,0,NULL,'0',NULL,0,NULL,'/res/images/avatar/default.png',0,0,0,NULL,'2020-04-28 14:53:49',NULL),(6,'guoshizhanddddd','e10adc3949ba59abbe56e057f20f883e','1223233@qq.com',NULL,0,NULL,'0',NULL,0,NULL,'/res/images/avatar/default.png',0,0,0,NULL,'2020-07-18 14:48:04',NULL),(7,'hexueqin','e10adc3949ba59abbe56e057f20f883e','123456@qq.com',NULL,0,'物品，一起学 Java！！','1',NULL,0,NULL,'/res/images/avatar/default.png',0,0,0,'2020-07-19 12:43:59','2020-07-18 22:57:55',NULL);/*Table structure for table `m_user_action` */DROP TABLE IF EXISTS `user_action`;CREATE TABLE `user_action` ( `id` varchar(32) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '', `user_id` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '用户ID', `action` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '动作类型', `point` int(11) DEFAULT NULL COMMENT '得分', `post_id` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '关联的帖子ID', `comment_id` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '关联的评论ID', `created` datetime DEFAULT NULL, `modified` datetime DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;/*Data for the table `m_user_action` *//*Table structure for table `m_user_collection` */DROP TABLE IF EXISTS `user_collection`;CREATE TABLE `user_collection` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `user_id` bigint(20) NOT NULL, `post_id` bigint(20) NOT NULL, `post_user_id` bigint(20) NOT NULL, `created` datetime NOT NULL, `modified` datetime NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;/*Data for the table `m_user_collection` */insert into `user_collection`(`id`,`user_id`,`post_id`,`post_user_id`,`created`,`modified`) values (1,1,1,1,'2020-07-14 00:00:00','2020-07-14 00:00:00'),(2,1,2,1,'2020-07-15 00:00:00','2020-07-15 00:00:00'),(3,1,3,1,'2020-07-15 00:00:00','2020-07-15 00:00:00');/*Table structure for table `m_user_message` */DROP TABLE IF EXISTS `user_message`;CREATE TABLE `user_message` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `from_user_id` bigint(20) NOT NULL COMMENT '发送消息的用户ID', `to_user_id` bigint(20) NOT NULL COMMENT '接收消息的用户ID', `post_id` bigint(20) DEFAULT NULL COMMENT '消息可能关联的帖子', `comment_id` bigint(20) DEFAULT NULL COMMENT '消息可能关联的评论', `content` text COLLATE utf8mb4_unicode_ci, `type` tinyint(2) DEFAULT NULL COMMENT '消息类型', `created` datetime NOT NULL, `modified` datetime DEFAULT NULL, `status` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;/*Data for the table `m_user_message` */insert into `user_message`(`id`,`from_user_id`,`to_user_id`,`post_id`,`comment_id`,`content`,`type`,`created`,`modified`,`status`) values (1,1,2,1,1,'天上掉下个猪八戒',1,'2020-07-15 00:00:00','2020-07-15 00:00:00',1);/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; 下载 fly 社区模板我们首先需要下载 fly 社区的模板 。具体如下图所示： 把下载好的 fly 模板解压之后如下图： 新建 Spring Boot 工程如何创建 Spring Boot 工程这里就不多说了。我们主要看 pom.xml 里面的的依赖。代码如下： pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;club.guoshizhan&lt;/groupId&gt; &lt;artifactId&gt;Layui-Blog&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;!--netty--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--mp--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--代码生成器--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- sql分析器 --&gt; &lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;3.8.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- commons-lang3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;4.1.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 接下来的步骤：通过阅读下列文字完成相关的操作 。步骤如下： 12345678+++ 接下来的步骤+ 1、在 templates 目录下新建首页模板页面文件 index.ftl ，因为使用了 freemarker 模板 ，所以后缀为 ftl 。+ 2、然后把下载的 fly 社区模板 html 文件夹里的 index.html 的内容复制到我们新建的 index.ftl 里面。+ 3、最后把 res 整个文件夹复制到项目的 static 目录下。+ 4、在 guoshizhan 包下新建 controller 包，前端控制器都写在这个包下。+++ 接下来的步骤 接下来在 controller 包 下新建 BaseController 类 【作为一个基类】。代码如下： 123456789package club.guoshizhan.controller;/** * @Author: guoshizhan * @Create: 2020/7/27 10:11 * @Description: 基类，存放公共部分 */public class BaseController {} 然后在 controller 包 下新建 IndexController 类 【首页控制器】。代码如下： 12345678910111213141516171819package club.guoshizhan.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * @Author: guoshizhan * @Create: 2020/7/27 10:12 * @Description: 首页控制器 */@Controllerpublic class IndexController extends BaseController { @RequestMapping({\"\", \"/\", \"/index\"}) public String index() { return \"index\"; }} 编写配置文件 application.yml ，配置数据库连接 。代码如下： application.yml1234567# MySQL 数据库连接spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/layui_blog?serverTimezone=GMT%2B8 username: root password: root 注意啦！！！ 1、我们使用的 Spring boot 版本是 2.1.2 ，用这个版本主要是稳定。2、一定要先在配置文件 application.yml 里面 配置好数据库连接 之后再启动项目，否则会报错。 启动项目启动我们的 LayuiBlogApplication 启动类，代码如下： 123456789101112131415161718package club.guoshizhan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @Author: guoshizhan * @Create: 2020/7/26 23:44 * @Description: Layui-Blog 的启动类 */@SpringBootApplicationpublic class LayuiBlogApplication { public static void main(String[] args) { SpringApplication.run(LayuiBlogApplication.class, args); // 加入这行代码目的：让我们无需在浏览器输入地址，而是在控制台点击即可进入到项目 System.out.println(\"\\n项目的访问地址： http://localhost:8080\\n\"); }} 启动之后的效果如下图： 项目的最终目录结构，如下图： 到此为止，前期准备已经结束！！！这里注意一下下列问题： 如果启动项目后，访问的页面无法加载样式，这个问题可能会出现。我的做法是：把 res 文件夹改为其他名字。例如：sdfajsdlfkj。然后启动一次项目，这个肯定是没有样式的，然后去访问一次。访问完之后再把 sdfajsdlfkj 名字改回原来的 res ，再次重启项目，就有样式了。这个做法在我的机子上是成功的。 完善首页模块划分模块划分 就是把公共的部分给抽取出来成为一个模块 ，以后的页面需要这个模块时，把它引入即可。接下来就开始进行操作吧！！！ 第一步： 在 templates 目录 下新建 include 目录 ，然后在 include 目录 下新建 header.ftl 文件，把如下代码复制到里面【这部分代码就剪切自 index.ftl 页面的头部】： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;div class=\"fly-header layui-bg-black\"&gt; &lt;div class=\"layui-container\"&gt; &lt;a class=\"fly-logo\" href=\"/\"&gt; &lt;img src=\"/res/images/logo.png\" alt=\"layui\"&gt; &lt;/a&gt; &lt;ul class=\"layui-nav\" lay-filter=\"\" style=\"margin-left: 180px;\"&gt; &lt;li class=\"layui-nav-item\"&gt;&lt;a href=\"\"&gt;博客首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"layui-nav-item layui-this\"&gt;&lt;a href=\"\"&gt;归档&lt;/a&gt;&lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt;&lt;a href=\"\"&gt;分类&lt;/a&gt;&lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt;&lt;a href=\"\"&gt;标签&lt;/a&gt;&lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt;&lt;a href=\"\"&gt;友情链接&lt;/a&gt;&lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt; &lt;a href=\"javascript:;\"&gt;实验室&lt;/a&gt; &lt;dl class=\"layui-nav-child\"&gt; &lt;!-- 二级菜单 --&gt; &lt;dd&gt;&lt;a href=\"\"&gt;移动模块&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"\"&gt;后台模版&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"\"&gt;电商平台&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"\"&gt;相册&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"\"&gt;影音&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"\"&gt;关于&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"\"&gt;私密&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"\"&gt;随笔&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt;&lt;a href=\"\"&gt;社区&lt;/a&gt;&lt;/li&gt; &lt;li class=\"layui-nav-item layui-this\"&gt;&lt;a href=\"\"&gt;发表博客&lt;/a&gt;&lt;/li&gt; &lt;li class=\"layui-nav-item layui-this\"&gt; &lt;span class=\"fly-search\"&gt;&lt;i class=\"layui-icon\"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;#--&lt;ul class=\"layui-nav fly-nav layui-hide-xs\"&gt; &lt;li class=\"layui-nav-item layui-this\"&gt; &lt;a href=\"/pages/catalog\"&gt; &lt;i class=\"iconfont icon-jiaoliu\"&gt;&lt;/i&gt; 站点导航 &lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt; &lt;a href=\"/pages/catalog\"&gt; &lt;i class=\"iconfont icon-iconmingxinganli\"&gt;&lt;/i&gt; 文章分类 &lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt; &lt;a href=\"javascript:;\"&gt;解决方案&lt;/a&gt; &lt;dl class=\"layui-nav-child\" style=\"z-index: 999999px;\"&gt; &lt;!-- 二级菜单 &amp;ndash;&amp;gt; &lt;dd&gt;&lt;a href=\"\"&gt;移动模块&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"\"&gt;后台模版&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"http://www.layui.com/\" target=\"_blank\"&gt;Layui 框架&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"/pages/custom\"&gt;时间轴&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"\"&gt;电商平台&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item layui-this\"&gt; &lt;a href=\"/pages/add\"&gt; 发表博客 &lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item layui-this\"&gt; &lt;span class=\"fly-search\"&gt;&lt;i class=\"layui-icon\"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt;--&gt; &lt;ul class=\"layui-nav fly-nav-user\"&gt; &lt;!-- 未登入的状态 --&gt; &lt;#--&lt;li class=\"layui-nav-item\"&gt; &lt;a class=\"iconfont icon-touxiang layui-hide-xs\" href=\"/pages/login\"&gt;&lt;/a&gt; &lt;/li&gt;--&gt; &lt;li class=\"layui-nav-item\"&gt;&lt;a href=\"/pages/login\"&gt;登入&lt;/a&gt;&lt;/li&gt; &lt;li class=\"layui-nav-item\" style=\"color: rgba(255,255,255,.7);\"&gt; | &lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt;&lt;a href=\"/pages/reg\"&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;#--&lt;li class=\"layui-nav-item layui-hide-xs\"&gt; &lt;a href=\"/app/qq/\" onclick=\"layer.msg('正在通过QQ登入', {icon:16, shade: 0.1, time:0})\" title=\"QQ登入\" class=\"iconfont icon-qq\"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item layui-hide-xs\"&gt; &lt;a href=\"/app/weibo/\" onclick=\"layer.msg('正在通过微博登入', {icon:16, shade: 0.1, time:0})\" title=\"微博登入\" class=\"iconfont icon-weibo\"&gt;&lt;/a&gt; &lt;/li&gt;--&gt; &lt;!-- 登入后的状态 --&gt; &lt;!-- &lt;li class=\"layui-nav-item\"&gt; &lt;a class=\"fly-nav-avatar\" href=\"javascript:;\"&gt; &lt;cite class=\"layui-hide-xs\"&gt;贤心&lt;/cite&gt; &lt;i class=\"iconfont icon-renzheng layui-hide-xs\" title=\"认证信息：layui 作者\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip layui-hide-xs\"&gt;VIP3&lt;/i&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\"&gt; &lt;/a&gt; &lt;dl class=\"layui-nav-child\"&gt; &lt;dd&gt;&lt;a href=\"user/set.html\"&gt;&lt;i class=\"layui-icon\"&gt;&amp;#xe620;&lt;/i&gt;基本设置&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"user/message.html\"&gt;&lt;i class=\"iconfont icon-tongzhi\" style=\"top: 4px;\"&gt;&lt;/i&gt;我的消息&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"user/home.html\"&gt;&lt;i class=\"layui-icon\" style=\"margin-left: 2px; font-size: 22px;\"&gt;&amp;#xe68e;&lt;/i&gt;我的主页&lt;/a&gt;&lt;/dd&gt; &lt;hr style=\"margin: 5px 0;\"&gt; &lt;dd&gt;&lt;a href=\"/user/logout/\" style=\"text-align: center;\"&gt;退出&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/li&gt; --&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;div style=\"width: 100%;height: 15px;\"&gt;&lt;/div&gt; 第二步： 在 include 目录 下新建 footer.ftl 文件，把如下代码复制到里面【这部分代码就剪切自 index.ftl 页面的底部】： 1234567891011&lt;div class=\"fly-footer\"&gt; &lt;p&gt; &lt;a href=\"http://fly.layui.com/\" target=\"_blank\"&gt;Fly 社区&lt;/a&gt; 2020 &amp;copy; &lt;a href=\"http://www.layui.com/\" target=\"_blank\"&gt;layui.com 出品&lt;/a&gt; &lt;/p&gt; &lt;p&gt; &lt;a href=\"http://fly.layui.com/jie/3147/\" target=\"_blank\"&gt;付费计划&lt;/a&gt; &lt;a href=\"http://www.layui.com/template/fly/\" target=\"_blank\"&gt;获取 Fly 社区模版&lt;/a&gt; &lt;a href=\"http://fly.layui.com/jie/2461/\" target=\"_blank\"&gt;微信公众号&lt;/a&gt; &lt;/p&gt;&lt;/div&gt; 第三步： 在 include 目录 下新建 left.ftl 文件，把如下代码复制到里面【这部分代码就剪切自 index.ftl 页面的中间部分的右侧（md4 那一块），但是我喜欢把更窄的放在左边，所以命名为 left.ftl】： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172&lt;div class=\"layui-col-md3\"&gt; &lt;div class=\"fly-panel\" style=\"padding: 20px 5px; text-align: center;\"&gt; &lt;div style=\"width: 100%;border-bottom: 1px solid #393D49;height: 100px;\"&gt; &lt;div style=\"width: 30%;height: 100px;float: left;\"&gt; &lt;a href=\"/\"&gt;&lt;img src=\"../../res/images/avatar/5.jpg\" style=\"width: 80px; height: 80px;border-radius: 40px;\" alt=\"layui\"&gt;&lt;/a&gt; &lt;/div&gt; &lt;div style=\"width: 70%;height: 100px;float: left;\"&gt; &lt;h2&gt;何年の再遇见&lt;/h2&gt; &lt;p style=\"position: relative; color: #666;\"&gt;愿你走出半生，归来仍是少年&lt;/p&gt; &lt;p style=\"position: relative; color: #666;\"&gt; &lt;i class=\"layui-icon\"&gt;&lt;/i&gt; 井冈山大学 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style=\"width: 100%;border-bottom: 1px solid #393D49;height: 70px;\"&gt; &lt;table style=\"width: 100%;height: 70px;\"&gt; &lt;tr&gt;&lt;td&gt;文章&lt;/td&gt;&lt;td&gt;分类&lt;/td&gt;&lt;td&gt;标签&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;32&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;&lt;td&gt;43&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;p id=\"hitokoto\" style=\"color: #666;text-align: center;padding-top: 20px;\"&gt; 一言句子获取中…… &lt;/p&gt; &lt;script src=\"https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto\"&gt;&lt;/script&gt; &lt;/div&gt; &lt;style&gt; .fly-panel .fly-panel-main li { padding: 3px 0; list-style: none; margin-bottom: 3px; } .fly-panel .fly-panel-main li:hover { background: #fff9ec; /*cursor: pointer;*/ } .fly-panel .fly-panel-main li span { margin-right: 8px; padding: 0 10px; float: right; border-radius: 9999px; color: white; background: #5FB878; } .fly-panel .fly-panel-main li a { text-decoration: none; color: #000; } &lt;/style&gt; &lt;div class=\"fly-panel\"&gt; &lt;h3 class=\"fly-panel-title\" style=\"color: #7a7a7a;\"&gt;博客文章分类&lt;/h3&gt; &lt;ul class=\"fly-panel-main fly-list-static\"&gt; &lt;#--&lt;#list categories as item&gt; &lt;li style=\"list-style: none\"&gt; &lt;a href=\"/post/category/${item.id}\"&gt;${item.name}&lt;/a&gt; &lt;span&gt;${item.postCount}&lt;/span&gt; &lt;/li&gt; &lt;/#list&gt;--&gt; &lt;li style=\"list-style: none\"&gt; &lt;a href=\"http://fly.layui.com/jie/4281/\" target=\"_blank\"&gt;Java 学习&lt;/a&gt; &lt;span&gt;8&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"http://fly.layui.com/jie/5366/\" target=\"_blank\"&gt; 数据结构与算法 &lt;/a&gt; &lt;span&gt; 5 &lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"http://fly.layui.com/jie/4281/\" target=\"_blank\"&gt; 数据库 &lt;/a&gt; &lt;span&gt; 3 &lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"http://fly.layui.com/jie/5366/\" target=\"_blank\"&gt; 计算机网络 &lt;/a&gt; &lt;span&gt; 2 &lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"fly-panel fly-signin\"&gt; &lt;div class=\"fly-panel-title\"&gt; 签到 &lt;span class=\"fly-signin-days\"&gt;已连续签到&lt;cite&gt;16&lt;/cite&gt;天&lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-panel-main fly-signin-main\"&gt; &lt;button class=\"layui-btn layui-btn-danger\" id=\"LAY_signin\"&gt;今日签到&lt;/button&gt; &lt;span&gt;可获得&lt;cite&gt;5&lt;/cite&gt;飞吻&lt;/span&gt; &lt;!-- 已签到状态 --&gt; &lt;!-- &lt;button class=\"layui-btn layui-btn-disabled\"&gt;今日已签到&lt;/button&gt; &lt;span&gt;获得了&lt;cite&gt;20&lt;/cite&gt;飞吻&lt;/span&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"fly-panel fly-rank fly-rank-reply\" id=\"LAY_replyRank\"&gt; &lt;h3 class=\"fly-panel-title\"&gt;回贴周榜&lt;/h3&gt; &lt;dl&gt; &lt;!--&lt;i class=\"layui-icon fly-loading\"&gt;&amp;#xe63d;&lt;/i&gt;--&gt; &lt;dd&gt; &lt;a href=\"user/home.html\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\"&gt;&lt;cite&gt;贤心&lt;/cite&gt;&lt;i&gt;106次回答&lt;/i&gt; &lt;/a&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"user/home.html\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\"&gt;&lt;cite&gt;贤心&lt;/cite&gt;&lt;i&gt;106次回答&lt;/i&gt; &lt;/a&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;dl class=\"fly-panel fly-list-one\"&gt; &lt;dt class=\"fly-panel-title\"&gt;本周热议&lt;/dt&gt; &lt;dd&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;!-- 无数据时 --&gt; &lt;!-- &lt;div class=\"fly-none\"&gt;没有相关数据&lt;/div&gt; --&gt; &lt;/dl&gt; &lt;div class=\"fly-panel\"&gt; &lt;div class=\"fly-panel-title\"&gt; 这里可作为广告区域 &lt;/div&gt; &lt;div class=\"fly-panel-main\"&gt; &lt;a href=\"http://layim.layui.com/?from=fly\" target=\"_blank\" class=\"fly-zanzhu\" time-limit=\"2017.09.25-2099.01.01\" style=\"background-color: #5FB878;\"&gt;LayIM 3.0 - layui 旗舰之作&lt;/a&gt; &lt;/div&gt; &lt;div class=\"fly-panel-main\"&gt; &lt;a href=\"\" target=\"_blank\" class=\"fly-zanzhu\" style=\"background-color: #393D49;\"&gt;虚席以待&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"fly-panel fly-link\"&gt; &lt;h3 class=\"fly-panel-title\"&gt;友情链接&lt;/h3&gt; &lt;dl class=\"fly-panel-main\"&gt; &lt;dd&gt;&lt;a href=\"http://www.layui.com/\" target=\"_blank\"&gt;layui&lt;/a&gt;&lt;dd&gt; &lt;dd&gt;&lt;a href=\"http://www.layui.com/laydate/\" target=\"_blank\"&gt;layDate&lt;/a&gt;&lt;dd&gt; &lt;dd&gt;&lt;a href=\"mailto:xianxin@layui-inc.com?subject=%E7%94%B3%E8%AF%B7Fly%E7%A4%BE%E5%8C%BA%E5%8F%8B%E9%93%BE\" class=\"fly-link\"&gt;申请友链&lt;/a&gt;&lt;dd&gt; &lt;/dl&gt; &lt;/div&gt;&lt;/div&gt; 开启热部署： settings –&gt; Build –&gt; compiler –&gt; build project automatically 第四步： 在 include 目录 下新建 layout.ftl 文件，用于定义宏 ，即一个通用模块，在任何页面都适用。如何定义以及其他介绍都写在代码里面了。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;#macro layout title&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;${title}&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;meta name=\"keywords\" content=\"何年の再遇见\"&gt; &lt;meta name=\"description\" content=\"何年の再遇见\"&gt; &lt;link rel=\"stylesheet\" href=\"/res/layui/css/layui.css\"&gt; &lt;link rel=\"stylesheet\" href=\"/res/css/global.css\"&gt; &lt;script src=\"/res/layui/layui.all.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;style&gt; *{font-family: SimSun;} &lt;/style&gt; &lt;body&gt; &lt;#--&lt;#include \"common.ftl\" /&gt;--&gt; &lt;#include \"header.ftl\" /&gt; &lt;#nested /&gt; &lt;#include \"footer.ftl\" /&gt; &lt;script src=\"/res/layui/layui.js\"&gt;&lt;/script&gt; &lt;script&gt; // layui.cache.page = ''; layui.cache.user = { username: '游客' ,uid: -1 ,avatar: '../res/images/avatar/00.jpg' ,experience: 83 ,sex: '男' }; layui.config({ version: \"3.0.0\" ,base: '../res/mods/' // 这里实际使用时，建议改成绝对路径 }).extend({ fly: 'index' }).use('fly'); &lt;/script&gt; &lt;script type=\"text/javascript\"&gt;var cnzz_protocol = ((\"https:\" == document.location.protocol) ? \" https://\" : \" http://\");document.write(unescape(\"%3Cspan id='cnzz_stat_icon_30088308'%3E%3C/span%3E%3Cscript src='\" + cnzz_protocol + \"w.cnzz.com/c.php%3Fid%3D30088308' type='text/javascript'%3E%3C/script%3E\"));&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;&lt;/#macro&gt; 第五步： 清空 index.ftl 的内容，然后把以下代码复制进去 。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505&lt;#include \"include/layout.ftl\" /&gt;&lt;@layout \"何年の再遇见-博客首页\"&gt;&lt;#include \"include/header.ftl\"&gt;&lt;div class=\"layui-container\"&gt; &lt;div class=\"layui-row layui-col-space10\"&gt; &lt;#include 'include/left.ftl'&gt; &lt;div class=\"layui-col-md9\"&gt; &lt;div class=\"fly-panel\"&gt; &lt;div class=\"fly-panel-title fly-filter\"&gt; &lt;a&gt;置顶&lt;/a&gt; &lt;a href=\"#signin\" class=\"layui-hide-sm layui-show-xs-block fly-right\" id=\"LAY_goSignin\" style=\"color: #FF5722;\"&gt;去签到&lt;/a&gt; &lt;/div&gt; &lt;ul class=\"fly-list\"&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!-- &lt;span class=\"layui-badge layui-bg-black\"&gt;置顶&lt;/span&gt; &lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt; --&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;公告&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;2017-11-30&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!-- &lt;span class=\"layui-badge layui-bg-black\"&gt;置顶&lt;/span&gt; &lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt; --&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;公告&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!-- &lt;span class=\"layui-badge layui-bg-black\"&gt;置顶&lt;/span&gt; &lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt; --&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;公告&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!-- &lt;span class=\"layui-badge layui-bg-black\"&gt;置顶&lt;/span&gt; &lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt; --&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"fly-panel\" style=\"margin-bottom: 0;\"&gt; &lt;div class=\"fly-panel-title fly-filter\"&gt; &lt;a href=\"\" class=\"layui-this\"&gt;综合&lt;/a&gt; &lt;span class=\"fly-mid\"&gt;&lt;/span&gt; &lt;a href=\"\"&gt;未结&lt;/a&gt; &lt;span class=\"fly-mid\"&gt;&lt;/span&gt; &lt;a href=\"\"&gt;已结&lt;/a&gt; &lt;span class=\"fly-mid\"&gt;&lt;/span&gt; &lt;a href=\"\"&gt;精华&lt;/a&gt; &lt;span class=\"fly-filter-right layui-hide-xs\"&gt; &lt;a href=\"\" class=\"layui-this\"&gt;按最新&lt;/a&gt; &lt;span class=\"fly-mid\"&gt;&lt;/span&gt; &lt;a href=\"\"&gt;按热议&lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;ul class=\"fly-list\"&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;分享&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!--&lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt;--&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"jie/detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div style=\"text-align: center\"&gt; &lt;div class=\"laypage-main\"&gt; &lt;a href=\"jie/index.html\" class=\"laypage-next\"&gt;更多求解&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/@layout&gt; 接着启动项目，看到的结果如下图： 到此为止，模块划分就结束了，以后的页面划分模块和这里的步骤是一样的。所以以后就不再说了。 博客分类数据填充第一步： 在 templates 目录 下新建 post 目录 ，然后在 post 目录 下新建 category.ftl 文件和 detail.ftl 文件。 然后把下载的模板 html/jie/index.html 的内容复制到 category.ftl 文件，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;基于 layui 的极简社区页面模版&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;meta name=\"keywords\" content=\"fly,layui,前端社区\"&gt; &lt;meta name=\"description\" content=\"Fly社区是模块化前端UI框架Layui的官网社区，致力于为web开发提供强劲动力\"&gt; &lt;link rel=\"stylesheet\" href=\"../../res/layui/css/layui.css\"&gt; &lt;link rel=\"stylesheet\" href=\"../../res/css/global.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"fly-header layui-bg-black\"&gt; &lt;div class=\"layui-container\"&gt; &lt;a class=\"fly-logo\" href=\"/\"&gt; &lt;img src=\"../../res/images/logo.png\" alt=\"layui\"&gt; &lt;/a&gt; &lt;ul class=\"layui-nav fly-nav layui-hide-xs\"&gt; &lt;li class=\"layui-nav-item layui-this\"&gt; &lt;a href=\"/\"&gt;&lt;i class=\"iconfont icon-jiaoliu\"&gt;&lt;/i&gt;交流&lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt; &lt;a href=\"../case/case.html\"&gt;&lt;i class=\"iconfont icon-iconmingxinganli\"&gt;&lt;/i&gt;案例&lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt; &lt;a href=\"http://www.layui.com/\" target=\"_blank\"&gt;&lt;i class=\"iconfont icon-ui\"&gt;&lt;/i&gt;框架&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"layui-nav fly-nav-user\"&gt; &lt;!-- 未登入的状态 --&gt; &lt;li class=\"layui-nav-item\"&gt; &lt;a class=\"iconfont icon-touxiang layui-hide-xs\" href=\"user/login.html\"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt; &lt;a href=\"user/login.html\"&gt;登入&lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt; &lt;a href=\"user/reg.html\"&gt;注册&lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item layui-hide-xs\"&gt; &lt;a href=\"/app/qq/\" onclick=\"layer.msg('正在通过QQ登入', {icon:16, shade: 0.1, time:0})\" title=\"QQ登入\" class=\"iconfont icon-qq\"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item layui-hide-xs\"&gt; &lt;a href=\"/app/weibo/\" onclick=\"layer.msg('正在通过微博登入', {icon:16, shade: 0.1, time:0})\" title=\"微博登入\" class=\"iconfont icon-weibo\"&gt;&lt;/a&gt; &lt;/li&gt; &lt;!-- 登入后的状态 --&gt; &lt;!-- &lt;li class=\"layui-nav-item\"&gt; &lt;a class=\"fly-nav-avatar\" href=\"javascript:;\"&gt; &lt;cite class=\"layui-hide-xs\"&gt;贤心&lt;/cite&gt; &lt;i class=\"iconfont icon-renzheng layui-hide-xs\" title=\"认证信息：layui 作者\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip layui-hide-xs\"&gt;VIP3&lt;/i&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\"&gt; &lt;/a&gt; &lt;dl class=\"layui-nav-child\"&gt; &lt;dd&gt;&lt;a href=\"../user/set.html\"&gt;&lt;i class=\"layui-icon\"&gt;&amp;#xe620;&lt;/i&gt;基本设置&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"../user/message.html\"&gt;&lt;i class=\"iconfont icon-tongzhi\" style=\"top: 4px;\"&gt;&lt;/i&gt;我的消息&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"../user/home.html\"&gt;&lt;i class=\"layui-icon\" style=\"margin-left: 2px; font-size: 22px;\"&gt;&amp;#xe68e;&lt;/i&gt;我的主页&lt;/a&gt;&lt;/dd&gt; &lt;hr style=\"margin: 5px 0;\"&gt; &lt;dd&gt;&lt;a href=\"\" style=\"text-align: center;\"&gt;退出&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/li&gt; --&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"fly-panel fly-column\"&gt; &lt;div class=\"layui-container\"&gt; &lt;ul class=\"layui-clear\"&gt; &lt;li class=\"layui-hide-xs\"&gt;&lt;a href=\"/\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"layui-this\"&gt;&lt;a href=\"\"&gt;提问&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;分享&lt;span class=\"layui-badge-dot\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;讨论&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;建议&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;公告&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;动态&lt;/a&gt;&lt;/li&gt; &lt;li class=\"layui-hide-xs layui-hide-sm layui-show-md-inline-block\"&gt;&lt;span class=\"fly-mid\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;!-- 用户登入后显示 --&gt; &lt;li class=\"layui-hide-xs layui-hide-sm layui-show-md-inline-block\"&gt;&lt;a href=\"../user/index.html\"&gt;我发表的贴&lt;/a&gt;&lt;/li&gt; &lt;li class=\"layui-hide-xs layui-hide-sm layui-show-md-inline-block\"&gt;&lt;a href=\"../user/index.html#collection\"&gt;我收藏的贴&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"fly-column-right layui-hide-xs\"&gt; &lt;span class=\"fly-search\"&gt;&lt;i class=\"layui-icon\"&gt;&lt;/i&gt;&lt;/span&gt; &lt;a href=\"add.html\" class=\"layui-btn\"&gt;发表新帖&lt;/a&gt; &lt;/div&gt; &lt;div class=\"layui-hide-sm layui-show-xs-block\" style=\"margin-top: -10px; padding-bottom: 10px; text-align: center;\"&gt; &lt;a href=\"add.html\" class=\"layui-btn\"&gt;发表新帖&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"layui-container\"&gt; &lt;div class=\"layui-row layui-col-space15\"&gt; &lt;div class=\"layui-col-md8\"&gt; &lt;div class=\"fly-panel\" style=\"margin-bottom: 0;\"&gt; &lt;div class=\"fly-panel-title fly-filter\"&gt; &lt;a href=\"\" class=\"layui-this\"&gt;综合&lt;/a&gt; &lt;span class=\"fly-mid\"&gt;&lt;/span&gt; &lt;a href=\"\"&gt;未结&lt;/a&gt; &lt;span class=\"fly-mid\"&gt;&lt;/span&gt; &lt;a href=\"\"&gt;已结&lt;/a&gt; &lt;span class=\"fly-mid\"&gt;&lt;/span&gt; &lt;a href=\"\"&gt;精华&lt;/a&gt; &lt;span class=\"fly-filter-right layui-hide-xs\"&gt; &lt;a href=\"\" class=\"layui-this\"&gt;按最新&lt;/a&gt; &lt;span class=\"fly-mid\"&gt;&lt;/span&gt; &lt;a href=\"\"&gt;按热议&lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;ul class=\"fly-list\"&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;分享&lt;/a&gt; &lt;a href=\"detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;span class=\"layui-badge layui-bg-black\"&gt;置顶&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!--&lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt;--&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"user/home.html\" class=\"fly-avatar\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;h2&gt; &lt;a class=\"layui-badge\"&gt;动态&lt;/a&gt; &lt;a href=\"detail.html\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;/h2&gt; &lt;div class=\"fly-list-info\"&gt; &lt;a href=\"user/home.html\" link&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;!-- &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; --&gt; &lt;/a&gt; &lt;span&gt;刚刚&lt;/span&gt; &lt;span class=\"fly-list-kiss layui-hide-xs\" title=\"悬赏飞吻\"&gt;&lt;i class=\"iconfont icon-kiss\"&gt;&lt;/i&gt; 60&lt;/span&gt; &lt;!--&lt;span class=\"layui-badge fly-badge-accept layui-hide-xs\"&gt;已结&lt;/span&gt;--&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;i class=\"iconfont icon-pinglun1\" title=\"回答\"&gt;&lt;/i&gt; 66 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"fly-list-badge\"&gt; &lt;!--&lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt;--&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- &lt;div class=\"fly-none\"&gt;没有相关数据&lt;/div&gt; --&gt; &lt;div style=\"text-align: center\"&gt; &lt;div class=\"laypage-main\"&gt;&lt;span class=\"laypage-curr\"&gt;1&lt;/span&gt;&lt;a href=\"/jie/page/2/\"&gt;2&lt;/a&gt;&lt;a href=\"/jie/page/3/\"&gt;3&lt;/a&gt;&lt;a href=\"/jie/page/4/\"&gt;4&lt;/a&gt;&lt;a href=\"/jie/page/5/\"&gt;5&lt;/a&gt;&lt;span&gt;…&lt;/span&gt;&lt;a href=\"/jie/page/148/\" class=\"laypage-last\" title=\"尾页\"&gt;尾页&lt;/a&gt;&lt;a href=\"/jie/page/2/\" class=\"laypage-next\"&gt;下一页&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;dl class=\"fly-panel fly-list-one\"&gt; &lt;dt class=\"fly-panel-title\"&gt;本周热议&lt;/dt&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;!-- 无数据时 --&gt; &lt;!-- &lt;div class=\"fly-none\"&gt;没有相关数据&lt;/div&gt; --&gt; &lt;/dl&gt; &lt;div class=\"fly-panel\"&gt; &lt;div class=\"fly-panel-title\"&gt; 这里可作为广告区域 &lt;/div&gt; &lt;div class=\"fly-panel-main\"&gt; &lt;a href=\"\" target=\"_blank\" class=\"fly-zanzhu\" style=\"background-color: #393D49;\"&gt;虚席以待&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"fly-panel fly-link\"&gt; &lt;h3 class=\"fly-panel-title\"&gt;友情链接&lt;/h3&gt; &lt;dl class=\"fly-panel-main\"&gt; &lt;dd&gt;&lt;a href=\"http://www.layui.com/\" target=\"_blank\"&gt;layui&lt;/a&gt;&lt;dd&gt; &lt;dd&gt;&lt;a href=\"http://layim.layui.com/\" target=\"_blank\"&gt;WebIM&lt;/a&gt;&lt;dd&gt; &lt;dd&gt;&lt;a href=\"http://layer.layui.com/\" target=\"_blank\"&gt;layer&lt;/a&gt;&lt;dd&gt; &lt;dd&gt;&lt;a href=\"http://www.layui.com/laydate/\" target=\"_blank\"&gt;layDate&lt;/a&gt;&lt;dd&gt; &lt;dd&gt;&lt;a href=\"mailto:xianxin@layui-inc.com?subject=%E7%94%B3%E8%AF%B7Fly%E7%A4%BE%E5%8C%BA%E5%8F%8B%E9%93%BE\" class=\"fly-link\"&gt;申请友链&lt;/a&gt;&lt;dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"fly-footer\"&gt; &lt;p&gt;&lt;a href=\"http://fly.layui.com/\" target=\"_blank\"&gt;Fly社区&lt;/a&gt; 2017 &amp;copy; &lt;a href=\"http://www.layui.com/\" target=\"_blank\"&gt;layui.com 出品&lt;/a&gt;&lt;/p&gt; &lt;p&gt; &lt;a href=\"http://fly.layui.com/jie/3147/\" target=\"_blank\"&gt;付费计划&lt;/a&gt; &lt;a href=\"http://www.layui.com/template/fly/\" target=\"_blank\"&gt;获取Fly社区模版&lt;/a&gt; &lt;a href=\"http://fly.layui.com/jie/2461/\" target=\"_blank\"&gt;微信公众号&lt;/a&gt; &lt;/p&gt;&lt;/div&gt;&lt;script src=\"../../res/layui/layui.js\"&gt;&lt;/script&gt;&lt;script&gt;layui.cache.page = 'jie';layui.cache.user = { username: '游客' ,uid: -1 ,avatar: '../../res/images/avatar/00.jpg' ,experience: 83 ,sex: '男'};layui.config({ version: \"3.0.0\" ,base: '../../res/mods/'}).extend({ fly: 'index'}).use('fly');&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最后把下载的模板 html/jie/detail.html 的内容复制到 detail.ftl 文件，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Fly Template v3.0，基于 layui 的极简社区页面模版&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;meta name=\"keywords\" content=\"fly,layui,前端社区\"&gt; &lt;meta name=\"description\" content=\"Fly社区是模块化前端UI框架Layui的官网社区，致力于为web开发提供强劲动力\"&gt; &lt;link rel=\"stylesheet\" href=\"../../res/layui/css/layui.css\"&gt; &lt;link rel=\"stylesheet\" href=\"../../res/css/global.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"fly-header layui-bg-black\"&gt; &lt;div class=\"layui-container\"&gt; &lt;a class=\"fly-logo\" href=\"/\"&gt; &lt;img src=\"../../res/images/logo.png\" alt=\"layui\"&gt; &lt;/a&gt; &lt;ul class=\"layui-nav fly-nav layui-hide-xs\"&gt; &lt;li class=\"layui-nav-item layui-this\"&gt; &lt;a href=\"/\"&gt;&lt;i class=\"iconfont icon-jiaoliu\"&gt;&lt;/i&gt;交流&lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt; &lt;a href=\"../case/case.html\"&gt;&lt;i class=\"iconfont icon-iconmingxinganli\"&gt;&lt;/i&gt;案例&lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt; &lt;a href=\"http://www.layui.com/\" target=\"_blank\"&gt;&lt;i class=\"iconfont icon-ui\"&gt;&lt;/i&gt;框架&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"layui-nav fly-nav-user\"&gt; &lt;!-- 未登入的状态 --&gt; &lt;!-- &lt;li class=\"layui-nav-item\"&gt; &lt;a class=\"iconfont icon-touxiang layui-hide-xs\" href=\"user/login.html\"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt; &lt;a href=\"user/login.html\"&gt;登入&lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item\"&gt; &lt;a href=\"user/reg.html\"&gt;注册&lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item layui-hide-xs\"&gt; &lt;a href=\"/app/qq/\" onclick=\"layer.msg('正在通过QQ登入', {icon:16, shade: 0.1, time:0})\" title=\"QQ登入\" class=\"iconfont icon-qq\"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=\"layui-nav-item layui-hide-xs\"&gt; &lt;a href=\"/app/weibo/\" onclick=\"layer.msg('正在通过微博登入', {icon:16, shade: 0.1, time:0})\" title=\"微博登入\" class=\"iconfont icon-weibo\"&gt;&lt;/a&gt; &lt;/li&gt; --&gt; &lt;!-- 登入后的状态 --&gt; &lt;li class=\"layui-nav-item\"&gt; &lt;a class=\"fly-nav-avatar\" href=\"javascript:;\"&gt; &lt;cite class=\"layui-hide-xs\"&gt;贤心&lt;/cite&gt; &lt;i class=\"iconfont icon-renzheng layui-hide-xs\" title=\"认证信息：layui 作者\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip layui-hide-xs\"&gt;VIP3&lt;/i&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\"&gt; &lt;/a&gt; &lt;dl class=\"layui-nav-child\"&gt; &lt;dd&gt;&lt;a href=\"../user/set.html\"&gt;&lt;i class=\"layui-icon\"&gt;&amp;#xe620;&lt;/i&gt;基本设置&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"../user/message.html\"&gt;&lt;i class=\"iconfont icon-tongzhi\" style=\"top: 4px;\"&gt;&lt;/i&gt;我的消息&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=\"../user/home.html\"&gt;&lt;i class=\"layui-icon\" style=\"margin-left: 2px; font-size: 22px;\"&gt;&amp;#xe68e;&lt;/i&gt;我的主页&lt;/a&gt;&lt;/dd&gt; &lt;hr style=\"margin: 5px 0;\"&gt; &lt;dd&gt;&lt;a href=\"\" style=\"text-align: center;\"&gt;退出&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"layui-hide-xs\"&gt; &lt;div class=\"fly-panel fly-column\"&gt; &lt;div class=\"layui-container\"&gt; &lt;ul class=\"layui-clear\"&gt; &lt;li class=\"layui-hide-xs\"&gt;&lt;a href=\"/\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"layui-this\"&gt;&lt;a href=\"\"&gt;提问&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;分享&lt;span class=\"layui-badge-dot\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;讨论&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;建议&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;公告&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;动态&lt;/a&gt;&lt;/li&gt; &lt;li class=\"layui-hide-xs layui-hide-sm layui-show-md-inline-block\"&gt;&lt;span class=\"fly-mid\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;!-- 用户登入后显示 --&gt; &lt;li class=\"layui-hide-xs layui-hide-sm layui-show-md-inline-block\"&gt;&lt;a href=\"../user/index.html\"&gt;我发表的贴&lt;/a&gt;&lt;/li&gt; &lt;li class=\"layui-hide-xs layui-hide-sm layui-show-md-inline-block\"&gt;&lt;a href=\"../user/index.html#collection\"&gt;我收藏的贴&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"fly-column-right layui-hide-xs\"&gt; &lt;span class=\"fly-search\"&gt;&lt;i class=\"layui-icon\"&gt;&lt;/i&gt;&lt;/span&gt; &lt;a href=\"add.html\" class=\"layui-btn\"&gt;发表新帖&lt;/a&gt; &lt;/div&gt; &lt;div class=\"layui-hide-sm layui-show-xs-block\" style=\"margin-top: -10px; padding-bottom: 10px; text-align: center;\"&gt; &lt;a href=\"add.html\" class=\"layui-btn\"&gt;发表新帖&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"layui-container\"&gt; &lt;div class=\"layui-row layui-col-space15\"&gt; &lt;div class=\"layui-col-md8 content detail\"&gt; &lt;div class=\"fly-panel detail-box\"&gt; &lt;h1&gt;Fly Template v3.0，基于 layui 的极简社区页面模版&lt;/h1&gt; &lt;div class=\"fly-detail-info\"&gt; &lt;!-- &lt;span class=\"layui-badge\"&gt;审核中&lt;/span&gt; --&gt; &lt;span class=\"layui-badge layui-bg-green fly-detail-column\"&gt;动态&lt;/span&gt; &lt;span class=\"layui-badge\" style=\"background-color: #999;\"&gt;未结&lt;/span&gt; &lt;!-- &lt;span class=\"layui-badge\" style=\"background-color: #5FB878;\"&gt;已结&lt;/span&gt; --&gt; &lt;span class=\"layui-badge layui-bg-black\"&gt;置顶&lt;/span&gt; &lt;span class=\"layui-badge layui-bg-red\"&gt;精帖&lt;/span&gt; &lt;div class=\"fly-admin-box\" data-id=\"123\"&gt; &lt;span class=\"layui-btn layui-btn-xs jie-admin\" type=\"del\"&gt;删除&lt;/span&gt; &lt;span class=\"layui-btn layui-btn-xs jie-admin\" type=\"set\" field=\"stick\" rank=\"1\"&gt;置顶&lt;/span&gt; &lt;!-- &lt;span class=\"layui-btn layui-btn-xs jie-admin\" type=\"set\" field=\"stick\" rank=\"0\" style=\"background-color:#ccc;\"&gt;取消置顶&lt;/span&gt; --&gt; &lt;span class=\"layui-btn layui-btn-xs jie-admin\" type=\"set\" field=\"status\" rank=\"1\"&gt;加精&lt;/span&gt; &lt;!-- &lt;span class=\"layui-btn layui-btn-xs jie-admin\" type=\"set\" field=\"status\" rank=\"0\" style=\"background-color:#ccc;\"&gt;取消加精&lt;/span&gt; --&gt; &lt;/div&gt; &lt;span class=\"fly-list-nums\"&gt; &lt;a href=\"#comment\"&gt;&lt;i class=\"iconfont\" title=\"回答\"&gt;&amp;#xe60c;&lt;/i&gt; 66&lt;/a&gt; &lt;i class=\"iconfont\" title=\"人气\"&gt;&amp;#xe60b;&lt;/i&gt; 99999 &lt;/span&gt; &lt;/div&gt; &lt;div class=\"detail-about\"&gt; &lt;a class=\"fly-avatar\" href=\"../user/home.html\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\"贤心\"&gt; &lt;/a&gt; &lt;div class=\"fly-detail-user\"&gt; &lt;a href=\"../user/home.html\" class=\"fly-link\"&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：{{ rows.user.approve }}\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; &lt;/a&gt; &lt;span&gt;2017-11-30&lt;/span&gt; &lt;/div&gt; &lt;div class=\"detail-hits\" id=\"LAY_jieAdmin\" data-id=\"123\"&gt; &lt;span style=\"padding-right: 10px; color: #FF7200\"&gt;悬赏：60飞吻&lt;/span&gt; &lt;span class=\"layui-btn layui-btn-xs jie-admin\" type=\"edit\"&gt;&lt;a href=\"add.html\"&gt;编辑此贴&lt;/a&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"detail-body photos\"&gt; &lt;p&gt; 该模版由 layui官方社区（&lt;a href=\"http://fly.layui.com/\" target=\"_blank\"&gt;fly.layui.com&lt;/a&gt;）倾情提供，只为表明我们对 layui 执着的信念、以及对未来持续加强的承诺。该模版基于 layui 搭建而成，可作为极简通用型社区的页面支撑。 &lt;/p&gt; &lt;p&gt;更新日志：&lt;/p&gt;&lt;pre&gt;# v3.0 2017-11-30* 采用 layui 2.2.3 作为 UI 支撑* 全面同步最新的 Fly 社区风格，各种细节得到大幅优化* 更友好的响应式适配能力&lt;/pre&gt; 下载&lt;hr&gt; &lt;p&gt; 官网：&lt;a href=\"http://www.layui.com/template/fly/\" target=\"_blank\"&gt;http://www.layui.com/template/fly/&lt;/a&gt;&lt;br&gt; 码云：&lt;a href=\"https://gitee.com/sentsin/fly/\" target=\"_blank\"&gt;https://gitee.com/sentsin/fly/&lt;/a&gt;&lt;br&gt; GitHub：&lt;a href=\"https://github.com/layui/fly\" target=\"_blank\"&gt;https://github.com/layui/fly&lt;/a&gt; &lt;/p&gt; 封面&lt;hr&gt; &lt;p&gt; &lt;img src=\"../../res/images/fly.jpg\" alt=\"Fly社区\"&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"fly-panel detail-box\" id=\"flyReply\"&gt; &lt;fieldset class=\"layui-elem-field layui-field-title\" style=\"text-align: center;\"&gt; &lt;legend&gt;回帖&lt;/legend&gt; &lt;/fieldset&gt; &lt;ul class=\"jieda\" id=\"jieda\"&gt; &lt;li data-id=\"111\" class=\"jieda-daan\"&gt; &lt;a name=\"item-1111111111\"&gt;&lt;/a&gt; &lt;div class=\"detail-about detail-about-reply\"&gt; &lt;a class=\"fly-avatar\" href=\"\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\" \"&gt; &lt;/a&gt; &lt;div class=\"fly-detail-user\"&gt; &lt;a href=\"\" class=\"fly-link\"&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;i class=\"iconfont icon-renzheng\" title=\"认证信息：XXX\"&gt;&lt;/i&gt; &lt;i class=\"layui-badge fly-badge-vip\"&gt;VIP3&lt;/i&gt; &lt;/a&gt; &lt;span&gt;(楼主)&lt;/span&gt; &lt;!-- &lt;span style=\"color:#5FB878\"&gt;(管理员)&lt;/span&gt; &lt;span style=\"color:#FF9E3F\"&gt;（社区之光）&lt;/span&gt; &lt;span style=\"color:#999\"&gt;（该号已被封）&lt;/span&gt; --&gt; &lt;/div&gt; &lt;div class=\"detail-hits\"&gt; &lt;span&gt;2017-11-30&lt;/span&gt; &lt;/div&gt; &lt;i class=\"iconfont icon-caina\" title=\"最佳答案\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class=\"detail-body jieda-body photos\"&gt; &lt;p&gt;香菇那个蓝瘦，这是一条被采纳的回帖&lt;/p&gt; &lt;/div&gt; &lt;div class=\"jieda-reply\"&gt; &lt;span class=\"jieda-zan zanok\" type=\"zan\"&gt; &lt;i class=\"iconfont icon-zan\"&gt;&lt;/i&gt; &lt;em&gt;66&lt;/em&gt; &lt;/span&gt; &lt;span type=\"reply\"&gt; &lt;i class=\"iconfont icon-svgmoban53\"&gt;&lt;/i&gt; 回复 &lt;/span&gt; &lt;div class=\"jieda-admin\"&gt; &lt;span type=\"edit\"&gt;编辑&lt;/span&gt; &lt;span type=\"del\"&gt;删除&lt;/span&gt; &lt;!-- &lt;span class=\"jieda-accept\" type=\"accept\"&gt;采纳&lt;/span&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li data-id=\"111\"&gt; &lt;a name=\"item-1111111111\"&gt;&lt;/a&gt; &lt;div class=\"detail-about detail-about-reply\"&gt; &lt;a class=\"fly-avatar\" href=\"\"&gt; &lt;img src=\"https://tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" alt=\" \"&gt; &lt;/a&gt; &lt;div class=\"fly-detail-user\"&gt; &lt;a href=\"\" class=\"fly-link\"&gt; &lt;cite&gt;贤心&lt;/cite&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"detail-hits\"&gt; &lt;span&gt;2017-11-30&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"detail-body jieda-body photos\"&gt; &lt;p&gt;蓝瘦那个香菇，这是一条没被采纳的回帖&lt;/p&gt; &lt;/div&gt; &lt;div class=\"jieda-reply\"&gt; &lt;span class=\"jieda-zan\" type=\"zan\"&gt; &lt;i class=\"iconfont icon-zan\"&gt;&lt;/i&gt; &lt;em&gt;0&lt;/em&gt; &lt;/span&gt; &lt;span type=\"reply\"&gt; &lt;i class=\"iconfont icon-svgmoban53\"&gt;&lt;/i&gt; 回复 &lt;/span&gt; &lt;div class=\"jieda-admin\"&gt; &lt;span type=\"edit\"&gt;编辑&lt;/span&gt; &lt;span type=\"del\"&gt;删除&lt;/span&gt; &lt;span class=\"jieda-accept\" type=\"accept\"&gt;采纳&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;!-- 无数据时 --&gt; &lt;!-- &lt;li class=\"fly-none\"&gt;消灭零回复&lt;/li&gt; --&gt; &lt;/ul&gt; &lt;div class=\"layui-form layui-form-pane\"&gt; &lt;form action=\"/jie/reply/\" method=\"post\"&gt; &lt;div class=\"layui-form-item layui-form-text\"&gt; &lt;a name=\"comment\"&gt;&lt;/a&gt; &lt;div class=\"layui-input-block\"&gt; &lt;textarea id=\"L_content\" name=\"content\" required lay-verify=\"required\" placeholder=\"请输入内容\" class=\"layui-textarea fly-editor\" style=\"height: 150px;\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"layui-form-item\"&gt; &lt;input type=\"hidden\" name=\"jid\" value=\"123\"&gt; &lt;button class=\"layui-btn\" lay-filter=\"*\" lay-submit&gt;提交回复&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;dl class=\"fly-panel fly-list-one\"&gt; &lt;dt class=\"fly-panel-title\"&gt;本周热议&lt;/dt&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;dd&gt; &lt;a href=\"\"&gt;基于 layui 的极简社区页面模版&lt;/a&gt; &lt;span&gt;&lt;i class=\"iconfont icon-pinglun1\"&gt;&lt;/i&gt; 16&lt;/span&gt; &lt;/dd&gt; &lt;!-- 无数据时 --&gt; &lt;!-- &lt;div class=\"fly-none\"&gt;没有相关数据&lt;/div&gt; --&gt; &lt;/dl&gt; &lt;div class=\"fly-panel\"&gt; &lt;div class=\"fly-panel-title\"&gt; 这里可作为广告区域 &lt;/div&gt; &lt;div class=\"fly-panel-main\"&gt; &lt;a href=\"http://layim.layui.com/?from=fly\" target=\"_blank\" class=\"fly-zanzhu\" time-limit=\"2017.09.25-2099.01.01\" style=\"background-color: #5FB878;\"&gt;LayIM 3.0 - layui 旗舰之作&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"fly-panel\" style=\"padding: 20px 0; text-align: center;\"&gt; &lt;img src=\"../../res/images/weixin.jpg\" style=\"max-width: 100%;\" alt=\"layui\"&gt; &lt;p style=\"position: relative; color: #666;\"&gt;微信扫码关注 layui 公众号&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"fly-footer\"&gt; &lt;p&gt;&lt;a href=\"http://fly.layui.com/\" target=\"_blank\"&gt;Fly社区&lt;/a&gt; 2017 &amp;copy; &lt;a href=\"http://www.layui.com/\" target=\"_blank\"&gt;layui.com 出品&lt;/a&gt;&lt;/p&gt; &lt;p&gt; &lt;a href=\"http://fly.layui.com/jie/3147/\" target=\"_blank\"&gt;付费计划&lt;/a&gt; &lt;a href=\"http://www.layui.com/template/fly/\" target=\"_blank\"&gt;获取Fly社区模版&lt;/a&gt; &lt;a href=\"http://fly.layui.com/jie/2461/\" target=\"_blank\"&gt;微信公众号&lt;/a&gt; &lt;/p&gt;&lt;/div&gt;&lt;script src=\"../../res/layui/layui.js\"&gt;&lt;/script&gt;&lt;script&gt;layui.cache.page = 'jie';layui.cache.user = { username: '游客' ,uid: -1 ,avatar: '../../res/images/avatar/00.jpg' ,experience: 83 ,sex: '男'};layui.config({ version: \"3.0.0\" ,base: '../../res/mods/'}).extend({ fly: 'index'}).use(['fly', 'face'], function(){ var $ = layui.$ ,fly = layui.fly; //如果你是采用模版自带的编辑器，你需要开启以下语句来解析。 /* $('.detail-body').each(function(){ var othis = $(this), html = othis.html(); othis.html(fly.content(html)); }); */});&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 到这里，第一步结束了。但是，模板的抽取就不会在这里过多的叙述了。根据上面讲过的模板抽取，自行把它们抽取处理。 第二步： 新建 PostController 类。代码如下： 1234567891011121314151617181920212223242526package club.guoshizhan.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;/** * @Author: guoshizhan * @Create: 2020/7/29 18:07 * @Description: 文章控制器 */@Controllerpublic class PostController { @GetMapping(\"/category/{id:\\\\d*}\") public String category(@PathVariable(name = \"id\") Long id) { return \"post/category\"; } @GetMapping(\"/post/{id:\\\\d*}\") public String details(@PathVariable(name = \"id\") Long id) { return \"post/detail\"; }} 此时写好之后可以重启项目运行，看是否有结果。经过测试，我的没有问题。（多个浏览器测试，防止有缓存） 第三步： 引入 mybatis-plus 依赖，前面已经引入了第四步： 配置数据库连接，前面已经配置好了。 1234567891011# MySQL 数据库连接spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/layui_blog?serverTimezone=GMT%2B8 username: root password: root # mybatis-plus 的 xml 文件的位置mybatis-plus: mapper-locations: classpath*:/mapper/**Mapper.xml 第五步： 引入代码生成器，生成相应的实体代码以及 mapper、service、controller 等等。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144package club.guoshizhan;import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;import com.baomidou.mybatisplus.core.toolkit.StringPool;import com.baomidou.mybatisplus.core.toolkit.StringUtils;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.InjectionConfig;import com.baomidou.mybatisplus.generator.config.*;import com.baomidou.mybatisplus.generator.config.po.TableInfo;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;import java.util.ArrayList;import java.util.List;import java.util.Scanner;/** * @Author: guoshizhan * @Create: 2020/7/16 13:50 * @Description: 代码生成器 */// 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中public class CodeGenerator { /** * 读取控制台内容 */ public static String scanner(String tip) { Scanner scanner = new Scanner(System.in); StringBuilder help = new StringBuilder(); help.append(\"请输入\" + tip + \"：\"); System.out.println(help.toString()); if (scanner.hasNext()) { String ipt = scanner.next(); if (StringUtils.isNotEmpty(ipt)) { return ipt; } } throw new MybatisPlusException(\"请输入正确的\" + tip + \"！\"); } public static void main(String[] args) { // 代码生成器 AutoGenerator mpg = new AutoGenerator(); // 全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath + \"/src/main/java\"); gc.setAuthor(\"guoshizhan\"); gc.setOpen(false); // gc.setSwagger2(true); 实体属性 Swagger2 注解 mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\"jdbc:mysql://localhost:3306/layui_blog?serverTimezone=GMT%2B8\"); // dsc.setSchemaName(\"public\"); dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"root\"); mpg.setDataSource(dsc); // 包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(null); pc.setParent(\"club.guoshizhan\"); mpg.setPackageInfo(pc); // 自定义配置 InjectionConfig cfg = new InjectionConfig() { @Override public void initMap() { // to do nothing } }; // 如果模板引擎是 freemarker String templatePath = \"/templates/mapper.xml.ftl\"; // 如果模板引擎是 velocity // String templatePath = \"/templates/mapper.xml.vm\"; // 自定义输出配置 List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;(); // 自定义配置会被优先输出 focList.add(new FileOutConfig(templatePath) { @Override public String outputFile(TableInfo tableInfo) { // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！ return projectPath + \"/src/main/resources/mapper/\" + pc.getModuleName() + \"/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML; } }); /* cfg.setFileCreate(new IFileCreate() { @Override public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) { // 判断自定义文件夹是否需要创建 checkDir(\"调用默认方法创建的目录，自定义目录用\"); if (fileType == FileType.MAPPER) { // 已经生成 mapper 文件判断存在，不想重新生成返回 false return !new File(filePath).exists(); } // 允许生成模板文件 return true; } }); */ cfg.setFileOutConfigList(focList); mpg.setCfg(cfg); // 配置模板 TemplateConfig templateConfig = new TemplateConfig(); // 配置自定义输出模板 //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别 // templateConfig.setEntity(\"templates/entity2.java\"); // templateConfig.setService(); // templateConfig.setController(); templateConfig.setXml(null); mpg.setTemplate(templateConfig); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setSuperEntityClass(\"club.guoshizhan.entity.BaseEntity\"); strategy.setEntityLombokModel(true); strategy.setRestControllerStyle(true); // 公共父类 strategy.setSuperControllerClass(\"club.guoshizhan.controller.BaseController\"); // 写于父类中的公共字段 strategy.setSuperEntityColumns(\"id\"); strategy.setInclude(scanner(\"表名，多个英文逗号分割\").split(\",\")); strategy.setSuperEntityColumns(\"id\", \"created\", \"modified\", \"status\"); strategy.setControllerMappingHyphenStyle(true); strategy.setTablePrefix(pc.getModuleName() + \"_\"); mpg.setStrategy(strategy); mpg.setTemplateEngine(new FreemarkerTemplateEngine()); mpg.execute(); }} 然后执行代码即可生成相应的各种代码。生成代码之后我们启动项目，发现报错了，找不到XXX符号之类的。这个时候请看第六步。category,comment,post,user,user_action,user_collection,user_message第六步： 在 新建config 包，然后 编写 MybatisPlusConfig 类即可 同样在 config 包下新建 ContextStartup 类。类似缓存。里面有 categories 域，用于 left.ftl 页面博客分类的数据填充。填充完数据之后重启发现分类查出来了。 分页： 导入分页插件到：MybatisPlusConfig 1:03:39","link":"/LayuiBlog.html"},{"title":"数据库入门教程","text":"数据库的基本概念数据库初识数据库 就是用于存储和管理数据的仓库，它的英文单词： DataBase ，简称 ： DB 。数据库本质上是一个文件系统，还是以文件的方式存在服务器的电脑上的。所有的关系型数据库都可以使用通用的 SQL 语句进行管理 ，即我们常说的 数据库管理系统 DBMS 【DataBase Management System】 数据库的特点 数据库的特点： 1、持久化存储数据的。其实数据库就是一个文件系统。 2、存储和管理数据。 3、使用了统一的方式操作数据库 --> SQL 。 常见数据库 常见的数据库： 1、Oracle：收费的大型数据库，Oracle 公司的产品。 2、MySQL：开源免费的数据库，小型的数据库，已经被 Oracle 收购了。MySQL6.x 版本也开始收费。 3、DB2：IBM 公司的数据库产品,收费的。常应用在银行系统中。 4、SQLServer：MicroSoft 公司收费的中型的数据库。C#、.net 等语言常使用。 5、SQLite：嵌入式的小型数据库，应用在手机端，如：Android。 数据库排行榜 MySQL 数据库 MySQL 安装以下将 以图的方式 简述 MySQL 安装过程，如下： 进入命令行 ，测试 MySQL 是否安装成功： MySQL 卸载有时候我们安装 MySQL 不成功，这个时候就要卸载 MySQL。但是，如果卸载不干净，那么再次安装 MySQL 的成功概率就特别低了，甚至就再也不能成功安装了。所以需要学会卸载 MySQL。话不多说，卸载步骤走起。第一步： 找到 MySQL 安装目录，打开 my.ini 文件： 第二步： 使用 CTRL + F 查找 datadir ，找到的结果就是 MySQL 的数据存放目录，如果不出意外，大家结果都是一样的。找到之后复制出来，后面会用到这个目录。我的查找结果如下： 12#Path to the database rootdatadir=\"C:/ProgramData/MySQL/MySQL Server 5.5/Data/\" 第三步： win + r ，然后输入 appwiz.cpl 打开应用控制面板，找到 MySQL ，然后卸载，如下图： 第四步： 当我们卸载了 MySQL 之后，其实并没有卸载干净。这时就要用到 第二步 查找到的那个目录的路径。我们截取此目录路径的一部分： C:/ProgramData ，然后打开这个目录，如下图： 到这里为止，MySQL 的安装卸载 就搞定了。 MySQL 服务启动和关闭图形界面方式： 打开命令行 win + r ，然后输入 services.msc 进入到服务，如下图： 命令行方式： 打开命令行 win + r ，然后输入 net stop mysql 关闭 MySQL 服务，如下图： 哎，发现不行呀。对的，这是权限不足问题。现在我们以 管理员身份 运行 net stop mysql 试试吧。如下图： MySQL 登陆和退出命令行方式： 打开命令行 win + r ，然后输入 cmd 进入到命令行，相关操作如下图： 还记得我们安装 MySQL 设置密码的时候，那里勾选了远程连接，用来连接到远程的数据库。现在来讲解一下。举个例子：比如我要连接到我云服务器的 MySQL ，咋弄？ 来，这么办，演示如下图： MySQL 目录结构 MySQL 的安装目录MySQL 的安装目录其实就是 MySQL 的安装位置 ，这个目录里面的文件我们简单介绍一下： MySQL 的数据目录 SQL 初识什么是 SQL结构化查询语言(Structured Query Language) 简称 SQL ，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。【————百度百科】 SQL 的 作用 其实就是 定义了操作所有关系型数据库的规则 。但是每一种数据库操作的方式存在不一样的地方，称为 “方言” 。 SQL 通用语法 SQL 特点： 1、SQL 语句可以单行或多行书写，以分号结尾。 2、可使用空格和缩进来增强语句的可读性。 3、MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 SQL 3 种注释： 1、单行注释: -- 注释内容 【-- 后面有一个空格，没有会出错】 2、单行注释: # 注释内容( mysql 特有) 【#后面可以没有空格】 3、多行注释: /* 注释内容，和 Java 多行注释一样 */ 12345select * from user; -- 单行注释select * from user; # 单行注释 ( mysql 特有)select * from user; /* 多行注释 */ SQL 分类我将以图的方式对下述 四种 SQL 分类 进行介绍，请看下图： SQL-小白命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* * DDL 命令操作数据库 */-- 查询数据库show databases; # 查看所有数据库show create database mysql; # 查看 mysql 数据库的创建语句，其实主要目的是查看数据库的字符集-- 创建数据库create database db01; # 创建 db01 数据库，默认字符集是 utf8create database if not exists db01; # 判断 db01 数据库是否存在，存在就不创建了，不存在就创建create database db02 character set gbk; # 创建 db02 数据库并指定 gbk 字符集-- 修改和删除数据库alter database db02 character set utf8; # 修改 db02 数据库的字符集为 utf8drop database db02; # 删除 db02 数据库，如果不存在这个数据库，会报错drop database if exists db02; # 如果存在 db02 数据库，则删除数据库，不存在，不会报错-- 使用数据库select database(); # 查询当前正在使用的数据库名称use db02; # 使用 db02 数据库use book-system; # 这样写会报 1064 错误，正确写法： use `book-system`;/* * DDL 命令操作数据表 */ -- 查询数据表show tables; # 查询当前数据库的所有表show create table stu_tbl; # 查看 stu_tbl 数据表的字符集desc book_tbl; # 查询 book_tbl 表结构，desc 是 description 的缩写-- 创建和复制数据表create table stu_tbl( # 创建一张名为 stu_tbl 的数据表 stu_id int, # id 字段为第一列，以下以此类推， 字段类型为 int stu_name varchar(128), # name 字段为第二列，字段类型为 varchar stu_age int, stu_birthday date, stu_address varchar(128) # 这是最后一个字段，它的后面没有逗号);create table student_tbl like stu_tbl; # 复制一张和 stu_tbl 一样的表，名字为 student_tbl-- 修改和删除数据表drop table stu_tbl; # 删除 stu_tbl 数据表，如果不存在这个数据表，会报错drop table if exists stu_tbl; # 如果存在 stu_tbl 数据表，则删除数据表，不存在，不会报错alter table stu_tbl rename to stu; # 把 stu_tbl 数据表重命名为 stualter table stu_tbl character set gbk; # 把 stu_tbl 数据表的字符集修改为 gbkalter table stu_tbl add gender varchar(32); # 给 stu_tbl 数据表添加 gender 字段，数据类型为 varchar。就是新增了 gender 这么一列alter table stu_tbl change gender sex int; # 把 stu_tbl 数据表的 gender 列改名为 sex 列，并且修改了数据类型为 intalter table stu_tbl modify gender int; # 把 stu_tbl 数据表的 gender 列的数据类型修改为了 intalter table stu_tbl drop gender; # 删除 stu_tbl 数据表的 gender 列/* * DML 命令，添加、删除、修改表中的数据 */ -- 添加数据，遇到字符和日期类型，需要用引号（单双都行）insert into stu_tbl (stu_id,stu_name) values (1,'Jack'); # 给 id 和 name 两个字段插入值，记得数据类型要对应，否则报错insert into stu_tbl (stu_id,stu_name,stu_age,stu_birthday,stu_address) values (1,'Jack',18,\"1997-6-6\",'hangzhou'); # 给所有字段插入值，这是完整的写法insert into stu_tbl values (1,'Jack',18,null,'hangzhou'); # 给所有字段插入值，这是简化的写法-- 删除数据delete from stu_tbl; # 删除 stu_tbl 表中所有数据，有多少条记录就会执行多少次删除操作，效率很慢，不推荐使用【谨慎操作】truncate table stu_tbl; # 先删除 stu_tbl 表，然后重新创建同名的空表，删除效率高，推荐使用【谨慎操作】delete from stu_tbl where id = 1; # 删除 stu_tbl 表中 id=1 的那一行数据delete from stu_tbl where name = 'Tom'; # 删除 stu_tbl 表中 name='Tom' 的那一行数据-- 修改数据UPDATE stu_tbl SET name = \"Jack\" WHERE id = 1; # 把 id=1 的记录中的 name 修改为 Jack DDL-数据定义语言DDL 概念： 数据定义语言【DDL】是 (Data Definition Language) 的缩写形式。用来定义和操作数据库对象。例如：数据库，表，列等。相关关键字： create , drop , alter 等。 CRUD 操作： 1、C(Create):&nbsp;&nbsp;&nbsp;&nbsp;创建 2、R(Retrieve)：&nbsp;查询 3、U(Update):&nbsp;&nbsp;&nbsp;&nbsp;修改 3、D(Delete):&nbsp;&nbsp;&nbsp;&nbsp;删除 安装完 MySQL 后，系统自带了 4 个数据库。都代表什么呢。相关的介绍如下图： 接下来介绍 创建数据库 和 指定字符集 （指定字符集的命令在 SQL-小白命令 处）相关的操作，如下图： 操作数据库的其他命令就不再一个一个地演示了，详情看上方的 SQL 命令汇总 自行练习。接下来介绍 DDL 命令操作数据表 。 接着我们介绍 创建数据表和查询数据表 操作，首先认识 SQL 的数据类型，如下图： 接下来我们 创建表和查询表 ，操作如下图： 操作数据表的其他命令 就不再一个一个地演示了，详情看上方的 SQL 命令汇总 自行练习。接下来介绍 图形化界面工具 SQLyog 。 图形化界面工具有时间再补充……DML-数据操作语言DML 概念： 数据操作语言【DML】是 (Data Manipulation Language) 的缩写形式。用来对数据库中 表的数据进行增删改 。相关关键字： insert , delete , update 等。 12345678910111213141516171819202122232425262728293031323334353637/* * DML 命令，添加、删除、修改表中的数据 */-- 命令模板# 添加数据。注意事项：1、列名和值要一一对应；2、除了数字类型，其他类型需要使用引号(单双都可以)引起来insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);# 如果表名后，不定义列名，则默认给所有列添加值insert into 表名 values(值1,值2,...值n);# 删除数据,如果不加条件，则删除表中所有记录。delete from 表名 [where 条件];# 不推荐使用。有多少条记录就会执行多少次删除操作，效率低。此条命令谨慎使用delete from 表名;# 推荐使用，效率更高 先删除表，然后再创建一张一样的表。此条命令谨慎使用TRUNCATE TABLE 表名;# 修改数据，如果不加任何条件，则会将表中所有记录全部修改。update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];-- 命令实际操作-- 添加数据，遇到字符和日期类型，需要用引号（单双都行）insert into stu_tbl (stu_id,stu_name) values (1,'Jack'); # 给 id 和 name 两个字段插入值，记得数据类型要对应，否则报错insert into stu_tbl (stu_id,stu_name,stu_age,stu_birthday,stu_address) values (1,'Jack',18,\"1997-6-6\",'hangzhou'); # 给所有字段插入值，这是完整的写法insert into stu_tbl values (1,'Jack',18,null,'hangzhou'); # 给所有字段插入值，这是简化的写法-- 删除数据delete from stu_tbl; # 删除 stu_tbl 表中所有数据，有多少条记录就会执行多少次删除操作，效率很慢，不推荐使用【谨慎操作】truncate table stu_tbl; # 先删除 stu_tbl 表，然后重新创建同名的空表，删除效率高，推荐使用【谨慎操作】delete from stu_tbl where id = 1; # 删除 stu_tbl 表中 id=1 的那一行数据delete from stu_tbl where name = 'Tom'; # 删除 stu_tbl 表中 name='Tom' 的那一行数据-- 修改数据UPDATE stu_tbl SET name = \"Jack\" WHERE id= 1; # 把 id=1 的记录中的 name 修改为 JackUPDATE stu_tbl SET name = \"Jack\"; # 表中的 name 字段的值都是 Jack，大家的名字都一样了。谨慎操作 由于时间关系，具体的操作截图就不弄了，命令模板 和 命令实际操作 上述代码都有，参阅然后自行实操。 DQL-数据查询语言DQL 概念： 数据查询语言【DQL】是 (Data Query Language) 的缩写形式。用来查询数据库中表的记录(数据)。相关关键字： select , where 等。 123456789101112131415# 基本语法介绍select # 字段列表 from # 表名列表 where # 条件列表 group by # 分组字段 having # 分组之后的条件 order by # 排序 limit # 分页限定 接下来，我们使用上述基本语法实现各种查询骚操作。第一步： 创建一张表并插入数据，操作如下： 123456789101112131415161718192021222324-- 创建 student 表CREATE TABLE student(id INT, -- 编号NAME VARCHAR(20), -- 姓名age INT, -- 年龄sex VARCHAR(5), -- 性别address VARCHAR(100), -- 地址math INT, -- 数学english INT -- 英语);-- 向 student 表中插入数据INSERT INTO student(id,NAME,age,sex,address,math,english) VALUES (1,'马云',55,'男','杭州',66,78),(2,'马化腾',45,'女','深圳',98,87),(3,'马景涛',55,'男','香港',56,77),(4,'柳岩',20,'女','湖南',76,65),(5,'柳青',20,'男','湖南',86,NULL),(6,'刘德华',57,'男','香港',99,99),(7,'马德',22,'女','香港',99,99),(8,'德玛西亚',18,'男','南京',56,65);-- 查询 student 表SELECT * FROM student; 第二步： 我们使用 SQLyog 图形化界面工具创建上述的 student 表 ，并插入数据和查询，如下图： 第三步： 开始操作。接下来的各种查询操作都是 基于 student 表 ，所以必须创建好，并且有数据，以下是 基础查询操作命令 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445-- 基础查询操作select * from student; # 查询 student 表所有数据select name,address from student; # 查询 student 表中 name 和 addressselect address from student; # 只查询 address ，结果可能重复select distinct address from student; # 只查询 address ，去除了重复数据。注意事项：结果集必须都一样才能去重。例如 3,\"23\" 和 4,\"23\" 是不能去重的，结果集不是完全一样-- 计算 math 和 English 之和。如果字段比较多，就应该这么写查询语句select name, math, english, (math + english) # 这里 english 可能为 null，那么计算结果也为 null，这样计算显然不合理 我们使用 ifnull 对其判断，如下from student;-- 对有 null 值的数据进行优化，使用 IFNULL 函数select name, math, english, (math + ifnull(english,0)) # 使用 ifnull 对其判断，有 null 就返回 0from student;-- 给 (math + ifnull(english,0)) 起别名，使用 as 关键字select name, math, english, (math + ifnull(english,0)) as scores # 起别名为 scores ，也可以使用空格替代 asfrom student;-- 使用 空格和关键字 AS 起别名操作select name 名字, # 给 name 起别名为 名字，使用的是空格起别名 math as 数学, # 给 math 起别名为 数学，使用的是 as 关键字 english, (math + ifnull(english,0)) as scores # 起别名为 scores ，也可以使用空格替代 asfrom student; 第四步： 上述基础查询操作命令自己去练习，时间紧张，就不截图了。接下来介绍 条件查询操作命令 ，如下： 12345678910111213141516171819202122232425262728293031323334-- 条件查询操作，where 子句后跟条件# 比较运算符 &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;SELECT * FROM student WHERE age &gt; 20; # 查询年龄大于 20 岁的数据SELECT * FROM student WHERE age &gt;= 20; # 查询年龄大于等于 20 岁的数据SELECT * FROM student WHERE age &lt; 20; # 查询年龄小于 20 岁的数据SELECT * FROM student WHERE age = 20; # 查询年龄等于 20 岁的数据SELECT * FROM student WHERE age != 20; # 查询年龄不等于 20 岁的数据SELECT * FROM student WHERE age &lt;&gt; 20; # 查询年龄不等于 20 岁的数据# 范围查询：BETWEEN...AND 【and 或 &amp;&amp;】【or 或 || 】SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;= 30; # 查询年龄在 [20,30] 岁之间的数据，不推荐使用SELECT * FROM student WHERE age &gt;= 20 AND age &lt;= 30; # 查询年龄在 [20,30] 岁之间的数据，不推荐使用SELECT * FROM student WHERE age BETWEEN 20 AND 30; # 查询年龄在 [20,30] 岁之间的数据，推荐使用# IN( 集合) 【not 或 !】SELECT * FROM student WHERE age = 20 OR age = 18 OR age=25; # 查询年龄为 20、18 或者 25 岁的数据SELECT * FROM student WHERE age IN(20,18,25); # 查询年龄为 20、18 或者 25 岁的数据SELECT * FROM student WHERE age NOT IN(20,18,25); # 查询年龄不为 20、18 且 25 岁的数据# IS NULLSELECT * FROM student WHERE english = NULL; # 查询 english 没成绩的数据。但是这是错误的 SQL 语句，结果显示 Empty Set 。【不能写 XXX = NULL】SELECT * FROM student WHERE english IS NULL; # 查询 english 没成绩的数据。SELECT * FROM student WHERE english IS NOT NULL; # 查询 english 有成绩的数据。# LIKE：模糊查询。两种占位符：下划线 _ 代表单个任意字符， 百分号 % 代表多个任意字符SELECT * FROM student WHERE name like \"马%\"; # 查找姓 ”马“ 的人SELECT * FROM student WHERE name like \"_化%\"; # 查找姓名第二个字是 ”化“ 的人SELECT * FROM student WHERE name like \"___\"; # 查找姓名是三个字的人SELECT * FROM student WHERE name like \"%德%\"; # 查找姓名中包含 ”德“ 的人 第五步： 上述条件查询操作命令自己去练习，时间紧张，就不截图了。接下来介绍 排序查询操作命令 ，如下： 12345678# 排序查询操作语法： order by 排序字段1 排序方式1 ， 排序字段2 排序方式2...# 排序方式：ASC：升序，默认的；DESC：降序。# 注意事项：如果有多个排序条件，只有当前边的条件值一样时，才会进行第二个条件。SELECT * FROM student ORDER BY math; # 以 math 成绩 排序所有记录，默认是升序SELECT * FROM student ORDER BY math ASC; # 以 math 成绩 升序排序所有记录SELECT * FROM student ORDER BY math DESC; # 以 math 成绩 降序排序所有记录SELECT * FROM student ORDER BY math ASC, english DESC; # 以 math 成绩 升序排名，如果数学成绩一样，则按照英语成绩 降序排名 第六步： 接下来介绍 聚合函数操作命令 ，如下： 1234567891011121314151617181920212223242526# 聚合函数：将一列数据作为一个整体，进行纵向的计算。-- 1. count：计算个数SELECT COUNT(id) FROM student; # 以 id 这一列计算个数，结果是 8，因为有 8 条数据SELECT COUNT(*) FROM student; # 以不为空的列计算个数，结果是 8，* 号的写法是不推荐的SELECT COUNT(english) FROM student; # 以 english 这一列计算个数，结果是 7，因为聚合函数的计算，会排除 null 值-- 2. max：计算最大值SELECT MAX(math) FROM student; # 计算 math 成绩最高分SELECT MAX(english) FROM student; # 计算 english 成绩最高分-- 3. min：计算最小值SELECT MIN(math) FROM student; # 计算 math 成绩最低分SELECT MIN(english) FROM student; # 计算 english 成绩最低分SELECT * FROM stu WHERE math=(SELECT MIN(math) FROM stu); # 子查询，查询 math 成绩最低分的数据-- 4. sum：计算和SELECT SUM(math) FROM student; # 计算 math 成绩总和SELECT SUM(english) FROM student; # 计算 english 成绩总和-- 5. avg：计算平均值SELECT AVG(math) FROM student; # 计算 math 平均成绩SELECT AVG(english) FROM student; # 计算 english 平均成绩SELECT AVG(name) FROM student; # 计算 name 平均成绩，因为 name 非数值，所以结果是 0 第七步： 接下来介绍 分组查询操作命令 ，如下： 12345678910111213141516171819202122232425# 分组查询语法: group by 分组字段；#注意事项：1. 分组之后查询的字段是分组字段或者聚合函数，而不能是有关单条记录的字段，如下：SELECT name , sex , AVG(math),COUNT(id) FROM student GROUP BY sex; # 这条语句中的 name 是没有任何意义的虽然不报错，但是就是无意义-- 按照性别分组。分别查询男、女同学的平均分SELECT sex , AVG(math) FROM student GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;-- 按照性别分组。分别查询男、女同学的数学平均分,人数。 要求：分数低于70分的人，不参与分组SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;-- 按照性别分组。分别查询男、女同学的数学平均分,人数 要求：分数低于70分的人，不参与分组,且分组之后。人数要大于2个人SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; # 在聚合函数后面起别名，方便判断，最好别起中文，这里只是演示# where 和 having 的区别？# 1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having 在分组之后进行限定，如果不满足结果，则不会被查询出来# 2. where 后不可以跟聚合函数，having 可以进行聚合函数的判断。 第八步： 接下来介绍 分页查询操作命令 ，如下： 12345678# 分页查询语法：limit 开始的索引,每页查询的条数;# 开始索引公式：开始索引 = （当前的页码 - 1） * 每页显示的条数# 注意事项：limit 是一个 MySQL \"方言\" ，只能在 MySQL 中使用，其他数据库中用不了-- 每页显示 3 条记录：第一个参数表示开始索引，第二个参数表示每页显示条数SELECT * FROM student LIMIT 0,3; # 查询第 1 页SELECT * FROM student LIMIT 3,3; # 查询第 2 页SELECT * FROM student LIMIT 6,3; # 查询第 3 页 DCL-数据控制语言DCL 概念： 数据控制语言【DCL】是 (Data Control Language) 的缩写形式。用来定义数据库的访问权限和安全级别，以及创建用户。相关关键字： GRANT ， REVOKE 等。 1234567891011121314151617181920212223242526# 1、查询用户-- 切换到 MySQL 数据库USE mysql;-- 查询 user 表SELECT * FROM USER; -- 通配符： % 表示可以在任意主机使用用户登录数据库，localhost 代表只能在本地登陆# 2、创建用户-- 创建用户语法CREATE USER '用户名'@'地址' IDENTIFIED BY '密码';-- 创建用户举例CREATE USER 'zhangsan'@'%' IDENTIFIED BY '123'; -- 可在本地和远程登陆CREATE USER 'lisi'@'localhost' IDENTIFIED BY '123'; -- 仅限本地登陆# 3、删除用户-- 删除用户语法DROP USER '用户名'@'主机名';-- 删除用户举例DROP USER 'lisi'@'localhost';# 4、修改用户密码-- 修改用户密码语法：PASSWORD() 函数可以实现密码自动加密UPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE USER = '用户名'; # 第一种方式SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码'); # 第二种方式-- 修改用户密码举例UPDATE USER SET PASSWORD = PASSWORD('abc') WHERE USER = 'lisi';SET PASSWORD FOR 'root'@'localhost' = PASSWORD('123'); 用户权限管理 相关的操作如下： 123456789101112131415161718# 1、查询权限-- 查询权限语法SHOW GRANTS FOR '用户名'@'主机名';-- 查询权限实例SHOW GRANTS FOR 'lisi'@'localhost';# 2、授予权限-- 授予权限语法grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';-- 给张三用户授予所有权限，在任意数据库任意表上GRANT SELECT ON db01.emp TO 'zhangsan'@'localhost'; -- 给 zhangsan 用户授予查询权限，仅限于 db01数据库中的 emp 表查询，其他操作均不可GRANT ALL ON *.* TO 'zhangsan'@'localhost'; -- ALL 代表所有权限，第一个 * 代表所有数据库，第二个代表每个数据库下的所有表# 3、撤销权限-- 撤销权限语法revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';-- 撤销权限实例REVOKE UPDATE ON db01.`account` FROM 'lisi'@'%'; -- 撤销 lisi 用户的修改权限 重点来喽： 如果我们忘记了 MySQL 密码怎么办？ 以下 骚操作 记好： mysql 中忘记了 root 用户的密码？ 1、cmd -- > net stop mysql 停止 MySQL 服务。注意：这条命令需要管理员身份运行 2、使用无验证方式启动 MySQL 服务： mysqld --skip-grant-tables 3、打开新的 cmd 窗口,直接输入 mysql 命令，敲回车。就可以登录成功 4、use mysql; 5、update user set password = password('你的新密码') where user = 'root'; 6、关闭两个窗口 7、打开任务管理器，手动结束 mysqld.exe 的进程 8、启动 MySQL 服务 9、使用新密码登录。 表的约束约束概念及分类约束概念： 对表中的数据进行限定，保证数据的 正确性 、有效性 和 完整性 。 约束的分类： 1、主键约束：primary key 2、非空约束：not null 3、唯一约束：unique 4、外键约束：foreign key 约束命令汇总第一个： 非空约束 命令汇总如下： 1234567891011# 非空约束：not null，加了这个约束的字段的值不能为 null，如下表的 name 字段-- 创建表时添加约束CREATE TABLE stu1( id INT, name VARCHAR(20) NOT NULL -- name 为非空，如果不给值会报错);-- 删除 name 的非空约束ALTER TABLE stu1 MODIFY name VARCHAR(20);-- 创建表后，然后添加非空约束ALTER TABLE stu1 MODIFY name VARCHAR(20) NOT NULL; 第二个： 唯一约束 命令汇总如下： 1234567891011121314# 唯一约束：unique，值不能重复# 注意事项：mysql 中，唯一约束限定的列的值可以有多个 null ，这个不算重复-- 创建表时，添加唯一约束CREATE TABLE stu2( id INT, phone_number VARCHAR(20) UNIQUE -- 给 phone_number 字段添加了唯一约束，如果值重复就报错);-- 删除唯一约束ALTER TABLE stu2 DROP INDEX phone_number;-- 在创建表后，添加唯一约束-- 这里要注意：如果 phone_number 字段有重复值，必须先删除某个重复值然后再执行次命令ALTER TABLE stu2 MODIFY phone_number VARCHAR(20) UNIQUE; 第三个： 主键约束 命令汇总如下： 123456789101112131415161718192021222324# 主键约束：primary key。# 注意事项：主键就是表中记录的唯一标识，非空且唯一，一张表只能有一个字段为主键-- 在创建表时，添加主键约束create table stu3( id int primary key, -- 给 id 添加主键约束 name varchar(20));-- 删除主键alter table stu3 modify id int ; -- 这是错误删除方式，虽然执行成功不报错，但是主键仍然在，并没有被删除ALTER TABLE stu3 DROP PRIMARY KEY; -- 正确删除主键的方式-- 创建完表后，添加主键ALTER TABLE stu3 MODIFY id INT PRIMARY KEY;# 自动增长：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长-- 在创建表时，添加主键约束，并且完成主键自增长create table stu4( id int primary key auto_increment, -- 给 id 添加主键约束，并自动增长 name varchar(20));-- 删除自动增长ALTER TABLE stu4 MODIFY id INT; -- 只是删除了自动增长，并不会删除主键-- 添加自动增长ALTER TABLE stu4 MODIFY id INT AUTO_INCREMENT; 第四个： 外键约束 命令汇总如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# 外键约束：foreign key , 让表于表产生关系，从而保证数据的正确性。-- 01-创建员工表CREATE TABLE emp( # 创建员工表id INT PRIMARY KEY AUTO_INCREMENT, # 主键 id，自增name VARCHAR(30), # 姓名age INT, # 年龄dep_name VARCHAR(30), # 部门名称dep_location VARCHAR(30) # 部门所在位置);-- 02-添加数据INSERT INTO emp(NAME,age,dep_name,dep_location) VALUES ('张三',20,'研发部','广州');INSERT INTO emp(NAME,age,dep_name,dep_location) VALUES ('李四',21,'研发部','广州');INSERT INTO emp(NAME,age,dep_name,dep_location) VALUES ('王五',20,'研发部','广州');INSERT INTO emp(NAME,age,dep_name,dep_location) VALUES ('老王',20,'销售部','深圳');INSERT INTO emp(NAME,age,dep_name,dep_location) VALUES ('大王',22,'销售部','深圳');INSERT INTO emp(NAME,age,dep_name,dep_location) VALUES ('小王',18,'销售部','深圳');# 上述 emp 表存在数据冗余问题。举个例子：研发部 已经改名为 研究部，地点迁移到 杭州。那么如果研发部这个部门有 100 名员工，# 那 emp 表中每个人的信息都要修改，岂不是要修改 100 次。那 1 万人呢？10 万人呢？修改 1 万次？10 万次？显然是不合理的。-- 03-解决数据冗余方案：把 emp 表分成两张表，主表 department 和 从表 employee-- 03-1 创建部门表【一方，主表】CREATE TABLE department(id INT PRIMARY KEY AUTO_INCREMENT,dep_name VARCHAR(20),dep_location VARCHAR(20));-- 03-2 添加 2 个部门INSERT INTO department VALUES (NULL,'研发部','广州'),(NULL,'销售部','深圳');SELECT * FROM department;-- 03-3 创建员工表【多方，从表】CREATE TABLE employee(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20),age INT,dep_id INT);-- 03-4 添加 6 个数据INSERT INTO employee(NAME,age,dep_id) VALUES ('张三',20,1);INSERT INTO employee(NAME,age,dep_id) VALUES ('李四',21,1);INSERT INTO employee(NAME,age,dep_id) VALUES ('王五',20,1);INSERT INTO employee(NAME,age,dep_id) VALUES ('老王',20,2);INSERT INTO employee(NAME,age,dep_id) VALUES ('大王',22,2);INSERT INTO employee(NAME,age,dep_id) VALUES ('小王',18,2);# 这个时候就把 emp 表拆分成了 employee 表和 department 表。但是这两张表没有关联啊，# 所以此时需要用外键 foreign key 把他们关联起来DROP TABLE employee; -- 删除员工表DROP TABLE department; -- 删除部门表# 上述删除表的母的就是可以再次创建有外键的表。语法如下： create table 表名( .... 外键列 # 这里解释一下 外键名称，例如：A表和B表相关联，外键名为A-B , C表和D表相关联，外键名为C-D,所以外键名称主要用于区分 哪两张表相关联 # 外键列名称 表示这张表当中哪个字段需要链接外键，主表名称(主表列名称) 代表外键链接到的是哪一个表中的哪一个字段 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) );-- 04-再次创建部门表CREATE TABLE department(id INT PRIMARY KEY AUTO_INCREMENT,dep_name VARCHAR(20),dep_location VARCHAR(20));-- 添加 2 个部门INSERT INTO department VALUES (NULL,'研发部','广州'),(NULL,'销售部','深圳');SELECT * FROM department;-- 05-再次创建员工表，这次的带了外键哦CREATE TABLE employee(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20),age INT,dep_id INT, -- 外键对应主表的主键-- 创建外键约束 ，emp_depid_fk 是外键名字，dep_id 是外键，department(id) 是外键所指向的表,关联 id 字段CONSTRAINT emp_depid_fk FOREIGN KEY (dep_id) REFERENCES department(id));-- 06-删除外键ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; # 删除外键语法ALTER TABLE employee DROP FOREIGN KEY emp_depid_fk; # 删除 employee 表与 department 表之间的外键 emp_depid_fk-- 07-创建表之后，添加外键# 添加外键语法ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);# 给 employee 表 dep_id 字段添加外键ALTER TABLE employee ADD CONSTRAINT emp_depid_fk FOREIGN KEY (dep_id) REFERENCES department(id); 第五个： 外键约束_级联操作 命令汇总如下： 1234567891011121314151617181920212223# 由于 employee 表和 department 表有外键关联，所以当需要修改 department 表的 id 字段时会报错。-- 解决修改 department 表 id 字段报错问题【麻烦版本，不建议使用】UPDATE employee SET dep_id = NULL WHERE dep_id = 1; # 外键可以设置为 NULL，但不可以不存在UPDATE department SET id = 3 WHERE id = 1;UPDATE employee SET dep_id = 3 WHERE dep_id = NULL; # 现在就把 department 表修改了，而且 employee 表也修改了# 有没有更简单的方法呢？只修改 department 表中 id 字段的值，然后 employee 表 dep_id 跟着变化。哎，那还真有，那就是 级联操作# 级联操作需要在添加外键的时候来设置，操作如下：-- 删除外键，如何判断是否删除 使用 SQLyog 软件中架构设计器，拖入两张相关联的表，没连线代表删除成功，连线代表没有删除外键ALTER TABLE employee DROP FOREIGN KEY emp_depid_fk;-- 添加级联操作语法ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ;-- 添加外键，设置级联更新【ON UPDATE CASCADE】 和设置级联删除【】ALTER TABLE employee ADD CONSTRAINT emp_depid_fk FOREIGN KEY (dep_id) REFERENCES department(id) ON UPDATE CASCADE ON DELETE CASCADE ;# 级联操作需要谨慎使用，以免误删数据。其次是进行级联操作影响效率和性能。 多表操作及关系 多表之间的关系： 1、一对一(了解)。 如：人和身份证【一个人只有一个身份证，一个身份证只能对应一个人】 2、一对多(多对一)。如：部门和员工【一个部门有多个员工，一个员工只能对应一个部门】 3、多对多。如：学生和课程【一个学生可以选择很多门课程，一个课程也可以被很多学生选择】 第一步： 一对多(多对一) 的实现关系，如下图： 第二步： 多对多 的实现关系，如下图： 第三步： 一对一(了解) 的实现关系，如下图： 三大范式设计数据库时，需要遵循的一些规范，这些规范就叫范式。而要遵循后边的范式要求，必须先遵循前边的所有范式要求。 范式的概念： 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 范式的分类： 1、第一范式（1NF）：每一列都是不可分割的原子数据项 2、第二范式（2NF）：在 1NF 的基础上，非码属性必须完全依赖于码（在 1NF 基础上消除非主属性对主码的部分函数依赖） 3、第三范式（3NF）：在 2NF 的基础上，任何非主属性不依赖于其它非主属性（在 2NF 基础上消除传递依赖） 几个概念： 1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号--&gt;姓名。 （学号，课程名称） --&gt; 分数 2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称） --&gt; 分数 3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） -- &gt; 姓名 4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号--&gt;系名，系名--&gt;系主任 5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） * 主属性：码属性组中的所有属性 * 非主属性：除过码属性组的属性 数据库的备份和还原123456789101112131415161718# 命令行操作方式-- 备份数据库操作-- 备份语法mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径# 把 db01 数据库备份到 G 盘下的 db.sqlmysqldump -uroot -proot db01 &gt; G:\\\\db.sql-- 还原数据库操作mysql -uroot -proot # 1、登录数据库create database db01; # 2、创建数据库，数据库名任意，不一定是备份的数据库名use db01; # 3、使用数据库；source G:\\\\db.sql; # 4、执行文件，把备份在 G 盘的 sql 文件还原# 图形界面操作方式# 图形界面相对简单，只要看的懂文字即可，即可实现备份和还原。# 推荐工具： SQLyog ，Navicat SQL 高级多表查询及分类当我们进行多表查询时，返回结果是 笛卡尔积 。笛卡尔积存在很多无用的数据，需要消除他们，就需要用到下述三类查询。 多表查询的分类： 1、内连接查询 2、外连接查询 3、子查询 前期准备 ，就是建立需要进行查询的表，并了解一些概念，如下： 1234567891011121314151617181920212223242526# 首先准备两张表，部门表和员工表# 创建部门表CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20));INSERT INTO dept (NAME) VALUES ('开发部'),('市场部'),('财务部');# 创建员工表CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dept_id INT, FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键));INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('孙悟空','男',7200,'2013-02-24',1);INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('猪八戒','男',3600,'2010-12-02',2);INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('唐僧','男',9000,'2008-08-08',2);INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('白骨精','女',5000,'2015-10-07',3);INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('蜘蛛精','女',4500,'2011-03-14',1);# 此时部门表 dept 有三条记录，员工表 emp 有五条记录select * from emp,dept; -- 最简单的多表查询，结果是 笛卡尔积【有两个集合A,B .取这两个集合的所有组成情况。】 内连接查询隐式内连接： 使用 where 条件 消除无用数据，如下： 1234567891011121314151617-- 查询所有员工信息和所对应的部门信息SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;-- 查询员工表中的姓名、性别，部门表的名称SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;-- 如果查询字段多，表名很长，条件很多，就是用以下格式SELECT t1.name, -- 员工表的姓名 t1.gender, -- 员工表的性别 t2.name -- 部门表的名称FROM emp t1, -- 给 emp 表取别名为 t1 dept t2 -- 给 dept 表取别名为 t2WHERE t1.`dept_id` = t2.`id`; -- 查询条件 显式内连接： 使用显式内连接来消除无用数据，如下： 123456-- 显式内连接语法select 字段列表 from 表名1 [inner] join 表名2 on 条件-- 显示内连接SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`; -- 显示内连接查询，INNER 可以省略SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`; -- INNER 省略了，查询结果同上 内连接查询注意事项： 1、从哪些表中查询数据 2、条件是什么 3、查询哪些字段 外连接查询左外连接：左外连接的相关介绍及语法如下： 123456789-- 左外连接语法：查询的是左表所有数据以及其交集部分。outer 可以省略select 字段列表 from 表1 left [outer] join 表2 on 条件-- 左外连接实例：查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称INSERT INTO emp VALUES (6,\"Lisa\",NULL,NULL,NULL,NULL); -- 插入一条外键为空的记录SELECT * FROM emp INNER JOIN dept ON emp.dept_id = dept.id; -- 使用内连接查找，发现查不到 Lisa 的信息-- 左外连接查询：可以查到 Lisa 记录SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; 右外连接：右外连接的相关介绍及语法如下： 12345-- 右外连接语法：查询的是右表所有数据以及其交集部分。select 字段列表 from 表1 right [outer] join 表2 on 条件-- 右外连接实例：查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; TIPS： 左外连接和右外连接学一个就行了，都是一样的意思。 子查询1234567891011121314151617181920212223242526272829303132# 子查询概念：查询中嵌套查询，称嵌套查询为子查询。-- 查询工资最高的员工信息，普通查询方式-- 1 查询最高的工资是多少 9000SELECT MAX(salary) FROM emp;-- 2 查询员工信息，并且工资等于 9000 的SELECT * FROM emp WHERE emp.`salary` = 9000;-- 使用子查询，一条 sql 就完成这个操作SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);# 子查询三种不同情况-- 1. 子查询的结果是单行单列的：子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =-- 查询员工工资小于平均工资的人SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);-- 2. 子查询的结果是多行单列的：子查询可以作为条件，使用运算符 in 来判断-- 查询 '财务部' 和 '市场部' 所有的员工信息，普通查询方式SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部';SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;-- 子查询SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部');-- 3. 子查询的结果是多行多列的：子查询可以作为一张虚拟表参与查询-- 查询员工入职日期是 2011-11-11日 之后的员工信息和部门信息-- 子查询SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; '2011-11-11') t2WHERE t1.id = t2.dept_id;-- 普通内连接查询方式SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt; '2011-11-11' 多表查询练习第一步： 创建一个数据库，然后创建下列表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778-- 部门表CREATE TABLE dept ( id INT PRIMARY KEY PRIMARY KEY, -- 部门id dname VARCHAR(50), -- 部门名称 loc VARCHAR(50) -- 部门所在地);-- 添加4个部门INSERT INTO dept(id,dname,loc) VALUES (10,'教研部','北京'),(20,'学工部','上海'),(30,'销售部','广州'),(40,'财务部','深圳');-- 职务表，职务名称，职务描述CREATE TABLE job ( id INT PRIMARY KEY, jname VARCHAR(20), description VARCHAR(50));-- 添加4个职务INSERT INTO job (id, jname, description) VALUES(1, '董事长', '管理整个公司，接单'),(2, '经理', '管理部门员工'),(3, '销售员', '向客人推销产品'),(4, '文员', '使用办公软件');-- 员工表CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT, -- 所在部门编号 CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id), CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id));-- 添加员工INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,'孙悟空',4,1004,'2000-12-17','8000.00',NULL,20),(1002,'卢俊义',3,1006,'2001-02-20','16000.00','3000.00',30),(1003,'林冲',3,1006,'2001-02-22','12500.00','5000.00',30),(1004,'唐僧',2,1009,'2001-04-02','29750.00',NULL,20),(1005,'李逵',4,1006,'2001-09-28','12500.00','14000.00',30),(1006,'宋江',2,1009,'2001-05-01','28500.00',NULL,30),(1007,'刘备',2,1009,'2001-09-01','24500.00',NULL,10),(1008,'猪八戒',4,1004,'2007-04-19','30000.00',NULL,20),(1009,'罗贯中',1,NULL,'2001-11-17','50000.00',NULL,10),(1010,'吴用',3,1006,'2001-09-08','15000.00','0.00',30),(1011,'沙僧',4,1004,'2007-05-23','11000.00',NULL,20),(1012,'李逵',4,1006,'2001-12-03','9500.00',NULL,30),(1013,'小白龙',4,1004,'2001-12-03','30000.00',NULL,20),(1014,'关羽',4,1007,'2002-01-23','13000.00',NULL,10);-- 工资等级表CREATE TABLE salarygrade ( grade INT PRIMARY KEY, -- 级别 losalary INT, -- 最低工资 hisalary INT -- 最高工资);-- 添加5个工资等级INSERT INTO salarygrade(grade,losalary,hisalary) VALUES (1,7000,12000),(2,12010,14000),(3,14010,20000),(4,20010,30000),(5,30010,99990); 第二步： 需求一和需求二分析查询，如下表： 12345678910111213141516171819202122232425262728293031323334353637-- 1、查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述/* * 需求分析： * 1.员工编号，员工姓名，工资，需要查询 emp 表； 职务名称，职务描述 需要查询 job 表 * 2.查询条件 emp.job_id = job.id */SELECT t1.`id`, -- 员工编号 t1.`ename`, -- 员工姓名 t1.`salary`, -- 员工工资 t2.`jname`, -- 职务名称 t2.`description` -- 职务描述FROM emp t1, job t2WHERE t1.`job_id` = t2.`id`;-- 2、查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置/* * 需求分析： * 1. 员工编号，员工姓名，工资 emp 职务名称，职务描述 job 部门名称，部门位置 dept * 2. 条件： emp.job_id = job.id and emp.dept_id = dept.id */SELECT t1.`id`, -- 员工编号 t1.`ename`, -- 员工姓名 t1.`salary`, -- 员工工资 t2.`jname`, -- 职务名称 t2.`description`, -- 职务描述 t3.`dname`, -- 部门名称 t3.`loc` -- 部门位置FROM emp t1, job t2,dept t3WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`; 第三步： 需求三和需求四分析查询，如下表： 12345678910111213141516171819202122232425262728293031323334353637-- 3、查询员工姓名，工资，工资等级/* * 需求分析： * 1、员工姓名，工资 emp 工资等级 salarygrade * 2、条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary * emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary*/SELECT t1.ename , t1.`salary`, t2.*FROM emp t1, salarygrade t2WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;-- 4、查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级/* * 需求分析： * 1、员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept 工资等级 salarygrade * 2、条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary */SELECT t1.`ename`, t1.`salary`, t2.`jname`, t2.`description`, t3.`dname`, t3.`loc`, t4.`grade`FROM emp t1,job t2,dept t3,salarygrade t4WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id` AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`; 第四步： 需求五和需求六分析查询，如下表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051-- 5、查询出部门编号、部门名称、部门位置、部门人数/* * 需求分析： * 1、部门编号、部门名称、部门位置 dept 表。 部门人数 emp表 * 2、使用分组查询。按照emp.dept_id完成分组，查询count(id) * 3、使用子查询将第2步的查询结果和dept表进行关联查询 * */SELECT t1.`id`,t1.`dname`,t1.`loc` , t2.totalFROM dept t1, (SELECT dept_id,COUNT(id) total FROM emp GROUP BY dept_id) t2WHERE t1.`id` = t2.dept_id;-- 6、查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询/* * 需求分析： * 1、姓名 emp， 直接上级的姓名 emp * emp表的id 和 mgr 是自关联 * 2、条件 emp.id = emp.mgr * 3、查询左表的所有数据，和 交集数据 * 使用左外连接查询 * *//* 查不出没有领导的员工select t1.ename, t1.mgr, t2.`id`, t2.enameFROM emp t1, emp t2WHERE t1.mgr = t2.`id`;*/-- 能查出没有领导的员工SELECT t1.ename, t1.mgr, t2.`id`, t2.`ename`FROM emp t1LEFT JOIN emp t2ON t1.`mgr` = t2.`id`; 事务事务概念及相关操作事务的概念： 如果一个包含 多个步骤 的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 事务相关的操作： 1、开启事务： start transaction; 2、回滚：rollback; 3、提交：commit; 代码举例： 123456789101112131415161718192021222324252627282930-- 创建 account 表CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE);-- 添加数据INSERT INTO account (NAME, balance) VALUES ('zhangsan', 1000), ('lisi', 1000);SELECT * FROM account;UPDATE account SET balance = 1000;-- 张三给李四转账 500 元-- 0. 开启事务START TRANSACTION;-- 1. 张三账户 -500UPDATE account SET balance = balance - 500 WHERE NAME = 'zhangsan';-- 2. 李四账户 +500-- 出错了...UPDATE account SET balance = balance + 500 WHERE NAME = 'lisi';-- 发现执行没有问题，提交事务COMMIT;-- 发现出问题了，回滚事务ROLLBACK; 事务的两种提交方式1234567891011121314# 事务提交的两种方式：自动提交： MySQL 默认是自动提交的。一条 DML (增删改)语句会自动提交一次事务。手动提交： 需要先开启事务，再提交。Oracle 数据库默认是手动提交事务 # 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交 0 代表手动提交# 修改默认提交方式：set @@autocommit = 0;commit; -- 改为手动提交后，就需要 commit 才能把修改的数据生效 事务的四大特征 事务的四大特征： 1、原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 2、持久性：当事务提交或回滚后，数据库会持久化的保存数据。 3、隔离性：多个事务之间。相互独立。 4、一致性：事务操作前后，数据总量不变。 事务的隔离级别概念： 多个事务之间隔离的，相互独立的。但如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就能解决这些问题。 存在问题： 1、脏读：一个事务，读取到另一个事务中没有提交的数据。 2、不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 3、幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 隔离级别： 1、read uncommitted：读未提交。产生的问题：脏读、不可重复读、幻读 2、read committed：读已提交 （Oracle 默认）。产生的问题：不可重复读、幻读 3、repeatable read：可重复读（MySQL 默认）。产生的问题：幻读 4、serializable：串行化。可以解决所有的问题 注意事项： 隔离级别从小到大安全性越来越高，但是效率越来越低。 1234567# 数据库查询隔离级别：select @@tx_isolation;# 数据库设置隔离级别：set global transaction isolation level 级别字符串; -- 设置隔离级别语法set global transaction isolation level read committed; -- 设置为 读已提交select @@tx_isolation; -- 查询仍然是 repeatable read，需要关闭软件，再次打开即可 隔离级别演示如下： 12345678910111213# CMD 同时打开两个 MySQL 窗口，同时进入相同数据库和相同表，并且开启事务-- 第一个窗口set global transaction isolation level read uncommitted; -- 设置需要测试的隔离级别start transaction;-- 转账操作update account set balance = balance - 500 where id = 1; -- 给 1 号转账，且不提交事务update account set balance = balance + 500 where id = 2;-- 第二个窗口start transaction; -- 开启事务select * from account; -- 查找 account 表，可能出现的问题：脏读，虚读，幻读` JDBC 相关知识JDBC 基本概念JDBC 概念： JDBC 是 Java DataBase Connectivity 的缩写形式，翻译成中文为 Java 数据库连接 ，即使用 Java 语言操作数据库。JDBC 本质： 其实是官方（sun 公司）定义的一套操作所有关系型数据库的规则，即 接口 。各个数据库厂商去实现这套接口，提供 数据库驱动 jar 包 。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动 jar 包中的实现类。 快速入门 JDBC 使用步骤： 1、导入驱动 jar 包： mysql-connector-java-5.1.37-bin.jar &nbsp;&nbsp;&nbsp;&nbsp;1.1 复制 mysql-connector-java-5.1.37-bin.jar 到项目的 libs 目录下 &nbsp;&nbsp;&nbsp;&nbsp;1.2 右键 --> Add As Library 2、注册驱动 3、获取数据库连接对象 Connection 4、定义 sql 5、获取执行 sql 语句的对象 Statement 6、执行 sql，接受返回结果 7、处理结果 8、释放资源 快速入门小案例，代码如下： 1234567891011121314151617181920212223242526272829303132/** * JDBC 快速入门 */public static void main(String[] args) throws Exception { // 1. 导入驱动 jar 包，需要连接哪个数据库，就导入哪个数据库的 jar 包 // 2.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); // 3.获取数据库连接对象// Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db01\", \"root\", \"root\"); Connection conn = DriverManager.getConnection(\"jdbc:mysql:///db01\", \"root\", \"root\"); // 4.定义sql语句// String sql = \"update account set balance = 2000 where id = 1\"; String sql = \"update account set balance = 2000\"; // 5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); // 6.执行sql int count = stmt.executeUpdate(sql); // 7.处理结果 System.out.println(count); // 8.释放资源 stmt.close(); conn.close();} JDBC 详解 JDBC 详解各个对象： 1、DriverManager：驱动管理对象 2、Connection：数据库连接对象 3、Statement：执行 sql 的对象 4、ResultSet：结果集对象，封装查询结果 5、PreparedStatement：执行 sql 的对象 第一个： DriverManager：驱动管理对象 ，它有如下两个功能： 1234567891011121314# DriverManager 功能一：注册驱动，告诉程序该使用哪一个数据库驱动 jarstatic void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用： Class.forName(\"com.mysql.jdbc.Driver\");# 通过查看源码发现：在 com.mysql.jdbc.Driver 类中存在静态代码块：static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(\"Can't register driver!\"); }}# 注意事项：mysql5 之后的 驱动jar包 可以省略注册驱动的步骤。 1234567891011# DriverManager 功能二：获取数据库连接，方法：static Connection getConnection(String url, String user, String password) # 方法参数介绍：url：指定连接的路径 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 例子：jdbc:mysql://localhost:3306/db01 细节：如果连接的是本机 mysql 服务器，并且 mysql 服务默认端口是 3306，则 url 可以简写为：jdbc:mysql:/// 数据库名称user：用户名password：密码 第二个： Connection：数据库连接对象 ，它有如下两个功能： 12345678910# Connection 的两个功能：# 1、获取执行 sql 的对象：有下面两个方法 Statement createStatement() PreparedStatement prepareStatement(String sql)# 2、管理事务： 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() 第三个： Statement：执行 sql 的对象 ，介绍如下： 12345678910# 1、执行 sql 1、boolean execute(String sql) ：可以执行任意的sql 了解 2、int executeUpdate(String sql) ：执行 DML（insert、update、delete）语句、DDL(create，alter、drop) 语句 返回值：影响的行数，可以通过这个影响的行数判断 DML 语句是否执行成功 返回值 &gt; 0 的则执行成功，反之，则失败。 3、ResultSet executeQuery(String sql) ：执行DQL（select)语句# 2、练习 1、account表 添加一条记录 2、account表 修改记录 3、account表 删除一条记录 Statement：执行 sql 的对象 的练习，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void main(String[] args) { Statement stmt = null; Connection conn = null; try { // 1. 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); // 2. 定义 sql，需要执行哪个操作就选用那一条 sql String sql = \"insert into account values(null,'王五',3000)\"; // 添加操作 //String sql = \"update account set balance = 1500 where id = 3\"; // 修改操作 //String sql = \"delete from account where id = 3\"; // 删除操作 //String sql = \"create table student (id int , name varchar(20))\"; // 创建 student 表，但是这种操作不常用 // 3.获取Connection对象 conn = DriverManager.getConnection(\"jdbc:mysql:///db01\", \"root\", \"root\"); // 4.获取执行sql的对象 Statement stmt = conn.createStatement(); // 5.执行sql int count = stmt.executeUpdate(sql); // 影响的行数 // 6.处理结果 System.out.println(count); if(count &gt; 0){ System.out.println(\"添加/修改/删除成功！\"); }else{ System.out.println(\"添加/修改/删除失败！\"); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); }finally { // stmt.close(); // 7. 释放资源 // 避免空指针异常 if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } }} 第四个： ResultSet：结果集对象，封装查询结果 ，介绍如下： 12345678910111213# ResultSet：结果集对象，封装查询结果boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回 false，如果不是则返回 truegetXxx(参数):获取数据。Xxx：代表数据类型 如： int getInt() , String getString()参数： 1. int：代表列的编号,从 1 开始 如： getString(1) 2. String：代表列名称。 如： getDouble(\"balance\")使用步骤： 1. 游标向下移动一行 2. 判断是否有数据 3. 获取数据 ResultSet 结果集对象的一个练习 （只查询单条记录） ，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static void main(String[] args) { Connection conn = null; Statement stmt = null; ResultSet rs = null; try { // 1. 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); // 2.获取连接对象 conn = DriverManager.getConnection(\"jdbc:mysql:///db01\", \"root\", \"root\"); // 3.定义sql String sql = \"select * from account\"; // 4.获取执行sql对象 stmt = conn.createStatement(); //5.执行sql rs = stmt.executeQuery(sql); // 6.处理结果 // 6.1 让游标向下移动一行 rs.next(); // 6.2 获取数据 int id = rs.getInt(1); String name = rs.getString(\"name\"); double balance = rs.getDouble(3); System.out.println(id + \"---\" + name + \"---\" + balance); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } finally { // 7.释放资源 if(rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } }} ResultSet 结果集对象的一个练习 （查询所有记录） ，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static void main(String[] args) { Connection conn = null; Statement stmt = null; ResultSet rs = null; try { //1. 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取连接对象 conn = DriverManager.getConnection(\"jdbc:mysql:///db01\", \"root\", \"root\"); //3.定义sql String sql = \"select * from account\"; //4.获取执行sql对象 stmt = conn.createStatement(); //5.执行sql rs = stmt.executeQuery(sql); //6.处理结果 //循环判断游标是否是最后一行末尾。 while(rs.next()){ //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString(\"name\"); double balance = rs.getDouble(3); System.out.println(id + \"---\" + name + \"---\" + balance); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } finally { //7.释放资源 if(rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } }} ResultSet 结果集对象的一个 小案例 ，把数据库表中的数据封装到 JavaBean 中，代码如下： Emp.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 封装 Emp 表数据的 JavaBean */public class Emp { private int id; private String ename; private int job_id; private int mgr; private Date joindate; private double salary; private double bonus; private int dept_id; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getEname() { return ename; } public void setEname(String ename) { this.ename = ename; } public int getJob_id() { return job_id; } public void setJob_id(int job_id) { this.job_id = job_id; } public int getMgr() { return mgr; } public void setMgr(int mgr) { this.mgr = mgr; } public Date getJoindate() { return joindate; } public void setJoindate(Date joindate) { this.joindate = joindate; } public double getSalary() { return salary; } public void setSalary(double salary) { this.salary = salary; } public int getDept_id() { return dept_id; } public void setDept_id(int dept_id) { this.dept_id = dept_id; } public double getBonus() { return bonus; } public void setBonus(double bonus) { this.bonus = bonus; } @Override public String toString() { return \"Emp{\" + \"id=\" + id + \", ename='\" + ename + '\\'' + \", job_id=\" + job_id + \", mgr=\" + mgr + \", joindate=\" + joindate + \", salary=\" + salary + \", bonus=\" + bonus + \", dept_id=\" + dept_id + '}'; }} 上面定义好了一个实体类，与数据库相映射，现在就来编写具体的测试类，代码如下； JDBC_Test.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * 定义一个方法，查询 emp 表的数据将其封装为对象，然后装载集合，返回。 */public class JDBC_Test { public static void main(String[] args) { List&lt;Emp&gt; list = new JDBCDemo8().findAll2(); System.out.println(list); System.out.println(list.size()); } /** * 查询所有 emp 对象 * @return */ public List&lt;Emp&gt; findAll(){ Connection conn = null; Statement stmt = null; ResultSet rs = null; List&lt;Emp&gt; list = null; try { //1.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取连接 conn = DriverManager.getConnection(\"jdbc:mysql:///db01\", \"root\", \"root\"); //3.定义sql String sql = \"select * from emp\"; //4.获取执行 sql 的对象 stmt = conn.createStatement(); //5.执行sql rs = stmt.executeQuery(sql); //6.遍历结果集，封装对象，装载集合 Emp emp = null; list = new ArrayList&lt;Emp&gt;(); while(rs.next()){ //获取数据 int id = rs.getInt(\"id\"); String ename = rs.getString(\"ename\"); int job_id = rs.getInt(\"job_id\"); int mgr = rs.getInt(\"mgr\"); Date joindate = rs.getDate(\"joindate\"); double salary = rs.getDouble(\"salary\"); double bonus = rs.getDouble(\"bonus\"); int dept_id = rs.getInt(\"dept_id\"); // 创建 emp 对象,并赋值 emp = new Emp(); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); //装载集合 list.add(emp); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); }finally { if(rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } return list; }} JDBC 工具类JDBC 工具类 小案例，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * JDBC 工具类 */public class JDBCUtils { private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 */ static{ //读取资源文件，获取值。 try { //1. 创建Properties集合类。 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(\"jdbc.properties\"); String path = res.getPath(); // System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties //2. 加载文件 // pro.load(new FileReader(\"D:\\\\IdeaProjects\\\\itcast\\\\day04_jdbc\\\\src\\\\jdbc.properties\")); pro.load(new FileReader(path)); //3. 获取数据，赋值 url = pro.getProperty(\"url\"); user = pro.getProperty(\"user\"); password = pro.getProperty(\"password\"); driver = pro.getProperty(\"driver\"); //4. 注册驱动 Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException { return DriverManager.getConnection(url, user, password); } /** * 释放资源 * @param stmt * @param conn */ public static void close(Statement stmt,Connection conn){ if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } /** * 释放资源 * @param stmt * @param conn */ public static void close(ResultSet rs,Statement stmt, Connection conn){ if( rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } }} 编写配置文件，放在 src 目录 下，文件内容如下： jdbc.properties1234url=jdbc:mysql:///db01user=rootpassword=rootdriver=com.mysql.jdbc.Driver 编写 JDBC 工具类的演示类，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 演示 JDBC 工具类 * @return */public List&lt;Emp&gt; findAll2(){ Connection conn = null; Statement stmt = null; ResultSet rs = null; List&lt;Emp&gt; list = null; try { conn = JDBCUtils.getConnection(); //3.定义sql String sql = \"select * from emp\"; //4.获取执行sql的对象 stmt = conn.createStatement(); //5.执行sql rs = stmt.executeQuery(sql); //6.遍历结果集，封装对象，装载集合 Emp emp = null; list = new ArrayList&lt;Emp&gt;(); while(rs.next()){ //获取数据 int id = rs.getInt(\"id\"); String ename = rs.getString(\"ename\"); int job_id = rs.getInt(\"job_id\"); int mgr = rs.getInt(\"mgr\"); Date joindate = rs.getDate(\"joindate\"); double salary = rs.getDouble(\"salary\"); double bonus = rs.getDouble(\"bonus\"); int dept_id = rs.getInt(\"dept_id\"); // 创建emp对象,并赋值 emp = new Emp(); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); //装载集合 list.add(emp); } } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,stmt,conn); } return list;} JDBC 练习JDBC 的一个登陆操作小案例，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * 练习： * 1. 通过键盘录入用户名和密码 * 2. 判断用户是否登录成功 */public class JDBCLogin_Test { public static void main(String[] args) { //1.键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(\"请输入用户名：\"); String username = sc.nextLine(); System.out.println(\"请输入密码：\"); String password = sc.nextLine(); //2.调用方法 boolean flag = new JDBCLogin_Test().login(username, password); //3.判断结果，输出不同语句 if(flag){ //登录成功 System.out.println(\"登录成功！\"); }else{ System.out.println(\"用户名或密码错误！\"); } } /** * 登录方法 */ public boolean login(String username ,String password){ if(username == null || password == null){ return false; } //连接数据库判断是否登录成功 Connection conn = null; Statement stmt = null; ResultSet rs = null; //1.获取连接 try { conn = JDBCUtils.getConnection(); //2.定义sql String sql = \"select * from user where username = '\"+username+\"' and password = '\"+password+\"' \"; System.out.println(sql); //3.获取执行sql的对象 stmt = conn.createStatement(); //4.执行查询 rs = stmt.executeQuery(sql); //5.判断 return rs.next();//如果有下一行，则返回true } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,stmt,conn); } return false; }}``上述操作会被 `SQL 注入` ，所以改造登陆方法，代码如下：```java/** * 登录方法,使用PreparedStatement实现 */public boolean login2(String username ,String password){ if(username == null || password == null){ return false; } //连接数据库判断是否登录成功 Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; //1.获取连接 try { conn = JDBCUtils.getConnection(); //2.定义sql String sql = \"select * from user where username = ? and password = ?\"; //3.获取执行sql的对象 pstmt = conn.prepareStatement(sql); //给?赋值 pstmt.setString(1,username); pstmt.setString(2,password); //4.执行查询,不需要传递sql rs = pstmt.executeQuery(); //5.判断 /* if(rs.next()){//如果有下一行，则返回true return true; }else{ return false; }*/ return rs.next();//如果有下一行，则返回true } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,pstmt,conn); } return false;} 第五个： PreparedStatement：执行 sql 的对象 ，介绍如下： 1234567891011121314151617181920212223242526# PreparedStatement：执行 sql 的对象1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 1. 输入用户随便，输入密码：a' or 'a' = 'a 2. sql：select * from user where username = 'fhdsjkf' and password = 'a' or 'a' = 'a' 2. 解决sql注入问题：使用PreparedStatement对象来解决3. 预编译的SQL：参数使用?作为占位符4. 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 5. 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 6. 给？赋值： * 方法： setXxx(参数1,参数2) * 参数1：？的位置编号 从1 开始 * 参数2：？的值 7. 执行sql，接受返回结果，不需要传递sql语句 8. 处理结果 9. 释放资源5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作 1. 可以防止SQL注入 2. 效率更高 JDBC 事务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * JDBC 事务操作 */public class JDBC_Transaction { public static void main(String[] args) { Connection conn = null; PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; try { //1.获取连接 conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); //2.定义sql //2.1 张三 - 500 String sql1 = \"update account set balance = balance - ? where id = ?\"; //2.2 李四 + 500 String sql2 = \"update account set balance = balance + ? where id = ?\"; //3.获取执行sql对象 pstmt1 = conn.prepareStatement(sql1); pstmt2 = conn.prepareStatement(sql2); //4. 设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //5.执行sql pstmt1.executeUpdate(); // 手动制造异常 int i = 3/0; pstmt2.executeUpdate(); //提交事务 conn.commit(); } catch (Exception e) { //事务回滚 try { if(conn != null) { conn.rollback(); } } catch (SQLException e1) { e1.printStackTrace(); } e.printStackTrace(); }finally { JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); } }} 数据库连接池当我们操作数据库时，我们每次都创建一个连接，然后操作完成之后释放这个连接。如此的频繁操作导致效率很低，因而连接池出现了，它解决了 资源浪费、效率低下 的问题。 连接池概念和优点连接池概念： 连接池其实就是一个容器(集合)，存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。草图如下： 连接池的好处： 1、节约资源 2、用户访问高效 连接池的实现Java 提供了一个标准接口来实现连接池： javax.sql 包下的 DataSource 接口。我们不会去实现它，而是由数据库厂商去实现。 接口中的方法： 1、获取连接方法：getConnection() 2、归还连接方法：Connection.close()。 3、注意：如果连接对象 Connection 是从连接池中获取的，那么调用 Connection.close()方法，则不会关闭连接，而是归还连接到连接池。 C3P0 连接池C3P0 是一个开源的 JDBC 连接池 ，它实现了数据源与 JNDI 绑定，支持 JDBC3 规范和实现了 JDBC2 的标准扩展说明的 Connection 和 Statement 池的 DataSources 对象 。即将用于连接数据库的连接整合在一起形成一个随取随用的数据库连接池（Connection pool）。 C3P0 连接池使用步骤： 1、导入 jar 包【三个】 c3p0-0.9.5.2.jar ， mchange-commons-java-0.2.12.jar ，mysql-connector-java-5.1.37-bin.jar 2、定义配置文件。名称： c3p0.properties 或者 c3p0-config.xml 。路径：直接将文件放在 src 目录下即可。【系统自动加载】 3、创建核心对象：数据库连接池对象 ComboPooledDataSource 4、获取连接： getConnection C3P0 代码演示如下： c3p0-config.xml12345678910111213141516171819202122232425262728293031&lt;c3p0-config&gt; &lt;!-- 使用默认的配置读取连接池对象 --&gt; &lt;default-config&gt; &lt;!-- 连接参数 --&gt; &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/db01&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;root&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;!--初始化申请的连接数量--&gt; &lt;property name=\"initialPoolSize\"&gt;5&lt;/property&gt; &lt;!--最大的连接数量--&gt; &lt;property name=\"maxPoolSize\"&gt;10&lt;/property&gt; &lt;!--超时时间--&gt; &lt;property name=\"checkoutTimeout\"&gt;3000&lt;/property&gt; &lt;/default-config&gt; &lt;named-config name=\"otherc3p0\"&gt; &lt;!-- 连接参数 --&gt; &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/db01&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;root&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;property name=\"initialPoolSize\"&gt;5&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;8&lt;/property&gt; &lt;property name=\"checkoutTimeout\"&gt;1000&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 123456789101112131415/** * C3P0 的演示 */public class C3P0_Demo { public static void main(String[] args) throws SQLException { // 1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); // 2. 获取连接对象 Connection conn = ds.getConnection(); // 3. 打印，查看一下 conn 到底是什么 System.out.println(conn); }} 验证一下 c3p0-config.xml 中的各种参数，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738/** * c3p0 参数验证演示 */public class C3P0_Test { public static void main(String[] args) throws SQLException { // 1. 获取DataSource，使用默认配置 DataSource ds = new ComboPooledDataSource(); // 2.获取连接：验证默认配置的最大连接数量： &lt;property name=\"maxPoolSize\"&gt;10&lt;/property&gt; for (int i = 1; i &lt;= 11 ; i++) { Connection conn = ds.getConnection(); System.out.println(i+\":\"+conn); // 如果没有下列 if 语句，那么超过 3 秒就会报错&lt;property name=\"checkoutTimeout\"&gt;3000&lt;/property&gt; // 因为连接池最大 10 个，而要产生 11 个对象，所以过了 超时检测时间 就要报错 if(i == 5){ conn.close(); // 归还连接到连接池中 } } //testNamedConfig(); } public static void testNamedConfig() throws SQLException { // 1.1 获取DataSource，使用指定名称配置 DataSource ds = new ComboPooledDataSource(\"otherc3p0\"); //2.获取连接：验证指定配置 otherc3p0 下的最大连接数量：8 个 for (int i = 1; i &lt;= 10 ; i++) { Connection conn = ds.getConnection(); System.out.println(i+\":\"+conn); } }} Druid 连接池Druid 为阿里巴巴的数据源（数据库连接池），集合了 c3p0、dbcp、proxool 等连接池的优点，还加入了日志监控，有效的监控 DB 池连接和 SQL 的执行情况。Druid 的 DataSource 类 为：com.alibaba.druid.pool.DruidDataSource 。 Druid 连接池使用步骤： 1、导入 jar 包： druid-1.0.9.jar 2、定义配置文件：是 properties 形式的，可以叫任意名称，可以放在任意目录下【需要手动加载】 3、加载配置文件：Properties 4、获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 5、获取连接：getConnection Druid 代码演示如下： druid.properties12345678910111213141516driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql:///db01username=rootpassword=root# 初始化连接数量initialSize=5# 最大连接数maxActive=10# 最大等待时间maxWait=3000 123456789101112131415161718192021/** * Druid演示 */public class Druid_Demo { public static void main(String[] args) throws Exception { //1.导入jar包 //2.定义配置文件 //3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(\"druid.properties\"); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection(); System.out.println(conn); }} 封装一个工具类，方便以后的各种操作，工具类如下： Druid 定义 JDBCUtils 工具类： 1、定义一个类 JDBCUtils 2、提供静态代码块加载配置文件，初始化连接池对象 3、提供相关的方法 &nbsp;&nbsp;&nbsp;&nbsp;1、获取连接方法：通过数据库连接池获取连接 &nbsp;&nbsp;&nbsp;&nbsp;2、释放资源 &nbsp;&nbsp;&nbsp;&nbsp;3、获取连接池的方法 JDBCUtils.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * Druid 连接池的工具类 */public class JDBCUtils { //1.定义成员变量 DataSource private static DataSource ds ; static{ try { //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\")); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } /** * 释放资源 */ public static void close(Statement stmt,Connection conn){ /* if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); // 归还连接 } catch (SQLException e) { e.printStackTrace(); } }*/ close(null,stmt,conn); } public static void close(ResultSet rs , Statement stmt, Connection conn){ if(rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); // 归还连接 } catch (SQLException e) { e.printStackTrace(); } } } /** * 获取连接池方法 */ public static DataSource getDataSource(){ return ds; }} 工具类类写好了，是否好用呢？来测试一下吧。代码如下： 123456789101112131415161718192021222324252627282930313233/** * 使用新的工具类 */public class Druid_Test { public static void main(String[] args) { /* * 完成添加操作：给 account 表添加一条记录 */ Connection conn = null; PreparedStatement pstmt = null; try { // 1.获取连接 conn = JDBCUtils.getConnection(); // 2.定义 sql String sql = \"insert into account values(null,?,?)\"; // 3.获取 pstmt 对象 pstmt = conn.prepareStatement(sql); // 4.给 ？赋值 pstmt.setString(1,\"王五\"); pstmt.setDouble(2,3000); // 5.执行 sql int count = pstmt.executeUpdate(); System.out.println(count); } catch (SQLException e) { e.printStackTrace(); }finally { // 6.释放资源 JDBCUtils.close(pstmt,conn); } }} 到此为止，连接池的内容就结束了！ JDBC TemplateJDBC Template 介绍连接池虽然提高了效率，工具类也简化了一些操作，但是仍然觉得很麻烦。有木有更简单一点的操作呢？只关注 sql 本身，而不去管其他的东西？有，它就是 JDBC Template 。它是 Spring 框架对 JDBC 的简单封装，提供了一个 JDBCTemplate 对象简化 JDBC 的开发。 JDBC Template 使用步骤： 1、导入 jar 包，总共 7 个 2、创建 JdbcTemplate 对象。依赖于数据源 DataSource 。JdbcTemplate template = new JdbcTemplate(ds); 3、调用 JdbcTemplate 的方法来完成 CRUD 的操作 &nbsp;&nbsp;&nbsp;&nbsp;1、update(): 执行 DML 语句。增、删、改语句 &nbsp;&nbsp;&nbsp;&nbsp;2、queryForMap(): 查询结果将结果集封装为 map 集合，将列名作为 key，将值作为 value 将这条记录封装为一个 map 集合。注意：这个方法查询的结果集长度只能是 1 &nbsp;&nbsp;&nbsp;&nbsp;3、queryForList(): 查询结果将结果集封装为 list 集合。注意：将每一条记录封装为一个 Map 集合，再将 Map 集合装载到 List 集合中 &nbsp;&nbsp;&nbsp;&nbsp;4、query(): 查询结果，将结果封装为 JavaBean 对象。query 的参数：RowMapper， 一般我们使用 BeanPropertyRowMapper 实现类。可以完成数据到 JavaBean 的自动封装 &nbsp;&nbsp;&nbsp;&nbsp;5、queryForObject：查询结果，将结果封装为对象。一般用于聚合函数的查询 JDBC Template 入门程序12345678910111213141516/** * JdbcTemplate 入门程序 */public class JdbcTemplate_Demo { public static void main(String[] args) { // 1.导入 jar 包 （总共 7 个） // 2.创建 JDBCTemplate 对象 JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); // 3.调用方法 String sql = \"update account set balance = 5000 where id = ?\"; int count = template.update(sql, 3); System.out.println(count); }} JDBC Template 练习 练习需求： 1、修改 1 号数据的 salary 为 10000 2、添加一条记录 3、删除刚才添加的记录 4、查询 id 为 1 的记录，将其封装为 Map 集合 5、查询所有记录，将其封装为 List 5、查询所有记录，将其封装为 Emp 对象的 List 集合 5、查询总记录数 定义一个 实体类 ，与数据库中的 emp 表 相对应，如下： Emp.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.Date;public class Emp { private Integer id; private String ename; private Integer job_id; private Integer mgr; private Date joindate; private Double salary; private Double bonus; private Integer dept_id; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getEname() { return ename; } public void setEname(String ename) { this.ename = ename; } public Integer getJob_id() { return job_id; } public void setJob_id(Integer job_id) { this.job_id = job_id; } public Integer getMgr() { return mgr; } public void setMgr(Integer mgr) { this.mgr = mgr; } public Date getJoindate() { return joindate; } public void setJoindate(Date joindate) { this.joindate = joindate; } public Double getSalary() { return salary; } public void setSalary(Double salary) { this.salary = salary; } public Double getBonus() { return bonus; } public void setBonus(Double bonus) { this.bonus = bonus; } public Integer getDept_id() { return dept_id; } public void setDept_id(Integer dept_id) { this.dept_id = dept_id; } @Override public String toString() { return \"Emp{\" + \"id=\" + id + \", ename='\" + ename + '\\'' + \", job_id=\" + job_id + \", mgr=\" + mgr + \", joindate=\" + joindate + \", salary=\" + salary + \", bonus=\" + bonus + \", dept_id=\" + dept_id + '}'; }} 编写测试类，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class JdbcTemplate_Practice { //Junit单元测试，可以让方法独立执行 //1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1(){ //2. 定义sql String sql = \"update emp set salary = 10000 where id = 1001\"; //3. 执行sql int count = template.update(sql); System.out.println(count); } /** * 2. 添加一条记录 */ @Test public void test2(){ String sql = \"insert into emp(id,ename,dept_id) values(?,?,?)\"; int count = template.update(sql, 1015, \"郭靖\", 10); System.out.println(count); } /** * 3.删除刚才添加的记录 */ @Test public void test3(){ String sql = \"delete from emp where id = ?\"; int count = template.update(sql, 1015); System.out.println(count); } /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4(){ String sql = \"select * from emp where id = ? or id = ?\"; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20} } /** * 5. 查询所有记录，将其封装为List */ @Test public void test5(){ String sql = \"select * from emp\"; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) { System.out.println(stringObjectMap); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6(){ String sql = \"select * from emp\"; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() { @Override public Emp mapRow(ResultSet rs, int i) throws SQLException { Emp emp = new Emp(); int id = rs.getInt(\"id\"); String ename = rs.getString(\"ename\"); int job_id = rs.getInt(\"job_id\"); int mgr = rs.getInt(\"mgr\"); Date joindate = rs.getDate(\"joindate\"); double salary = rs.getDouble(\"salary\"); double bonus = rs.getDouble(\"bonus\"); int dept_id = rs.getInt(\"dept_id\"); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; } }); for (Emp emp : list) { System.out.println(emp); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2(){ String sql = \"select * from emp\"; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) { System.out.println(emp); } } /** * 7. 查询总记录数 */ @Test public void test7(){ String sql = \"select count(id) from emp\"; Long total = template.queryForObject(sql, Long.class); System.out.println(total); }} 数据库知识到此就结束了。以后还会写一些数据库性能优化的文章，继续加油吧！！！ 问题解决1、【使用可视化工具连接远程服务器数据库】client does not support authentication 解法 1234use mysql;alter user 'root'@'%' identified with mysql_native_password by '********';flush privileges;","link":"/MySQL.html"},{"title":"Spring Boot 教程详细版（上篇）","text":"内容概要： Spring-Boot-入门 Spring-Boot-配置 Spring-Boot-日志 Spring Boot 入门Spring Boot 出现的背景J2EE 笨重的开发、繁多的配置、低下的开发效率、复杂的部署流程、第三方技术集成难度大 ，从而诞生了 Spring Boot 。举个栗子，如果不用 Spring Boot ，平时我们开发一个 Web 应用程序需要以下步骤： 传统 Web 应用开发步骤： 1、新建一个 web 工程 2、引入依赖 3、配置 web.xml 文件 4、配置框架本身的配置文件 5、加入运行容器 6、调试运行 在这些步骤中，可能感触最深的或者最麻烦的就是引入各种依赖和配置各种 xml 文件 ，一不小心，依赖包可能冲突，或者缺少，配置文件也可能写错。有的时候，我们可能只是开发的一个很小的 web 应用，但是搭建环境可能比写业务代码花的时间长 ，想起来头都大。。。或者得不偿失。这时，Spring Boot 就诞生了！ Spring Boot简介 相关链接： Spring 官网： Spring 官网Spring Boot 官网： Spring Boot 官网使用文档： Spring boot 使用文档 Spring Boot 是由 Pivotal 团队 提供的全新框架，其 设计目的 是用来简化 Spring 应用的初始搭建以及开发过程 。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。 Spring Boot 简化了基于 Spring 的应用开发，约定大于配置，去繁从简 ，通过少量的代码就能创建一个独立的、产品级别的 Spring 应用。不仅如此，Spring Boot 为 Spring 平台及第三方库提供 开箱即用 的设置 ，这样你就可以有条不紊地开始。Spring Boot 的核心思想就是约定大于配置，多数 Spring Boot 应用只需要很少的 Spring 配置 。采用 Spring Boot 可以大大的简化你的开发模式，所有你想集成的常用框架，它都有对应的组件支持。 Spring Boot 优缺点 Spring Boot 优点： 1、快速创建独立运行的 Spring 项目以及与主流框架集成 2、使用嵌入式的 Servlet 容器，应用无需打成 WAR 包 3、starters 自动依赖与版本控制 4、大量的自动配置，简化开发，也可修改默认值 5、无需配置 XML，无代码生成，开箱即用 6、准生产环境的运行时应用监控 7、与云计算的天然集成 Spring Boot 缺点： Spring Boot 唯一的缺点就是入门容易，精通难，只有对 Spring 非常的了解，才能够深度定制 Spring Boot。 Spring Boot 就是： 1、简化 Spring 应用开发的一个框架。 2、整个 Spring 技术栈的一个大整合。 3、J2EE 开发的一站式解决方案。 微服务简介微服务 是一种架构风格，它能够将单一程序开发成一组小型服务的组合，每一个功能元素最终都是一个可独立替换和独立升级的软件单元 。这些小型服务可以使用不同的编程语言以及数据存储技术 ，每一个微服务运行在自己的进程中，使用轻量级机制通信，并通过完全自动化部署机制来独立部署。 微服务： 1、始于2014年，martin fowler 的初始微服务文档 2、微服务其实就是一种架构风格（服务微化） 3、一个应用应该是一组小型服务 4、可以通过 HTTP 的方式进行互通 5、原先的应用称为单体应用：ALL IN ONE 单体应用 与 微服务 之间的对比图： 微服务之间的相互调用 关系图： Spring Boot 配置环境准备 学习 Spring Boot 前提： 1、最好学习过 Spring 框架 2、能够使用 Maven 进行项目构建和依赖管理 3、熟悉使用 IDE，如 IDEA 、 Eclipse 或者 STS 等等 环境准备： 1、JDK1.8：Spring Boot 官网推荐 jdk1.7 及以上，个人推荐使用 JDK1.8 或 JDK11 2、Maven3.x：maven 3.3 以上版本 3、IntelliJ IDEA：2017年及以上，可使用 2020 版本，支持中文哦 4、Spring Boot 1.5.9.RELEASE：Spring Boot 官网推荐 1.5.9 及以上，个人推荐 Spring Boot 2.x 以上 Maven 配置找到 Maven 安装目录下 settings.xml 配置文件的 profiles 标签，然后在 profiles 里面添加下面代码： D:\\01_Programs\\02_Java\\06_Maven\\apache-maven-3.5.2\\conf\\settings.xml1234567891011121314&lt;!-- 如果你的 JDK 是 1.8 的，那就直接复制，是其他的，改一下就行了 --&gt;&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; IDEA 配置按照 File\\settings\\build,Execution,Deployment\\Build Tools\\Maven 路径 给 IDEA 配置好 Maven ，配置项及截图如下： File\\settings\\build,Execution,Deployment\\Build Tools\\Maven12345# 配置好 Maven 的下列三项：- Maven home directory- User settings file- Local repository 创建一个简单的 Web 应用现在就使用 Spring Boot 开发一个小功能：浏览器发送一个 hello 请求 ，服务器接受请求并处理，然后返回相应的结果。那就开始吧！ 创建 Maven 项目新建一个 project 或者 module ，选择 Maven ，然后填写相关信息，一直下一步即可 ，直到 Finish 就完成了 Maven 项目的创建。我创建的项目工程名是 001-springboot-helloworld，完成后如下图： 导入相关的依赖打开 Maven 工程下的 pom.xml 文件，把以下代码复制到 pom.xml 文件中： pom.xml1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建主程序在 Maven 项目的 src\\main\\java 下面创建 主程序 HelloWorldApplication ，【下方有注意事项】 ，注意事项及代码如下： 注意事项： 1、我的包名为 edu.jgsu ，路径是：src\\main\\java\\edu\\jgsu 2、HelloWorldApplication 必须放在 jgsu 包里面 3、以后所有包和类必须放在 jgsu 包下面的子包里面，即 jgsu 下面的子包 和 HelloWorldApplication 同级 4、文字描述不够直观，请看下图 001-springboot-helloworld\\src\\main\\java\\edu\\jgsu\\HelloWorldApplication12345678910111213package edu.jgsu;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication// @SpringBootApplication 用来标注一个主程序类，说明这是一个 Spring Boot 应用public class HelloWorldApplication { public static void main(String[] args) { // 将 Spring 应用启动起来 SpringApplication.run(HelloWorldApplication.class, args); }} 编写 Controller在 edu\\jgsu 下面新建一个 Controller 包 ，然后在 Controller 下编写 HelloController 类 。代码如下： 123456789101112131415package edu.jgsu.Controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloController { @ResponseBody // 返回字符串，不写这个注解，那么spring boot 就会去 resources 下找以 Hello,Spring Boot! 命名的静态页面 @RequestMapping(\"/hello\") // 访问路径 public String Hello(){ return \"Hello,Spring Boot!\"; }} 启动运行切换到 HelloWorldApplication 类 ，运行其主方法 ，然后在浏览器输入如下地址即可。如果看到以下效果，代表 启动成功 ： 然后在地址栏后面加上 /hello ，/hello 来自于 HelloController 类 @RequestMapping 注解 里面的字符串。成功如下图： 打包部署添加打包插件 ，把以下代码添加到 pom.xml 文件 &lt;/project&gt; 上一行中： 123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的 jar 包 --&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 选择 Maven ，然后点击 Lifecycle\\package 命令即可进行打包。如下图： 打包完成之后，停止 Maven 项目运行，去 Maven 工程目录下找到 target 文件夹，刚刚打包的 jar 包就放在里面 。然后复制到桌面，使用 java -jar xxx.jar 命令来使用 jar 包。这个 jar 包 内嵌 tomcat ，启动成功后仍然可以通过浏览器访问，如下图： 拓展：自定义 banner我们启动 spring 项目时，默认的 banner 是这样的，如下： 123456 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ 如果我想把 banner 换成其他的文字可以吗？当然可以，以下是步骤： 替换步骤： 1、搜索引擎搜索：spring boot banner 。个人推荐网站：https://www.bootschool.net/ascii 2、输入自己喜欢的文字，然后生成，最后拷贝结果。或者点击 ASCll 艺术字，然后寻找到自己喜欢的 banner 并拷贝结果。 3、回到 IDEA ，在 src/main/resources/ 下新建 banner.txt 文本，把拷贝结果复制到里面即可。 4、重新启动项目，即可看到结果，示例如下： 123456789101112131415161718192021222324# 我的 banner////////////////////////////////////////////////////////////////////// _ooOoo_ //// o8888888o //// 88\" . \"88 //// (| ^_^ |) //// O\\ = /O //// ____/`---'\\____ //// .' \\\\| |// `. //// / \\\\||| : |||// \\ //// / _||||| -:- |||||- \\ //// | | \\\\\\ - /// | | //// | \\_| ''\\---/'' | | //// \\ .-\\__ `-` ___/-. / //// ___`. .' /--.--\\ `. . ___ //// .\"\" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'\"\". //// | | : `- \\`.;`\\ _ /`;.`/ - ` : | | //// \\ \\ `-. \\_ __\\ /__ _/ .-` / / //// ========`-.____`-.___\\_____/___.-`____.-'======== //// `=---=' //// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ //// 佛祖保佑 永不宕机 永无BUG ////////////////////////////////////////////////////////////////////// TIPS： 到这里为止，一个通过 Maven 构建的 Spring Boot 应用 就完成了。接下来将对这个应用进行剖析。 hello world 应用剖析为什么 Spring Boot 能够如此简单的实现一个 Web 应用？为什么 Spring Boot 不需要配置繁琐的 tomcat 服务器？*这就要归功于 Spring Boot 的各种启动器 * 。先阅读以下依赖并分析： 1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;!-- web 相关依赖：包括 tomcat、dispatcherServlet和 xml 配置文件等等 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter 称之为 场景启动器 ，它能够帮我们导入了各种模块正常运行所依赖的组件 。Spring Boot 将所有的功能场景都抽取出来，做成一个个的 starters（启动器） ，只需要在项目里面引入这些 starter ，那么相关场景的所有依赖都会导入进来 。要用什么功能就导入什么场景的启动器即可。例如要用到 邮件 ，那就导入 spring-boot-starter-mail 启动器。具体用哪一个版本可参考官网的某一个详细版本。如 版本2.12 。接下来，我们再来看看下面的依赖： 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; spring-boot-starter-parent 是 spring-boot-starter-web 的父项目。而 spring-boot-dependencies 是 spring-boot-starter-parent 的父项目，它才是是真正管理 Spring Boot 应用里面的所有的依赖版本的管理者，也可以称之为 Spring Boot 的版本仲裁中心 。以后我们导入依赖，默认是不需要写版本的。【除非没有在 dependencies 里面管理的依赖，才需要声明版本号】 自动配置原理让我们先来看看 Spring Boot 的主程序类 HelloWorldApplication ，也就是 Spring Boot 应用的入口，代码如下： 001-springboot-helloworld\\src\\main\\java\\edu\\jgsu\\HelloWorldApplication12345678910111213package edu.jgsu;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication// @SpringBootApplication 用来标注一个主程序类，说明这是一个 Spring Boot 应用public class HelloWorldApplication { public static void main(String[] args) { // 将 Spring 应用启动起来 SpringApplication.run(HelloWorldApplication.class, args); }} @SpringBootApplication 注解是用来说明这个类是 Spring Boot 的主配置类 ，Spring Boot 就应该运行这个类的 main 方法来启动 Spring Boot 应用 。让我们跟进 @SpringBootApplication 看一下： 1234567891011121314151617181920@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class}), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class})})public @interface SpringBootApplication { @AliasFor( annotation = EnableAutoConfiguration.class )... @SpringBootConfiguration 是 Spring Boot 的配置类注解，用于标注在某个类上，表示这是一个 Spring Boot 的配置类 。跟进这个注解，我们又发现了 @Configuration 注解，这个注解用于配置类，是 Spring 底层注解。Spring Boot 中的配置类和 Spring 中的配置文件是等价的 。接着往下看，@Component 注解表示配置类也是容器中的一个组件。 以前我们需要手动配置的东西，现在 Spring Boot 帮我们自动配置。@EnableAutoConfiguration 这个注解的作用就是 告诉 Spring Boot 开启自动配置功能 ，这样自动配置才能生效。跟进这个注解： 123456789@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import({AutoConfigurationImportSelector.class})public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";... 在上面代码中，有两个注解很重要，@AutoConfigurationPackage 和 @Import 。@AutoConfigurationPackage 注解 ：自动配置包，将主配置类【@SpringBootApplication 标注的类】的所在包及下面所有子包里面的所有组件扫描到 Spring 容器 。如果把上面的 Controller 包下面的 HelloController 类 剪切到 edu 包下，此时，这个类不在扫描的范围之内，那么 HelloController 类将无法被访问，那么当我们访问 /Hello 时，报错 404 。下面，我们跟进这个注解看一下： 1234567Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import({Registrar.class})public @interface AutoConfigurationPackage {} Spring 的底层注解 @Import ，给容器中导入一个组件，导入的组件为 Registrar.class 。进一步的源码也就不分析了，到这里就差不多了【其实是博主水平有限，只能到这了，哈哈】。 那么到这里为止，我们清楚了 自动配置注解的功能 就是给容器中导入非常多的自动配置类【xxxAutoConfiguration】，就是给容器中导入某个场景需要的所有组件，并配置好这些组件 。有了自动配置类，也就免去了我们手动编写配置注入功能组件等相关工作。 Spring Boot 在启动的时候从 类路径下 的 META-INF/spring.factories 中获取 EnableAutoConfiguration 注解所指定的值 ，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。以前我们需要自己配置的东西，现在自动配置类都帮我们配置好。J2EE 的整体整合解决方案和自动配置都在 spring-boot-autoconfigure-2.0.1.RELEASE.jar 。 快速创建 Spring Boot 应用使用 Spring Initializr 快速创建 Spring Boot 应用。首先 ，我们新建一个模块或者工程，选择左边的 Spring Initializr ，然后点击下一步，如下图： 然后填好相关信息，点击下一步 ，此刻进入到 依赖选择页面 ，选择好你要依赖，例如你要做 Web 开发，那么你就选择左侧的 Web ，中间选择你要的依赖，我选的是 Spring Web 。如果你还要用到数据库，那就选择数据库相关的即可。下图仅供参考： 选择好以后，点击完成即可。这里要 注意一点 ：选择我们需要的模块之后，向导会联网创建 Spring Boot 项目 【一定要联网】 。创建完成之后项目结构如下图。然后自己编写 Controller 类，再去浏览器访问 ，这里就不在赘述了。 项目创建成功后，默认生成的内容有哪些呢？如下： 默认生成的内容： 1、主程序 Application 已经生成好了，我们只需要编写业务逻辑即可 2、resources 文件夹中目录结构 &nbsp;&nbsp;&nbsp;&nbsp;1、static：保存所有的静态资源：如 js、css、images 等等 &nbsp;&nbsp;&nbsp;&nbsp;2、templates：保存所有的模板页面 &nbsp;&nbsp;&nbsp;&nbsp;3、application.properties：Spring Boot 应用的配置文件，可以修改一些默认设置 3、Spring Boot 默认 jar 包使用嵌入式的 Tomcat，默认不支持 JSP 页面，所以要使用模板引擎（freemarker、thymeleaf） Spring Boot 的配置文件Spring Boot 使用一个全局的配置文件，配置文件名是固定的 ，就叫做 application ，但是 后缀却有两种写法 ：properties 和 yaml 。 例如：application.properties 、 application.yml 或者 application.yaml 。其实有很多配置 pring Boot 在底层都给我们自动配置好了，而配置文件的作用 就是修改 Spring Boot 自动配置的默认值 。 YAML 配置文件.yml 或 .yaml 是 YAML（YAML Ain’t Markup Language） 语言的文件，以数据为中心，比 json、xml 等更适合做配置文件 。知识拓展：YAML 的语法规范：http://www.yaml.org/ 。 YAML Ain't Markup Language 的解释： 1、YAML A Markup Language：是一个标记语言 2、YAML isn't Markup Language：不是一个标记语言 标记语言对比 以前的配置文件大多都使用的是 xxxx.xml 文件，而 xml 大量的数据浪费在了标签的开闭上。 YAML 文件以数据为中心，比 json、xml 等更适合做配置文件 具体对比如下 12345678910111213# properties 配置文件server.port=8080# YAML 配置文件server: port: 8080# xml 配置文件&lt;server&gt; &lt;port&gt;8080&lt;/port&gt;&lt;/server&gt; YAML 基本语法YAML 基本语法格式 ：key:(空格)value 。例如：port: 8080 。表示一对键值对（空格必须有）。以 空格的缩进 来控制层级关系，只要是 左对齐 的一列数据，都是同一个层级的。属性和值也是大小写敏感 ，如下代码：四个属性同一层级，且 PORT 和 port 、 PATH 和 path 是不同属性。 12345server: port: 8081 PORT: 8082 path: /hello PORT: /world YAML 值的写法第一种写法： 字面量：普通的值（数字，字符串，布尔）。字面量格式 ：key: value 。字面直接来写，字符串默认不用加上单引号或者双引号，加上有不同意义 。加上双引号： 不会转义字符串里面的特殊字符，特殊字符会作为本身想表示的意思。例如：name: “zhangsan \\n lisi” 输出：zhangsan 换行 lisi 。加上单引号： 会转义特殊字符，特殊字符最终只是一个普通的字符串数据。例如：name: ‘zhangsan \\n lisi’ 输出：zhangsan \\n lisi 。 123name: zhangsanage: 23address: HangZhou 第二种写法： 对象、Map【属性和值】【键值对】 。key: value 在下一行来写对象的属性和值的关系。注意事项: 缩进对象还是 key: value 的方式 。如下 friends 对象： 12345678# 对象的默认写法friends: name: zhangsan hobby: chess# 对象的行内写法friends: {name: zhangsan,hobby: chess} 第三种写法： 数组（List、Set） 。用 ' - ' 来表示数组中的一个元素，写法如下： 123456789# 数组的默认写法pets: - cat - dog - pig# 数组的行内写法pets: [cat,dog,pig] 配置文件值的注入yaml 配置文件 如下，那么 如何把配置文件里面的值注入到 Java 代码里呢 ？即如何实现配置文件与实体类之间的映射？ 123456789101112131415# yamlperson 在 java 程序中通过 @ConfigurationProperties 注解与 java 程序绑定到一起yamlperson: lastName: guo age: 22 boss: false birth: 2018/12/3 maps: {key1: value1,key2: value2} lists: - key1 - key2 - key3 dog: name: milk-bottle age: 7 首先编写 YamlPerson 类 ，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package edu.jgsu.bean;import java.util.List;import org.hibernate.validator.constraints.Email;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;import org.springframework.validation.annotation.Validated;import javax.validation.constraints.Null;import java.util.Date;import java.util.List;import java.util.Map;/** * @Author: guoshizhan * @Create: 2020/2/2 22:49 * @Description: 映射 yaml 配置文件 */// @Component 把类添加到容器中，使之成为容器中的组件，才能使用容器提供的 @ConfigurationProperties 功能。@Component// @ConfigurationProperties：告诉 Spring Boot 将本类中的所有属性和配置文件中相关的配置进行绑定。@ConfigurationProperties(prefix = \"yamlperson\") // 绑定到 yaml 配置文件中的 yamlperson 对象 【prefix 的值必须小写，大写会报错】public class YamlPerson { // 可以使用 @Value 注解对属性赋值 private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; @Override public String toString() { return \"Person{\" + \"lastName='\" + lastName + '\\'' + \", age=\" + age + \", boss=\" + boss + \", birth=\" + birth + \", maps=\" + maps + \", lists=\" + lists + \", dog=\" + dog + '}'; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Boolean getBoss() { return boss; } public void setBoss(Boolean boss) { this.boss = boss; } public Date getBirth() { return birth; } public void setBirth(Date birth) { this.birth = birth; } public Map&lt;String, Object&gt; getMaps() { return maps; } public void setMaps(Map&lt;String, Object&gt; maps) { this.maps = maps; } public List&lt;Object&gt; getLists() { return lists; } public void setLists(List&lt;Object&gt; lists) { this.lists = lists; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; }}class Dog { private String name; private Integer age; @Override public String toString() { return \"Dog{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; }} 然后编写 ApplicationTests 测试类 就可以看到效果了，代码如下： 123456789101112131415161718192021package edu.jgsu;import edu.jgsu.bean.YamlPerson;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;// 测试类如果少了 public ，那么测试类无法使用@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTests { @Autowired YamlPerson yamlPerson; @Test public void test1(){ System.out.println(yamlPerson); }} 测试结果如下： 1232020-02-02 23:25:46.436 INFO 1472 --- [ main] edu.jgsu.ApplicationTests : Started ApplicationTests in 3.729 seconds (JVM running for 5.654)Person{lastName='guo', age=22, boss=false, birth=Mon Dec 03 00:00:00 CST 2018, maps={key1=value1, key2=value2}, lists=[key1, key2, key3], dog=Dog{name='milk-bottle', age=7}}2020-02-02 23:25:46.579 INFO 1472 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@18d604b: startup date [Sun Feb 02 23:25:43 CST 2020]; root of context hierarchy 我们还可以 导入配置文件处理器 ，以后编写配置就有提示了。在 pom.xml 文件中加入以下代码： 1234567 &lt;!-- 导入配置文件处理器，实体类在与配置文件进行绑定，在配置文件中输入值就会有提示 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; TIPS： yaml 文件中 ，lastName == last-name 。在编写属性时提示 last-name 就不用大惊小怪了。 现在来看一下上面 yaml 配置文件在 properties 配置文件 中的编写： 12345678910yamlperson.last-name=guoyamlperson.age=22yamlperson.boss=falseyamlperson.birth=2018/12/3yamlperson.maps.key1=value1yamlperson.maps.key2=value2yamlperson.maps.key3=value3yamlperson.lists=key1,key2,key3yamlperson.dog.name=milk-bottleyamlperson.dog.age=7 注意事项： 有的时候属性值为中文，那么可能出现乱码 。解决办法： 去 File | Settings | Editor | File Encodings 配置 utf-8 ，然后把 转成 ASCll 的那个选项勾上即可 。 现在，我们来看一下 配置文件和实体类进行映射的第二种姿势 ：使用 @Value 注解，部分代码如下： 1234567891011121314@Component//@ConfigurationProperties(prefix = \"yamlperson\") // prefix 的值必须小写，大写会报错public class YamlPerson { // lastName 必须是邮箱格式 // @Email 这个注解来自于 JSR303 数据校验【此部分知识自行搜索一下，不是很重要】 @Value(\"${yamlperson.last-name}\") // 使用 SPEL 表达式取出配置文件的值 private String lastName; @Value(\"#{11*2}\") private Integer age; @Value(\"true\") private Boolean boss;... 映射后的结果如下： 1232020-02-03 00:30:41.800 INFO 13740 --- [ main] edu.jgsu.ApplicationTests : Started ApplicationTests in 3.816 seconds (JVM running for 5.752)Person{lastName='guo', age=22, boss=true, birth=null, maps=null, lists=null, dog=null}2020-02-03 00:30:42.080 INFO 13740 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@3cf2ba: startup date [Mon Feb 03 00:30:38 CST 2020]; root of context hierarchy @Value 获取值和 @ConfigurationProperties 获取值比较，如下表： 获取值的两种方式 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件 yml 还是 properties 它们都能获取到值。那么开发的时候用哪一个好呢？ 1、如果说，我们只是在某个业务逻辑中需要 获取一下配置文件中的某项值 ，使用 @Value 。2、如果说，我们专门编写了一个 JavaBean 来和配置文件进行映射，我们就直接使用 @ConfigurationProperties 。 @PropertySource 、 @ImportResource 和 @Bean 三个注解对比。首先介绍 @PropertySource ，这个注解 用于加载指定的配置文件，即自己定义的配置文件 ，如 person.properties ，代码如下： custom.properties12yamlperson.last-name=典韦yamlperson.age=22 实体类部分代码如下： 123456789101112@PropertySource(value = {\"classpath:person.properties\"})@Component@ConfigurationProperties(prefix = \"yamlperson\") //prefix的值必须小写，大写会报错/** * @Author: guoshizhan * @Create: 2020/2/2 22:49 * @Description: 映射自定义的 yaml 配置文件 */public class YamlPerson { private String lastName; private Integer age;... 最终返回结果： 1232020-02-03 10:27:30.260 INFO 22524 --- [ main] edu.jgsu.ApplicationTests : Started ApplicationTests in 3.158 seconds (JVM running for 4.347)Person{lastName='典韦', age=22, boss=null, birth=null, maps=null, lists=null, dog=null}2020-02-03 10:27:30.415 INFO 22524 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@11001e5: startup date [Mon Feb 03 10:27:27 CST 2020]; root of context hierarchy 接着介绍 @ImportResource ，这个注解 用于导入 Spring 的配置文件 ，让配置文件里面的内容生效。如下 bean.xml ，代码如下： bean.xml1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"edu.jgsu.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; 然后 在测试类添加下列代码 ，测试 IOC 容器中是否有 helloService 这个对象，代码如下： 1234567@AutowiredApplicationContext ioc;@Testpublic void test2(){ System.out.println(ioc.containsBean(\"helloService\"));} 最终返回结果： 1232020-02-03 11:02:28.466 INFO 13836 --- [ main] edu.jgsu.ApplicationTests : Started ApplicationTests in 3.041 seconds (JVM running for 4.307)false2020-02-03 11:02:28.611 INFO 13836 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@8ff24: startup date [Mon Feb 03 11:02:25 CST 2020]; root of context hierarchy 上面的实验说明，Spring Boot 里面没有 Spring 的配置文件，我们自己编写的配置文件 bean.xml也不能被自动识别 。想让 Spring 的配置文件生效，那么就 在 Spring Boot 启动类中 加 @ImportResource 注解，代码如下： 123456789101112131415package edu.jgsu;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ImportResource;@ImportResource(locations = {\"classpath:bean.xml\"}) // 导入 Spring 配置文件并使其生效@SpringBootApplicationpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 然后再去测试类测试，最终结果： 1232020-02-03 11:08:00.350 INFO 9568 --- [ main] edu.jgsu.ApplicationTests : Started ApplicationTests in 3.61 seconds (JVM running for 5.002)true2020-02-03 11:08:00.526 INFO 9568 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@ed52de: startup date [Mon Feb 03 11:07:57 CST 2020]; root of context hierarchy 在开发中，不会这样做，自己写配置文件，然后加载进来，这样太麻烦。接下来介绍 Spring Boot 推荐给容器中添加组件的方式：不编写 Spring 的配置文件，使用全注解的方式。首先，我们编写一个配置类： MyConfig.java1234567891011121314151617181920212223package edu.jgsu.config;import edu.jgsu.service.HelloService;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @Author: guoshizhan * @Create: 2020/2/3 11:23 * @Description: * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件,在 Spring 配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件， * 而在配置类中使用使用@Bean给容器中添加组件。 */@Configurationpublic class MyConfig { //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02(){ System.out.println(\"配置类给 IOC 容器中添加组件了...\"); return new HelloService(); }} 然后回到测试类 test2 方法进行测试，返回结果如下： 1234567891011122020-02-03 11:31:41.352 INFO 5760 --- [ main] o.s.b.f.xml.XmlBeanDefinitionReader : Loading XML bean definitions from class path resource [bean.xml]配置类给 IOC 容器中添加组件了...2020-02-03 11:31:42.229 INFO 5760 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2020-02-03 11:31:42.466 INFO 5760 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.web.context.support.GenericWebApplicationContext@ed52de: startup date [Mon Feb 03 11:31:40 CST 2020]; root of context hierarchy2020-02-03 11:31:42.546 INFO 5760 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/hello]}\" onto public java.lang.String edu.jgsu.Controller.HelloController.Hello()2020-02-03 11:31:42.549 INFO 5760 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/error]}\" onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2020-02-03 11:31:42.550 INFO 5760 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/error],produces=[text/html]}\" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2020-02-03 11:31:42.577 INFO 5760 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2020-02-03 11:31:42.577 INFO 5760 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2020-02-03 11:31:43.369 INFO 5760 --- [ main] edu.jgsu.ApplicationTests : Started ApplicationTests in 2.943 seconds (JVM running for 4.215)true2020-02-03 11:31:43.474 INFO 5760 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@ed52de: startup date [Mon Feb 03 11:31:40 CST 2020]; root of context hierarchy 如果把配置类的方法 helloService 方法改为 helloService02 ，那么返回结果就为 false 了。这个我就不贴代码了。 配置文件占位符先来看配置文件： application.properties12345678910yamlperson.last-name=guo${random.uuid}yamlperson.age=${random.int}yamlperson.boss=falseyamlperson.birth=2018/12/3yamlperson.maps.key1=value1yamlperson.maps.key2=value2yamlperson.maps.key3=value3yamlperson.lists=key1,key2,key3yamlperson.dog.name=${yamlperson.last-name}-milk-bottleyamlperson.dog.age=7 然后去测试类测试，返回结果如下： 1232020-02-03 11:50:18.934 INFO 24560 --- [ main] edu.jgsu.ApplicationTests : Started ApplicationTests in 2.958 seconds (JVM running for 4.29)Person{lastName='guoa1e7ef2b-0e1f-41de-a9fa-16dce9687809', age=1319770232, boss=false, birth=Mon Dec 03 00:00:00 CST 2018, maps={key1=value1, key2=value2, key3=value3}, lists=[key1, key2, key3], dog=Dog{name='guoe6b21bd7-bd07-4af5-92eb-915f435eb465-milk-bottle', age=7}}2020-02-03 11:50:19.074 INFO 24560 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@19df09a: startup date [Mon Feb 03 11:50:16 CST 2020]; root of context hierarchy 占位符获取的是原先配置好了的值，如果没有配置，可以是用 “: “ 来指定默认值。例如： 1yamlperson.hello=${yamlperson.hello:world}-java 我的代码了并没有 hello 这个属性，所以它会使用 world 这个被指定的值。所以结果为： world-java 。那么，如果代码是这样的： 1yamlperson.hello=${yamlperson.hello}-java 这里既没有 hello 属性，也没有指定值，那么返回结果为： ${yamlperson.hello}-java 。以下是常用随机数代码： 12${random.value}、${random.int}、${random.long}${random.int(10)}、${random.int[1024,65536]} ProfileProfile 是 Spring 对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境。 多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml，实例代码如下： 默认的配置文件的端口application.properties1server.port=8080 开发的配置文件端口application-dev.properties1server.port=8081 测试的配置文件端口application-test.properties1server.port=8082 上面那么多配置文件，该使用哪一个呢？Spring Boot 默认使用 application.properties 的配置。 激活指定 Profileproperties文件激活指定 Profile : 在 properties 配置文件中激活指定，代码如下： application.properties12server.port=8080spring.profiles.active=dev 激活完成后，那么端口不是 8080 了，而是 dev 的端口 8081 。 命令行中激活指定：把已经打成 jar 包的文件可以在命令行中再次激活 Profile 1java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev 也可以直接在测试的时候，配置中传入命令行参数，如下图： 虚拟机参数激活指定，如下图： 1-Dspring.profiles.active=dev yml 支持多文档块方式激活指定 Profile，比 properties 更简单。格式：使用下面代码中的小短线将 yaml 文件分成几个文档块，如下代码： 123456789101112131415server: port: 8080spring: profiles: active: test #激活 test 环境---server: port: 8081spring: profiles: dev---server: port: 8082spring: profiles: test #指定属于哪个环境 配置文件加载位置Spring Boot 启动会扫描以下位置的 application.properties 或者 application.yml 文件作为 Spring Boot 的默认配置文件。那么 Spring Boot 是从哪里去找这些配置文件呢？现在告诉你，它从下面四个位置去找： 1234567891011# 项目根目录下的 config 文件夹里的配置文件– file:./config/# 项目根目录下的配置文件– file:./# 类路径下的 config 文件夹下的配置文件，即 resources/config 文件夹下的配置文件– classpath:/config/# 类路径下的配置文件，即 resources 文件夹下的配置文件– classpath:/ 以上是 按照优先级 从高到低 的顺序排序，Spring Boot 会从这四个位置加载所有的主配置文件，即上述所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置内容 ，而且还会 互补配置 。我们还可以通过 spring.config.location 来改变默认的配置文件位置。项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置。例如下面代码，加载了 G 盘的配置文件： 1java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --spring.config.location=G:/application.properties 外部配置加载顺序SpringBoot也可以从以下位置加载配置:优先级从高到低，高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置。顺序如下： 命令行参数 【重要】所有的配置都可以在命令行上进行指定，多个配置用空格分开，格式： –配置项=值。代码演示如下：1java -jar spring-boot-config-02-0.0.1-SNAPSHOT.jar --server.port=8087 --server.context-path=/abc 来自 java:comp/env 的 JNDI 属性 Java 系统属性（System.getProperties()） 操作系统环境变量 RandomValuePropertySource 配置的 random.* 属性值 配置文件查顺序：由jar包外向jar包内进行寻找。优先加载带profile，然后再来加载不带profile。 jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 【重要】 jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 【重要】 jar包外部的application.properties或application.yml(不带spring.profile)配置文件 【重要】 jar包内部的application.properties或application.yml(不带spring.profile)配置文件 【重要】 @Configuration注解类上的@PropertySource 通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源:参考官方文档 自动配置原理配置文件到底能写什么？怎么写？请参照文档：配置文件能配置的属性参照Spring Boot 启动的时候加载主配置类，开启了自动配置的功能，这主要归功于 @EnableAutoConfiguration 这个注解，它利用 EnableAutoConfigurationImportSelector 类给容器中导入一些组件，可以查看 selectImports() 方法的内容，获取到的候选配置以 List 集合返回，代码如下： 12345// SpringFactoriesLoader.loadFactoryNames()// 扫描所有jar包类路径下 META-INF/spring.factories// 把扫描到的这些文件的内容包装成properties对象// 从properties中获取到 EnableAutoConfiguration.class 类（类名）对应的值，然后把他们添加在容器中List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); // 获取候选的配置 将类路径下 META-INF/spring.factories 里面配置的所有 EnableAutoConfiguration 的值加入到了容器中: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# 所有的自动配置类org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration 类都是容器中的一个组件，都加入到容器中，用他们来做自动配置。那么每一个自动配置类是如何进行自动配置功能呢？以 HttpEncodingAutoConfiguration（Http编码自动配置） 为例解释自动配置原理。 12345678910111213141516171819202122232425262728293031323334// 表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@Configuration// 启动指定类的 ConfigurationProperties 功能；将配置文件中对应的值和 HttpEncodingProperties 绑定起来；并把 HttpEncodingProperties 加入到 ioc 容器中@EnableConfigurationProperties(HttpEncodingProperties.class);// Spring 底层 @Conditional 注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效。判断当前应用是否为 web 应用，如果是，当前配置类生效@ConditionalOnWebApplication// 判断当前项目有没有这个类 CharacterEncodingFilter ，Spring MVC 中进行乱码解决的过滤器@ConditionalOnClass(CharacterEncodingFilter.class);// 判断配置文件中是否存在某个配置： spring.http.encoding.enabled ，如果不存在，判断也是成立的。即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的@ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true)public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) { this.properties = properties; } @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; } 根据当前不同的条件判断，决定这个配置类是否生效。一但这个配置类生效，这个配置类就会给容器中添加各种组件，这些组件的属性是从对应的 properties 类中获取的，这些类里面的每一个属性又是和配置文件绑定的。所有在配置文件中能配置的属性都是在 xxxxProperties 类中封装者，配置文件能配置什么就可以参照某个功能对应的这个属性类。 1234@ConfigurationProperties(prefix = \"spring.http.encoding\") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties { public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\"); 自动配置的精髓 Spring Boot 启动会加载大量的自动配置类 我们看我们需要的功能有没有 Spring Boot 默认写好的自动配置类 我们再来看这个自动配置类中到底配置了哪些组件【只要我们要用的组件有，我们就不需要再来配置了】 给容器中自动配置类添加组件的时候，会从 properties 类中获取某些属性。我们就可以在配置文件中指定这些属性的值 xxxxAutoConfigurartion：自动配置类，给容器中添加组件 xxxxProperties:封装配置文件中相关属性 @Conditional派生注解作用：必须是 @Conditional 指定的条件成立，才给容器中添加组件，配置配里面的所有内容才能生效 @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效，点进某一个自动配置类，查看这个类生效所需要的条件：如下面的 aop 自动配置类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package org.springframework.boot.autoconfigure.aop;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.reflect.Advice;import org.aspectj.weaver.AnnotatedElement;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration// 如果没有导入 @ConditionalOnClass 注解里面的字节码文件，即相关 jar 包，自动配置类是无法生效的，这就是生效的条件：即各种 Conditional 注解。@ConditionalOnClass({EnableAspectJAutoProxy.class, Aspect.class, Advice.class, AnnotatedElement.class})@ConditionalOnProperty( prefix = \"spring.aop\", name = {\"auto\"}, havingValue = \"true\", matchIfMissing = true)public class AopAutoConfiguration { public AopAutoConfiguration() { } @Configuration @EnableAspectJAutoProxy( proxyTargetClass = true ) @ConditionalOnProperty( prefix = \"spring.aop\", name = {\"proxy-target-class\"}, havingValue = \"true\", matchIfMissing = true ) public static class CglibAutoProxyConfiguration { public CglibAutoProxyConfiguration() { } } @Configuration @EnableAspectJAutoProxy( proxyTargetClass = false ) @ConditionalOnProperty( prefix = \"spring.aop\", name = {\"proxy-target-class\"}, havingValue = \"false\", matchIfMissing = false ) public static class JdkDynamicAutoProxyConfiguration { public JdkDynamicAutoProxyConfiguration() { } }} 我们怎么知道哪些自动配置类生效了，哪些没有生效呢？我们可以通过启用 debug=true 属性，来让控制台打印自动配置报告，这样我们就可以很方便的知道自动配置类是否生效了。 先在配置文件中加入下列代码： application.properties1debug=true 然后运行 Spring Boot 主程序，就可看到控制台的自动配置报告，部分代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243442020-02-04 12:05:38.905 DEBUG 25984 --- [ main] ConditionEvaluationReportLoggingListener : ============================CONDITIONS EVALUATION REPORT============================Positive matches:----------------- CodecsAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.http.codec.CodecConfigurer'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) CodecsAutoConfiguration.JacksonCodecConfiguration matched: - @ConditionalOnClass found required class 'com.fasterxml.jackson.databind.ObjectMapper'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) CodecsAutoConfiguration.JacksonCodecConfiguration#jacksonCodecCustomizer matched: - @ConditionalOnBean (types: com.fasterxml.jackson.databind.ObjectMapper; SearchStrategy: all) found bean 'jacksonObjectMapper' (OnBeanCondition) DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - found ConfigurableWebEnvironment (OnWebApplicationCondition)...Negative matches:----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice', 'org.aspectj.weaver.AnnotatedElement' (OnClassCondition) ArtemisAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.artemis.jms.client.ActiveMQConnectionFactory' (OnClassCondition) BatchAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.springframework.batch.core.launch.JobLauncher', 'org.springframework.jdbc.core.JdbcOperations' (OnClassCondition)... 到此为止， Spring Boot 的配置学习就结束，记得常回来温习，巩固知识。接下来介绍 Spring Boot 与日志。 Spring Boot 日志市面上的日志框架JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j …. 日志门面 （日志的抽象层） 日志实现 SLF4j（Simple Logging Facade for Java） jboss-logging JCL（Jakarta Commons Logging） Log4j JUL（java.util.logging） Log4j2 Logback SLF4j 、 Log4j 、Logback 都是出自同一个人之手。现在我们从左边选一个门面（抽象层）、右边来选一个实现，最佳的搭配如下。【不使用Log4j ，是因为 Logback 比它更好，而且作者为同一人。不使用 JUL ，因为诞生就是和 Log4j 进行市场竞争的，所以没有后来的 Logback 好。不选择 Log4j2 的理由就是 它做的太好了，还不能和框架适配起来。就像计算机网络中的 OSI 七层协议和 OSI 五层协议 一样，七层太好了，还不能适配，五层并非官方，市场上却用的最多】 日志门面：SLF4J 日志实现：Logback Spring Boot 的底层是 Spring 框架，Spring 框架默认是用 JCL（Jakarta Commons Logging） 作为日志框架。而 Spring Boot 选用 SLF4j 和 logback 作为日志框架。 SLF4j 的使用那我们如何在系统中使用 SLF4j 呢？参考官网： https://www.slf4j.org 。如下图示： 我们以后在开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法。首先就要给系统里面导入 slf4j 的 jar 和 logback 的实现 jar 。 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); }} 每一个日志的实现框架都有自己的配置文件，使用 slf4j 以后，配置文件还是做成日志实现框架自己本身的配置文件。如果你是用 logback 实现的，那就做成 logback 的配置文件。 遗留问题打个比方，开发 A 系统时使用的是 slf4j + logback 日志框架，又用到了Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis 等等各种 JavaEE 框架，那么就会出现好多日志框架，导致冲突。那么我们就要统一日志记录，即要求别的框架统一使用 slf4j 进行输出。那么该如何做呢？该如何让系统中所有的日志都统一到 slf4j 呢？ 将系统中其他日志框架先排除出去 用中间包来替换原有的日志框架 我们导入slf4j其他的实现 下图是官方的解决方案图： Spring Boot 日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; Spring Boot 使用它来做日志功能 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; Spring Boot 日志底层依赖关系，如下图： Spring Boot 日志总结： Spring Boot 底层也是使用 slf4j + logback 的方式进行日志记录 Spring Boot 也把其他的日志都替换成了 slf4j 中间替换包，log4j 的底层仍然使用 Slf4j ，如下面代码所示，其他的中间替换包原理都一样。123456@SuppressWarnings(\"rawtypes\")public abstract class LogFactory { static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\"; static LogFactory logFactory = new SLF4JLogFactory(); 如果我们要引入其他框架，一定要把这个框架的默认日志依赖移除掉SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可。 日志使用Spring Boot 默认帮我们配置好了日志，只要我们运行程序，控制台便会有日志输出，测试程序如下： 1234567891011121314151617181920212223242526272829package edu.jgsu;import org.junit.Test;import org.junit.runner.RunWith;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTests { // 创建记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test public void contextLoads() { // 以下是日志的级别，优先级从低到高， trace &lt; debug &lt; info &lt; warn &lt; error logger.trace(\"这是trace日志...\"); logger.debug(\"这是debug日志...\"); // Spring Boot 默认给我们使用的是 info 级别的，info 级别以下的不输出，没有指定级别的就用 Spring Boot 默认规定的级别；root 级别(就是 info 级别) logger.info(\"这是info日志...\"); logger.warn(\"这是warn日志...\"); logger.error(\"这是error日志...\"); }} 控制台输出的结果如下： 123452020-02-04 22:27:01.312 INFO 22432 --- [ main] edu.jgsu.ApplicationTests : Started ApplicationTests in 4.233 seconds (JVM running for 8.279)2020-02-04 22:27:01.488 INFO 22432 --- [ main] edu.jgsu.ApplicationTests : 这是info日志...2020-02-04 22:27:01.488 WARN 22432 --- [ main] edu.jgsu.ApplicationTests : 这是warn日志...2020-02-04 22:27:01.488 ERROR 22432 --- [ main] edu.jgsu.ApplicationTests : 这是error日志...2020-02-04 22:27:01.501 INFO 22432 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@aba8be: startup date [Tue Feb 04 22:26:57 CST 2020]; root of context hierarchy 现在要改变日志级别，在配置文件中加入下列代码： 1logging.level.edu.jgsu=trace 然后控制台输出的结果就改变了，如下： 12345672020-02-04 22:29:48.232 INFO 2368 --- [ main] edu.jgsu.ApplicationTests : Started ApplicationTests in 3.614 seconds (JVM running for 5.138)2020-02-04 22:29:48.369 TRACE 2368 --- [ main] edu.jgsu.ApplicationTests : 这是trace日志...2020-02-04 22:29:48.369 DEBUG 2368 --- [ main] edu.jgsu.ApplicationTests : 这是debug日志...2020-02-04 22:29:48.370 INFO 2368 --- [ main] edu.jgsu.ApplicationTests : 这是info日志...2020-02-04 22:29:48.370 WARN 2368 --- [ main] edu.jgsu.ApplicationTests : 这是warn日志...2020-02-04 22:29:48.370 ERROR 2368 --- [ main] edu.jgsu.ApplicationTests : 这是error日志...2020-02-04 22:29:48.377 INFO 2368 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@d9b808: startup date [Tue Feb 04 22:29:45 CST 2020]; root of context hierarchy 根据以下代码，可修改 Spring Boot 日志的默认配置： 1234567891011121314# 修改日志级别logging.level.edu.jgsu=trace# 指定完整的路径来保存日志。以下指定了在 C 盘用springboot.log文件来记录日志logging.file=c:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹，使用 spring.log 作为默认文件来记录日志# logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d{yyyy-MM-dd} === [%thread] === %-5level === %logger{50} ==== %msg%n 在这里，我们区分一下 logging.file 和 logging.path ： logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 配置好之后，执行测试类，然后就会在 D 盘生成 springboot.log 文件，里面的日志与格式如下： 12345678910111213141516172020-02-04 === [main] === INFO === edu.jgsu.ApplicationTests ==== Starting ApplicationTests on guoshizhan with PID 1984 (started by guoshizhan in F:\\99-Frameworks\\01-springboot\\003-springboot-logging)2020-02-04 === [main] === DEBUG === edu.jgsu.ApplicationTests ==== Running with Spring Boot v2.0.1.RELEASE, Spring v5.0.5.RELEASE2020-02-04 === [main] === INFO === edu.jgsu.ApplicationTests ==== No active profile set, falling back to default profiles: default2020-02-04 === [main] === INFO === o.s.w.context.support.GenericWebApplicationContext ==== Refreshing org.springframework.web.context.support.GenericWebApplicationContext@2ff096: startup date [Tue Feb 04 22:57:02 CST 2020]; root of context hierarchy2020-02-04 === [main] === INFO === o.s.web.servlet.handler.SimpleUrlHandlerMapping ==== Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2020-02-04 === [main] === INFO === o.s.w.s.m.m.a.RequestMappingHandlerAdapter ==== Looking for @ControllerAdvice: org.springframework.web.context.support.GenericWebApplicationContext@2ff096: startup date [Tue Feb 04 22:57:02 CST 2020]; root of context hierarchy2020-02-04 === [main] === INFO === o.s.w.s.m.m.a.RequestMappingHandlerMapping ==== Mapped \"{[/error]}\" onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2020-02-04 === [main] === INFO === o.s.w.s.m.m.a.RequestMappingHandlerMapping ==== Mapped \"{[/error],produces=[text/html]}\" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2020-02-04 === [main] === INFO === o.s.web.servlet.handler.SimpleUrlHandlerMapping ==== Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2020-02-04 === [main] === INFO === o.s.web.servlet.handler.SimpleUrlHandlerMapping ==== Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2020-02-04 === [main] === INFO === edu.jgsu.ApplicationTests ==== Started ApplicationTests in 3.936 seconds (JVM running for 5.688)2020-02-04 === [main] === TRACE === edu.jgsu.ApplicationTests ==== 这是trace日志...2020-02-04 === [main] === DEBUG === edu.jgsu.ApplicationTests ==== 这是debug日志...2020-02-04 === [main] === INFO === edu.jgsu.ApplicationTests ==== 这是info日志...2020-02-04 === [main] === WARN === edu.jgsu.ApplicationTests ==== 这是warn日志...2020-02-04 === [main] === ERROR === edu.jgsu.ApplicationTests ==== 这是error日志...2020-02-04 === [Thread-2] === INFO === o.s.w.context.support.GenericWebApplicationContext ==== Closing org.springframework.web.context.support.GenericWebApplicationContext@2ff096: startup date [Tue Feb 04 22:57:02 CST 2020]; root of context hierarchy 与 D 盘的 springboot.log 文件里的日志相比，控制台的日志与格式如下： 12345678910111213141516172020-02-04 [main] INFO edu.jgsu.ApplicationTests - Starting ApplicationTests on guoshizhan with PID 1984 (started by guoshizhan in F:\\99-Frameworks\\01-springboot\\003-springboot-logging)2020-02-04 [main] DEBUG edu.jgsu.ApplicationTests - Running with Spring Boot v2.0.1.RELEASE, Spring v5.0.5.RELEASE2020-02-04 [main] INFO edu.jgsu.ApplicationTests - No active profile set, falling back to default profiles: default2020-02-04 [main] INFO o.s.w.context.support.GenericWebApplicationContext - Refreshing org.springframework.web.context.support.GenericWebApplicationContext@2ff096: startup date [Tue Feb 04 22:57:02 CST 2020]; root of context hierarchy2020-02-04 [main] INFO o.s.web.servlet.handler.SimpleUrlHandlerMapping - Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2020-02-04 [main] INFO o.s.w.s.m.m.a.RequestMappingHandlerAdapter - Looking for @ControllerAdvice: org.springframework.web.context.support.GenericWebApplicationContext@2ff096: startup date [Tue Feb 04 22:57:02 CST 2020]; root of context hierarchy2020-02-04 [main] INFO o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped \"{[/error]}\" onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2020-02-04 [main] INFO o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped \"{[/error],produces=[text/html]}\" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2020-02-04 [main] INFO o.s.web.servlet.handler.SimpleUrlHandlerMapping - Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2020-02-04 [main] INFO o.s.web.servlet.handler.SimpleUrlHandlerMapping - Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2020-02-04 [main] INFO edu.jgsu.ApplicationTests - Started ApplicationTests in 3.936 seconds (JVM running for 5.688)2020-02-04 [main] TRACE edu.jgsu.ApplicationTests - 这是trace日志...2020-02-04 [main] DEBUG edu.jgsu.ApplicationTests - 这是debug日志...2020-02-04 [main] INFO edu.jgsu.ApplicationTests - 这是info日志...2020-02-04 [main] WARN edu.jgsu.ApplicationTests - 这是warn日志...2020-02-04 [main] ERROR edu.jgsu.ApplicationTests - 这是error日志...2020-02-04 [Thread-2] INFO o.s.w.context.support.GenericWebApplicationContext - Closing org.springframework.web.context.support.GenericWebApplicationContext@2ff096: startup date [Tue Feb 04 22:57:02 CST 2020]; root of context hierarchy 上面的两种日志格式就是 properties 配置文件中配置的格式。现在来说一下日志格式中那些字符的含义： 12345678910日志输出格式： %d 表示日期时间， %thread 表示线程名， %-5level 级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg 日志消息 %n 是换行符# 举例如下：%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n 使用自定义日志配置文件如何使用自定义的日志文件呢？给类路径下即 resources 下放上每个日志框架自己的配置文件即可，【这个日志配置文件要自己编写，在最后我会提供一份日志配置，仅供参考】Spring Boot 就不使用它自己的默认配置了。但是自定义的日志配置文件的名字必须在下面表格 Customization 中的其中一个。 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties 建议不要用 logback.xml 这个名字，因为 logback.xml 直接就被日志框架识别了，所以无法使用高级功能。建议使用 logback-spring.xml 这个名字，日志框架就不能直接加载日志的配置项，所以就由 Spring Boot 来解析日志配置，从而可以使用 Spring Boot 的高级 Profile 功能。 下面标签里面可以指定某段配置只在某个环境下生效： 123&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt;&lt;/springProfile&gt; 下面代码自定义了开发环境日志格式和非开发环境日志格式： 123456789101112&lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;!-- 开发环境日志格式 --&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} ----&gt; [%thread] ---&gt; %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;!-- 非开发环境日志格式 --&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} ==== [%thread] ==== %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt;&lt;/appender&gt; 如果使用 logback.xml 作为日志配置文件，还要配置使用 Profile 功能，会出现以下错误： 1no applicable action for [springProfile] 切换日志框架 Spring Boot 默认使用的日志框架是 Slf4j + logback ，那么如果我要切换其他的日志框架，那该怎么做呢？可以按照 slf4j 的日志适配图【上一张图片】，进行相关的切换。例如：我们要把原先的 slf4j + logback 切换为 slf4j + log4j 的方式，那该这么做呢？首先，我们根据日志适配图排除不需要的日志依赖，然后新增我们需要的日志依赖： 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为 log4j2 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 到这里，Spring Boot 的日志就结束了，这一章节我感觉后面日志切换有点难，也写的不好，还没有贴代码。后期有时间的话，我会以更好的表达来重新写过。那么，接下来就是 Spring Boot 的重点内容，Spring Boot 与 Web 开发。","link":"/Spring-Boot-01.html"},{"title":"Redis 入门教程","text":"Redis 基本介绍Redis 简介Redis（Remote Dictionary Server ) : 即远程字典服务 ，是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、高性能的 NOSQL 系列的非关系型数据库 ，并提供多种语言的 API 。【———— 百度百科】 那么什么是 NOSQL 呢？ NoSQL(NoSQL = Not Only SQL) 意为：不仅仅是 SQL ，是一项全新的数据库理念，泛指 非关系型数据库 。NOSQL 出现原因： 随着互联网 web2.0 网站的兴起，传统的关系数据库在应付 web2.0 网站，特别是超大规模和高并发的 SNS 类型的 web2.0 纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL 数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 Redis 优缺点NOSQL 和关系型数据库比较，异同点如下所示： 123456789101112131415161718+++ Redis 优点：+ 1）成本：NOSQL 数据库简单易部署，基本都是开源软件，不需要像使用 oracle 那样花费大量成本购买使用，相比关系型数据库价格便宜。+ 2）查询速度：NOSQL 数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及 NOSQL 数据库。+ 3）存储数据的格式：NOSQL 的存储格式是 key=value 形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。+ 4）扩展性：关系型数据库有类似 join 这样的多表查询机制的限制导致扩展很艰难。+ 5）是否区分大小写：Redis 不区分大小写。+ 6）瓶颈：Redis 是单线程的，所以 Redis 的瓶颈不是 CPU ，而是机器内存和网络带宽。+++ Redis 缺点：- 1）维护的工具和资料有限，因为 NOSQL 是属于新的技术，不能和关系型数据库 10 几年的技术同日而语。- 2）不提供对sql的支持，如果不支持 SQL 这样的工业标准，将产生一定用户的学习和使用成本。- 3）不提供关系型数据库对事务的处理。（有些支持，有些不支持）+++ 总结如下：+ 1）关系型数据库与 NoSQL 数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用 NoSQL 的时候使用 NoSQL 数据库。+ 2）让 NoSQL 数据库对关系型数据库的不足进行弥补。+ 3）一般会将数据存储在关系型数据库中，在 NoSQL 数据库中备份存储关系型数据库的数据 Redis 应用场景Redis 是用 C 语言开发的一个开源的 高性能键值对（key-value）数据库 ，官方提供测试数据，50 个并发执行 100000 个请求,读的速度是 110000 次 / s ，写的速度是 81000 次 / s 。 且 Redis 通过提供多种键值数据类型来适应不同场景下的存储需求。目前为止 ， Redis 支持的键值数据类型 如下： Redis 支持的键值数据类型： 1、字符串类型 string 2、哈希类型 hash 3、列表类型 list 4、集合类型 set 5、有序集合类型 sortedset Redis 的应用场景： 1、缓存（数据查询、短连接、新闻内容、商品内容等等） 2、聊天室的在线好友列表 3、任务队列。（秒杀、抢购、12306 等等） 4、应用排行榜 5、网站访问统计 6、数据过期处理（可以精确到毫秒 7、分布式集群架构中的 session 分离 8、发布订阅系统 9、地图信息分析 1234567891011121314151617181920212223242526272829303132+++ 主流的 NOSQL 产品+++ 键值(Key-Value)存储数据库相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对优势： 快速查询劣势： 存储的数据缺少结构化+++ 列存储数据库相关产品：Cassandra, HBase, Riak典型应用：分布式的文件系统数据模型：以列簇式存储，将同一列数据存在一起优势：查找速度快，可扩展性强，更容易进行分布式扩展劣势：功能相对局限+++ 文档型数据库相关产品：CouchDB、MongoDB典型应用：Web应用（与 Key-Value 类似，Value 是结构化的）数据模型： 一系列键值对优势：数据结构要求不严格劣势： 查询性能不高，而且缺乏统一的查询语法+++ 图形(Graph)数据库相关数据库：Neo4J、InfoGrid、Infinite Graph典型应用：社交网络数据模型：图结构优势：利用图结构相关算法。劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 Redis 下载安装 Redis 的下载： 1、Redis 官网下载链接：Redis 官网 【下载的是 Liunx 版本，不是 windows 版本】2、Redis 中文网下载链接：Redis 中文网 【下载的是 Liunx 版本，不是 windows 版本】3、GitHub 下载链接：Redis 的 GitHub 地址 【建议使用，各种版本都有，这个是微软的，不是 Redis 的】4、本博客站点下载：redis-2.8.9.zip 【建议使用，windows 版本的】 下载完成之后，解压即可使用 。解压之后如下图： 那么如何使用 Redis 呢？ 双击打开 redis-server.exe ，如下图： 然后 双击打开 redis-cli.exe 即可使用，如下图： Redis 配置文件详解这个是 windows 下的配置文件【linux 的在 Redis 高级部分】，具体解释如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# 指定 Redis 运行的端口，默认是 6379port 6379# 设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么就关闭该连接。0 代表关闭此设置timeout 0tcp-keepalive 0# 当 Redis 在后台运行的时候，Redis 默认会把 pid 文件放在 /var/run/redis.pid ，你也可以配置到其他地址。当运行多个 Redis 服务时，需要指定不同的 pid 文件和端口pidfile /var/run/redis.pid# 指定日志记录级别。Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice# debug 记录很多信息，用于开发和测试。varbose 有用的信息，不像 debug 会记录那么多。notice 就是普通的 verbose ，常用于生产环境。warning 只有非常重要或者严重的信息会记录到日志loglevel notice# 默认值为 stdout ，标准输出，若后台模式会输出到 /dev/nulllogfile stdout# 代表 Redis 默认有 16 个数据库，默认使用第 0 个数据库。如果需要切换，那就进入到客户端，使用命令：select n （n 代表第 n + 1 个数据库，n 最大为 15 ）databases 16# daemonize no 默认情况下，redis不是在后台运行的，如果需要在后台运行，把该项的值更改为yesdaemonize yessave 900 1save 300 10save 60 10000stop-writes-on-bgsave-error yes# 在启动 redis 时是否显示 logoalways-show-logo yesrdbcompression yesrdbchecksum yesdbfilename dump.rdbdir ./slave-serve-stale-data yesslave-read-only yesrepl-disable-tcp-nodelay noslave-priority 100appendonly noappendfsync everysecno-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mblua-time-limit 5000slowlog-log-slower-than 10000slowlog-max-len 128hash-max-ziplist-entries 512hash-max-ziplist-value 64list-max-ziplist-entries 512list-max-ziplist-value 64set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64activerehashing yesclient-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60hz 10aof-rewrite-incremental-fsync yes 相关操作命令 TIPS： Redis 中文网教程： Redis 教程Redis 的官方文档： Redis 文档 redis 数据结构redis 存储的是 key-value 格式 的数据。其中 key 都是字符串 ，而 value 却有 5 种不同的数据结构 ，如下图： 通用命令通用命令 的相关操作以及截图如下： 12345678910111213141516+++ 通用命令+ keys * 查询所有的键+ type key 获取键对应的 value 的类型- del key 删除指定的 key- flushdb 清空当前数据库- flushall 清空所有数据库- clear 清空屏幕- expire key n 表示 key 在 n 秒后会过期。例如：expire name 10 表示 name 这个键在 10 秒后会过期+ dbsize 查看当前数据库大小+ select 8 切换到第 9 个数据库，n 最大值为 15+ exist key 判断某个键是否存在。例如：exist name 表示判断 name 这个键是否存在+++ 通用命令 字符串类型字符串类型 的常用命令相关操作以及截图如下： 1234567891011121314+++ 字符串类型 string+ 存储： set key value 举例：127.0.0.1:6379&gt; set age 23+ 追加： append key value 举例：127.0.0.1:6379&gt; append age 24+ 获取： get key 举例：127.0.0.1:6379&gt; get age - 删除： del key 举例：127.0.0.1:6379&gt; del age + 长度： strlen key 举例：127.0.0.1:6379&gt; strlen age+ 截取： getrange key start end 举例：127.0.0.1:6379&gt; getrange age 0 -1+ 替换： setrange key index value 举例：127.0.0.1:6379&gt; setrange age 0 G+++ 字符串类型 string 字符串类型 的高级操作，这里只做简单介绍，更多详情介绍请 参阅官网 。高级命令如下： 1234567891011121314151617181920212223242526# setnx 命令： Setnx（SET if Not eXists） 命令在指定的 key 不存在时，为 key 设置指定的值。127.0.0.1:6379&gt; SETNX KEY_NAME VALUE# mset 命令： Mset 命令用于同时设置一个或多个 key-value 对127.0.0.1:6379&gt; MSET key1 value1 key2 value2 .. keyN valueN # setex 命令： Setex 为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。127.0.0.1:6379&gt; SETEX KEY_NAME TIMEOUT VALUE# incr 命令： Incr 命令将 key 中储存的数字值增一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。注意 key 的值必须是 integer 类型的，就是整型127.0.0.1:6379&gt; INCR KEY_NAME# incrby 命令： 对 key 的值自动加 n，类似于 i += n127.0.0.1:6379&gt; INCRBY KEY_NAME INCR_AMOUNT# decr 命令： Decr 命令将 key 中储存的数字值减一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。注意 key 的值必须是 integer 类型的，就是整型127.0.0.1:6379&gt; DECR KEY_NAME # decrby 命令： 将 key 所储存的值减去指定的减量值。意思就是对 key 的值自动加 n，类似于 i += n 。127.0.0.1:6379&gt; DECRBY KEY_NAME DECREMENT_AMOUNT# set 命令存储 json 特殊用法127.0.0.1:6379&gt; set user:1 {name:zhangsan,age:23}# getset 命令： Getset 命令用于设置指定 key 的值，并返回 key 旧的值。127.0.0.1:6379&gt; GETSET KEY_NAME VALUE 哈希类型哈希类型 的相关操作以及截图如下： 1234567+++ 哈希类型 hash+ 存储： hset key field value 举例：127.0.0.1:6379&gt; hset myhash username guo+ 获取： hget key field 举例：127.0.0.1:6379&gt; hget myhash username- 删除： hdel key field 举例：127.0.0.1:6379&gt; hdel myhash username+++ 哈希类型 hash 列表类型列表类型 的相关操作以及截图如下： 1234567891011121314+++ 列表类型 list ：可以添加一个元素到列表的头部（左边）或者尾部（右边）。注意：列表类型里面的元素允许重复+ 向左添加： lpush key value 举例：127.0.0.1:6379&gt; lpush mylist a+ 向右添加： rpush key value 举例：127.0.0.1:6379&gt; rpush mylist c+ 范围获取： lrange key start end 举例：127.0.0.1:6379&gt; lrange mylist 0 -1+ 指定获取： lindex key index 举例：127.0.0.1:6379&gt; lindex mylist 1+ 列表长度： llen key 举例：127.0.0.1:6379&gt; llen mylist+ 列表修剪： ltrim key start stop 举例：127.0.0.1:6379&gt; ltrim mylist 0 1- 向左删除： lpop key 举例：127.0.0.1:6379&gt; lpop mylist- 向右删除： rpop key 举例：127.0.0.1:6379&gt; rpop mylist- 移除元素： lrem key count value 举例：127.0.0.1:6379&gt; lrem mylist 2 Java+++ 列表类型 list 集合类型集合类型 的相关操作以及截图如下： 1234567891011+++ 集合类型 set 注意：集合类型里面的元素不允许重复且不保证顺序+ 添加： sadd key value 举例：127.0.0.1:6379&gt; sadd myset a+ 获取： smembers key 举例：127.0.0.1:6379&gt; smembers myset+ 交集： sinter key1 key2 ...keyn 举例：127.0.0.1:6379&gt; sinter myset myset2+ 并集： sunion key1 key2 ...keyn 举例：127.0.0.1:6379&gt; sunion myset myset2- 删除： srem key value 举例：127.0.0.1:6379&gt; srem myset a- 差集： sdiff key1 key2 ...keyn 举例：127.0.0.1:6379&gt; sdiff myset myset2+++ 集合类型 set 有序集合类型有序集合类型 的相关操作以及截图如下： 12345678+++ 有序集合类型 sortedset 注意：不允许重复元素，且元素有顺序。+++ 每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。+ 添加： zadd key score value 举例：127.0.0.1:6379&gt; zadd mysort 60 Jack+ 获取： zrange key start end [withscores] 举例：127.0.0.1:6379&gt; zrange mysort 0 -1 或者 zrange mysort 0 -1 withscores- 删除： zrem key value 举例：127.0.0.1:6379&gt; zrem mysort Jack+++ 有序集合类型 sortedset Redis 的持久化持久化简介什么是持久化呢？ 因为 Redis 是一个内存数据库，当 Redis 服务器重启或者电脑重启，那么数据就会丢失。这个时候我们就要进行持久化操作，将 Redis 内存中的数据持久化保存到硬盘的文件中。 持久化机制接下来介绍一下 Redis 的持久化机制。Redis 持久化机制有两种：RDB 机制 和 AOF 机制 。具体详情介绍如下： RDB 机制： 这是 Redis 持久化的默认方式，不需要进行配置，默认就使用这种机制。这种机会在一定的间隔时间中，检测 key 的变化情况，然后持久化数据。接下来我们实际操作一下，看一下这种机制如何实现。 第一步： 编辑 Redis 安装目录下的 redis.windwos.conf 配置文件，找到如下内容，然后修改一下配置，把 save 60 10000 注释掉，修改为 save 10 5 。这里的修改只是用于测试，测试完成之后改回原来的数据。修改如下： redis.windwos.conf123456789# after 900 sec (15 min) if at least 1 key changed 中文意思是：15 分钟内，如果有 1 个 key 改变，那么就进行持久化# after 300 sec (5 min) if at least 10 keys changed 中文意思是：5 分钟内，如果有 10 个 key 改变，那么就进行持久化# after 60 sec if at least 10000 keys changed 中文意思是：1 分钟内，如果有 10000 个 key 改变，那么就进行持久化save 900 1save 300 10# save 60 10000# 10 秒内，如果有 5 个 key 改变，那么就进行持久化，即会在 Redis 安装目录生成一个以 rdb 为后缀的文件save 10 5 第二步： 以指定配置文件名称的方式重新启动 Redis 服务器，启动过程如下图： 第三步： 测试 RDB 机制，看是否生成以 rdb 为后缀的持久化文件。过程如下图： 第四步： 以指定配置文件名称的方式重启 Redis 服务器，看里面是否还有数据。如下图： 温馨小提示： 记得把修改了的配置文件修改回去嗷！！！ 接下来，我们介绍 AOF 机制： 日志记录的方式，可以记录每一条命令的操作。可以在每一次命令操作完成之后就持久化数据。那么现在就来操作一波吧！第一步： 编辑 redis.windwos.conf 配置文件，找到 appendonly no （关闭 aof）（在 392 行） ，然后将其修改为 appendonly yes （开启 aof）。修改好后保存。以下配置了解一下，不需要修改： 12345# 以下三行配置在 420 行，对应的功能都写好了# appendfsync always 每一次操作都进行持久化appendfsync everysec # 每隔一秒进行一次持久化# appendfsync no 不进行持久化 第二步： 以指定配置文件名称的方式重新启动 Redis 服务器，启动过程如下图： 第三步： 测试 AOF 机制，看是否生成以 aof 为后缀的持久化文件。过程如下图： 第四步： 以指定配置文件名称的方式重启 Redis 服务器，看里面是否还有数据。如下图： 两种持久化机制不足： RDB 机制： 数据可能无法完全保存，存在一些数据的丢失。AOF 机制： 对性能影响比较严重，耗内存。 Jedis 快速入门Jedis 简介Jedis 是一款 Redis 官方推荐 java 操作 redis 数据库的工具，与 JDBC 很类似 。 使用步骤： 第一步： 下载 jedis 的 jar 包 ，官方下载 或者 本博客下载 第二步： 新建 JavaEE 项目，然后添加 jedis 的 jar 包。 第三步： 启动 redis 服务器 redis-server.exe 。 第四步： 编写 Java 程序对 redis 进行操作。 第五步： 启动 redis 的客户端 redis-cli.exe 进行结果查看。 Jedis 的使用第一步： 新建一个 JavaEE 项目【如果新建 Maven 项目会更简单，只要导入依赖即可】。如下图： 第二步： 启动 redis 服务器。找到自己 redis 安装目录，双击 redis-server.exe 即可启动。如下图： 第三步： 编写 Java 程序对 redis 进行操作。相关代码如下： JedisTest.class12345678910111213141516171819202122232425package jedis;import org.junit.Test;import redis.clients.jedis.Jedis;/** * @Author: guoshizhan * @Create: 2020/7/21 15:39 * @Description: Jedis 测试类 */public class JedisTest { @Test public void jedisTest() { // 1、获取连接。如果使用空参构造，那么默认值就是 \"localhost\",6379 Jedis jedis = new Jedis(\"localhost\", 6379); // 2、进行操作 jedis.set(\"username\", \"guoshizhan\"); // 3、关闭连接 jedis.close(); }} 第四步： 启动 redis 的客户端 redis-cli.exe 进行结果查看。如下图： Jedis 的各种操作 温馨小提示： 1、Jedis 里面的各种方法和 Redis 里面的各种命令是相互对应的，所以操作起来相对简单。2、Jedis 里面也会有一些特殊的方法，这些方法都将在代码里体现。 第一种操作： Jedis 操作 redis 中的字符串类型 。代码如下： 1234567891011121314151617181920212223242526272829303132333435package jedis;import org.junit.Test;import redis.clients.jedis.Jedis;/** * @Author: guoshizhan * @Create: 2020/7/21 15:39 * @Description: Jedis 测试类 */public class JedisTest { @Test public void jedisTest() { // 1、获取连接 Jedis jedis = new Jedis(\"localhost\", 6379); // 2、进行操作 jedis.set(\"username\", \"guoshizhan\"); jedis.set(\"age\", \"22\"); String str = jedis.get(\"age\"); System.out.println(str); // setex() 方法存储可以指定时间过期的 key-value // 以下代码表示把 activeCode:039752 键值对存入 Redis ，30 秒之后过期 jedis.setex(\"activeCode\", 30, \"039752\"); // 3、关闭连接 jedis.close(); }} 代码的执行结果如下图： 第二种操作： Jedis 操作 redis 中的哈希类型 。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243package jedis;import org.junit.Test;import redis.clients.jedis.Jedis;import java.util.Map;import java.util.Set;/** * @Author: guoshizhan * @Create: 2020/7/21 15:39 * @Description: Jedis 测试类 */public class JedisTest { @Test public void jedisTest() { // 1、获取连接 Jedis jedis = new Jedis(\"localhost\", 6379); // 2、进行操作：存储 hash jedis.hset(\"user\", \"username\", \"guoshizhan\"); jedis.hset(\"user\", \"address\", \"HangZhou\"); jedis.hset(\"user\", \"gender\", \"male\"); // 3、获取 hash String username = jedis.hget(\"user\", \"username\"); System.out.println(username); Map&lt;String, String&gt; stringMap = jedis.hgetAll(\"user\"); Set&lt;String&gt; keySet = stringMap.keySet(); for (String key : keySet) { String value = stringMap.get(key); System.out.println(key + \"---\" + value); } // 4、关闭连接 jedis.close(); }} 代码的执行结果如下图： 第三种操作： Jedis 操作 redis 中的列表类型 。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041package jedis;import org.junit.Test;import redis.clients.jedis.Jedis;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/7/21 15:39 * @Description: Jedis 测试类 */public class JedisTest { @Test public void jedisTest() { // 1、获取连接 Jedis jedis = new Jedis(\"localhost\", 6379); // 2、进行操作：存储 list jedis.lpush(\"myList\", \"a\", \"b\", \"c\"); jedis.rpush(\"myList\", \"a\", \"b\", \"c\"); // 3、范围获取 List&lt;String&gt; myList = jedis.lrange(\"myList\", 0, -1); System.out.println(myList); // 4、删除操作 String eleLeft = jedis.lpop(\"myList\"); // 从左边删除 System.out.println(eleLeft); String eleright = jedis.rpop(\"myList\"); // 从右边删除 System.out.println(eleright); System.out.println(jedis.lrange(\"myList\", 0, -1)); // 5、关闭连接 jedis.close(); }} 代码的执行结果如下图： 第四种操作： Jedis 操作 redis 中的集合类型 。代码如下： 12345678910111213141516171819202122232425262728293031package jedis;import org.junit.Test;import redis.clients.jedis.Jedis;import java.util.Set;/** * @Author: guoshizhan * @Create: 2020/7/21 15:39 * @Description: Jedis 测试类 */public class JedisTest { @Test public void jedisTest() { // 1、获取连接 Jedis jedis = new Jedis(\"localhost\", 6379); // 2、进行操作：存储 set ，不重复存储且无序 jedis.sadd(\"mySet\", \"Java\", \"C++\", \"HTML\", \"Java\"); Set&lt;String&gt; mySet = jedis.smembers(\"mySet\"); System.out.println(mySet); // 3、关闭连接 jedis.close(); }} 代码的执行结果如下图： 第五种操作： Jedis 操作 redis 中的有序集合类型 。代码如下： 12345678910111213141516171819202122232425262728293031323334package jedis;import org.junit.Test;import redis.clients.jedis.Jedis;import java.util.Set;/** * @Author: guoshizhan * @Create: 2020/7/21 15:39 * @Description: Jedis 测试类 */public class JedisTest { @Test public void jedisTest() { // 1、获取连接 Jedis jedis = new Jedis(\"localhost\", 6379); // 2、进行操作：存储 set ，不重复存储且无序 jedis.zadd(\"sortedSet\", 9, \"典韦\"); jedis.zadd(\"sortedSet\", 7, \"亚瑟\"); jedis.zadd(\"sortedSet\", 5, \"白起\"); Set&lt;String&gt; sortedSet = jedis.zrange(\"sortedSet\", 0, -1); System.out.println(sortedSet); // 3、关闭连接 jedis.close(); }} 代码的执行结果如下图： Jedis 连接池Jedis 有直连方式，所谓直连指的是 Jedis 每次都会新建 TCP 连接，使用后再断开连接，对于频繁访问 Redis 的场景显然不是高效的使用方式。因此， Jedis 连接池 JedisPool 诞生了。 当我们需要连接 Redis 时，只需要向 JedisPool 池子中借，用完了再归还给 JedisPool 池子即可。 使用步骤： 第一步： 下载 jedis 的 jar 包 ，把 commons-pool2-2.3.jar 加入到项目的 lib 文件夹中。jar 包下载： 本博客下载 第二步： 编写相关代码：1、创建 JedisPool 连接池对象；2、调用方法 getResource() 方法获取 Jedis 连接。 第三步： 查看结果。 第一步 的操作如下图： 第二步 的具体代码如下： 12345678910111213141516171819202122232425262728293031package jedis;import org.junit.Test;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;/** * @Author: guoshizhan * @Create: 2020/7/21 15:39 * @Description: Jedis 测试类 */public class JedisTest { @Test public void jedisPoolTest() { // 1、创建 Jedis 连接池对象 JedisPool jedisPool = new JedisPool(); // 2、获取连接 Jedis jedis = jedisPool.getResource(); // 3、进行使用 jedis.set(\"jedisPool\", \"jedisPool\"); // 4、关闭，就是把 jedis 对象归还到 jedisPool 连接池中 jedis.close(); }} 代码的执行结果如下图： Jedis 连接池工具类感觉 使用 Jedis 连接池创建对象比较麻烦，那我们就来写一个 Jedis 连接池工具类吧！开始撸码 ing …… 第一步： 在 src 目录 下新建 utils 包 和 jedis 配置文件 jedis.properties 。如下图： 第二步： 编写 Jedis 配置文件 jedis.properties 和 Jedis 连接池工具类 JedisPoolUtils 。配置文件代码如下： jedis.properties1234567891011# 主机地址，可以是服务器地址，也可以是本地host=127.0.0.1# 端口号port=6379# 最大连接数maxTotal=50# 最大空闲连接数maxIdle=10 Jedis 连接池工具类代码如下： JedisPoolUtils.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package utils;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import java.io.IOException;import java.io.InputStream;import java.util.Properties;/** * @Author: guoshizhan * @Create: 2020/7/21 22:02 * @Description: Jedis 连接池工具类，用于加载连接池的配置文件，降低程序的耦合性 */public class JedisPoolUtils { private static JedisPool jedisPool; /** * 定义静态代码块，当这个类一加载，它就去读取连接池的配置文件 */ static { // 1、读取配置文件 InputStream inputStream = JedisPoolUtils.class.getClassLoader().getResourceAsStream(\"jedis.properties\"); // 2、创建 properties 对象 Properties properties = new Properties(); // 3、关联连接池配置文件 try { properties.load(inputStream); } catch (IOException e) { e.printStackTrace(); } // 4、获取数据，设置到 JedisPoolConfig 中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(properties.getProperty(\"maxTotal\"))); config.setMaxIdle(Integer.parseInt(properties.getProperty(\"maxIdle\"))); // 5、初始化 jedisPool jedisPool = new JedisPool(config, properties.getProperty(\"host\"), Integer.parseInt(properties.getProperty(\"port\"))); } /** * 获取连接的方法 */ public static Jedis getJedis() { return jedisPool.getResource(); }} 第三步： 编写测试类代码。具体代码如下： 12345678910111213141516171819202122232425262728package jedis;import org.junit.Test;import redis.clients.jedis.Jedis;import utils.JedisPoolUtils;/** * @Author: guoshizhan * @Create: 2020/7/21 15:39 * @Description: Jedis 测试类 */public class JedisTest { @Test public void jedisPoolTest() { // 1、jedis 连接池工具类的使用 Jedis jedis = JedisPoolUtils.getJedis(); // 2、进行操作 jedis.set(\"jedisPoolUtils\", \"jedisPoolUtils\"); // 3、关闭，就是把 jedis 对象归还到连接池中 jedis.close(); }} 第四步： 查看测试结果。如下图： 附赠：jedis 的详细配置一览： 12345678910111213141516171819202122# 最大活动对象数 redis.pool.maxTotal=1000 # 最大能够保持idel状态的对象数 redis.pool.maxIdle=100 # 最小能够保持idel状态的对象数 redis.pool.minIdle=50 # 当池内没有返回对象时，最大等待时间 redis.pool.maxWaitMillis=10000 # 当调用borrow Object方法时，是否进行有效性检查 redis.pool.testOnBorrow=true # 当调用return Object方法时，是否进行有效性检查 redis.pool.testOnReturn=true # “空闲链接”检测线程，检测的周期，毫秒数。如果为负值，表示不运行“检测线程”。默认为-1. redis.pool.timeBetweenEvictionRunsMillis=30000 # 向调用者输出“链接”对象时，是否检测它的空闲超时； redis.pool.testWhileIdle=true # 对于“空闲链接”检测线程而言，每次检测的链接资源的个数。默认为3. redis.pool.numTestsPerEvictionRun=50 # redis 服务器的 IP redis.ip=xxxxxx # redis 服务器的 Port redis1.port=6379 Redis 案例案例准备 案例需求： 提供 index.html 页面，页面中有一个省份【下拉列表】。当页面加载完成后，发送 ajax 请求，加载所有省份。本案例所用资源下载： 案例资源下载（包含了代码部分） 第一步： 新建数据库和数据表。代码如下： 1234567891011121314CREATE DATABASE RedisTest; -- 创建数据库USE RedisTest; -- 使用数据库CREATE TABLE province( -- 创建表 id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) NOT NULL );-- 插入数据INSERT INTO province VALUES(NULL,'北京');INSERT INTO province VALUES(NULL,'上海');INSERT INTO province VALUES(NULL,'广州');INSERT INTO province VALUES(NULL,'陕西'); 第二步： 添加各种 jar 包到 lib 文件夹下【案例资源上面已经给了】。添加之后如下图： 第三步： 添加数据库配置文件 druid.properties 到 src 目录下，并完善包结构。如下图： 第四步： 导入 js 文件到 web 目录下。如图所示： 第五步： 在 utils 包 下新建 JDBCUtils 和 JedisPoolUtils 两个工具类。对应代码如下： utils/JDBCUtils.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package utils;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;/** * JDBC工具类：使用 Durid 连接池 */public class JDBCUtils { private static DataSource ds ; static { try { // 1、加载配置文件 Properties properties = new Properties(); // 使用 ClassLoader 加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\"); properties.load(is); // 2、初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(properties); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接池对象 */ public static DataSource getDataSource(){ return ds; } /** * 获取连接 Connection 对象 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); }} utils/JedisPoolUtils.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package utils;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import java.io.IOException;import java.io.InputStream;import java.util.Properties;/** * @Author: guoshizhan * @Create: 2020/7/21 22:02 * @Description: Jedis 连接池工具类，用于加载连接池的配置文件，降低程序的耦合性 */public class JedisPoolUtils { private static JedisPool jedisPool; /** * 定义静态代码块，当这个类一加载，它就去读取连接池的配置文件 */ static { // 1、读取配置文件 InputStream inputStream = JedisPoolUtils.class.getClassLoader().getResourceAsStream(\"jedis.properties\"); // 2、创建 properties 对象 Properties properties = new Properties(); // 3、关联连接池配置文件 try { properties.load(inputStream); } catch (IOException e) { e.printStackTrace(); } // 4、获取数据，设置到 JedisPoolConfig 中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(properties.getProperty(\"maxTotal\"))); config.setMaxIdle(Integer.parseInt(properties.getProperty(\"maxIdle\"))); // 5、初始化 jedisPool jedisPool = new JedisPool(config, properties.getProperty(\"host\"), Integer.parseInt(properties.getProperty(\"port\"))); } /** * 获取连接的方法 */ public static Jedis getJedis() { return jedisPool.getResource(); }} 案例编码 第一步： 在 domain 包 下新建一个 Province 类 ，和数据库 province 表相对应。代码如下： domain/Province.java1234567891011121314151617181920212223242526272829package domain;/** * @Author: guoshizhan * @Create: 2020/7/21 23:33 * @Description: Province实体类 */public class Province { private int id; private String name; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; }} 第二步： 在 dao 包 下新建一个 ProvinceDao 接口 ，定义相关操作方法。代码如下： dao/ProvinceDao.java1234567891011121314151617package dao;import domain.Province;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/7/21 23:35 * @Description: ProvinceDao 接口 */public interface ProvinceDao { // 查询所有省份 public List&lt;Province&gt; findAll();} 然后在 dao/impl 包 下新建 ProvinceDaoImpl 实现类 ，用于实现 ProvinceDao 接口。代码如下： dao/impl/ProvinceDaoImpl.java12345678910111213141516171819202122232425262728293031323334package dao.impl;import dao.ProvinceDao;import domain.Province;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import utils.JDBCUtils;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/7/21 23:38 * @Description: ProvinceDao 的实现类 */public class ProvinceDaoImpl implements ProvinceDao { private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); @Override public List&lt;Province&gt; findAll() { // 1、定义查询所有的 sql String sql = \"select * from province\"; // 2、执行 sql List&lt;Province&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;&gt;(Province.class)); // 3、返回 list 集合 return list; }} 第三步： 在 service 包 下新建一个 ProvinceService 接口 ，定义相关操作方法。代码如下： service/ProvinceService.java1234567891011121314151617181920package service;import domain.Province;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/7/21 23:40 * @Description: ProvinceService */public interface ProvinceService { // 查询所有，与 Redis 无关 public List&lt;Province&gt; findAll(); // 使用 Redis 会用到这个方法 public String findAllJson();} 然后在 service/impl 包 下新建 ProvinceServiceImpl 实现类 ，用于实现 ProvinceService 接口。代码如下： service/impl/ProvinceServiceImpl.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package service.impl;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import dao.ProvinceDao;import dao.impl.ProvinceDaoImpl;import domain.Province;import redis.clients.jedis.Jedis;import service.ProvinceService;import utils.JedisPoolUtils;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/7/21 23:40 * @Description: ProvinceService 实现类 */public class ProvinceServiceImpl implements ProvinceService { private ProvinceDao dao = new ProvinceDaoImpl(); @Override public List&lt;Province&gt; findAll() { return dao.findAll(); } /** * 使用 Redis 作为缓存 * @return 返回字符串类型 */ @Override public String findAllJson() { // 1、获取连接 Jedis jedis = JedisPoolUtils.getJedis(); String province_json = jedis.get(\"province\"); // 2、判断 province_json 是否为 null if (province_json == null || province_json.length() == 0) { System.out.println(\"Redis 中没有数据，正在查询数据库……\"); List&lt;Province&gt; list = dao.findAll(); ObjectMapper mapper = new ObjectMapper(); try { province_json = mapper.writeValueAsString(list); } catch (JsonProcessingException e) { e.printStackTrace(); } jedis.set(\"province\", province_json); jedis.close(); } else { System.out.println(\"Redis 中有数据，正在查询缓存……\"); } // 3、返回数据 return province_json; }} 第四步： 在 web/servlet 包 下新建一个 ProvinceServlet 类 ，用于 Ajax 请求和页面数据展示 。代码如下： web/servlet/ProvinceServlet.java12345678910111213141516171819202122232425262728293031323334353637383940414243package web.servlet;import com.fasterxml.jackson.databind.ObjectMapper;import domain.Province;import service.ProvinceService;import service.impl.ProvinceServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;/** * @Author: guoshizhan * @Create: 2020/7/21 23:56 * @Description: Servlet */@WebServlet(\"/provinceServlet\")public class ProvinceServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1、调用 service 查询 ProvinceService service = new ProvinceServiceImpl(); List&lt;Province&gt; list = service.findAll(); // 2、序列化 list 为 json 数据 ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(list); // 3、响应结果 System.out.println(json); response.setContentType(\"application/json;charset=utf-8\"); response.getWriter().write(json); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); }} 接着在 web 目录下新建 index.html 页面，代码如下： web/index.html1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"js/jquery-3.3.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () { // 发送 ajax 请求，加载所有省份数据 $.get(\"provinceServlet\", {}, function (data) { // 1、获取 select var province = $(\"#province\"); // 2、遍历 json 数组 $(data).each(function () { // 3、创建 &lt;option&gt; var option = \"&lt;option name='\" + this.id + \"'&gt;\" + this.name + \"&lt;/option&gt;\"; // 4、调用 select 的 append 追加 option province.append(option); }); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;select id=\"province\"&gt; &lt;option&gt;---请选择省份---&lt;/option&gt; &lt;/select&gt; &lt;/body&gt;&lt;/html&gt; 第五步： 启动 tomcat 查看结果。如下图： 使用 Redis 作为缓存使用 Redis 可以减少数据库的交互，从而提高了效率。那么该如何操作呢？ 第一步： 使用以下代码覆盖原先的 ProvinceServlet 类 。代码如下： 123456789101112131415161718192021222324252627282930313233343536package web.servlet;import service.ProvinceService;import service.impl.ProvinceServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Author: guoshizhan * @Create: 2020/7/21 23:56 * @Description: Servlet */@WebServlet(\"/provinceServlet\")public class ProvinceServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1、调用 service 查询，这部分是与 Redis 相关的代码 ProvinceService service = new ProvinceServiceImpl(); String json = service.findAllJson(); // 2、响应结果 System.out.println(json); response.setContentType(\"application/json;charset=utf-8\"); response.getWriter().write(json); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); }} 第二步： 启动 tomcat ，查看测试结果。如下图： TIPS： 到此为止，Redis 入门教程就结束了。接着往下看 Redis 进阶教程。 Redis 进阶Redis 在 Linux 下的安装Redis 官方 更推荐我们在 Linux 下使用 Redis ，而不是在 windows 系统下，这样才更符合企业级的开发。现在就来介绍 Redis 在 Linux 下的安装。 第一步： 下载 Redis 的 Linux 版本。 下载地址 如下图： 当然，也可以 使用命令下载 。如下： 12345# 01-如果没有安装 wget ，那就使用下列命令安装。如果安装了，可跳过这一步yum install wget# 02-下载 redis-6.0.6.tar.gz 压缩包。下面的这条命令官方有wget http://download.redis.io/releases/redis-6.0.6.tar.gz 第二步： 解压 Redis 压缩包。【如果下载在 windows 系统了，还需要把压缩包上传到 Liunx 云服务器或者是虚拟机，这个自行解决，不难】解压缩的命令和结果如下图： 第三步： 编译 Redis 。 需要用到如下命令： 1234567891011121314151617# 01-安装 gcc 环境，如果安装过，可跳到 03 步骤【凡是涉及到安装的，都需要网络，没网络就完成不了了】yum install gcc-c++# 02-检查 gcc 是否安装成功以及查看版本gcc -v# 03-进入到刚刚解压出来的目录cd redis-5.0.4# 04-使用 make 命令编译。需要点时间，大概 1~2 分钟make# 05-进入到 src 目录cd src# 06-执行安装make install TIPS： 在 make 命令执行完后 ， redis-5.0.4 目录下会出现编译后的 redis 服务程序 redis-server 和用于测试的客户端程序 redis-cli ，两个程序位于 redis-5.0.4/src 目录下。 第四步： 启动 Redis【不是后台启动，需要使用 CTRL + C 才能停止服务】。 需要用到如下命令： 12345# 01-进入到 src 目录cd src# 02-启动 Redis 服务端./redis-server ../redis.conf 第五步： 配置后台启动，并存一个数据。 需要用到如下命令： 1234567891011# 01-编辑配置文件vi redis.conf# 02-找到 daemonize ，把它的值改为 yes ，然后保存退出daemonize yes# 03-启动 Redis 服务端./redis-server ../redis.conf# 04-启动 Redis 客户端./redis-cli -p 6379 对应的截图如下： 第六步： 查看 Redis 进程和关闭 Redis 。 需要用到如下命令： 12345678# 01-查看 Redis 进程ps -ef|grep redis# 02-关闭 Redis 进程，不明白就看下列图片shutdown# 03-退出 Redis ，不明白就看下列图片exit Redis 性能测试redis-benchmark 是一个官方自带的 性能测试工具 ，与 redis-server 一样，都位于 Redis 的安装目录 src 下 。如下图： 这个性能测试工具有一些可选参数【来源于：菜鸟教程】 ，如下图： 那么我们如何使用这个测试工具呢？我们又该如何使用这些可选参数呢？使用命令如下： 1234567# 01-进入到 Redis-server 所在目录，启动 Redis 服务端./redis-server ../redis.conf# 02-使用 redis-benchmark 测试 100 个并发连接 10 万个请求./redis-benchmark -h localhost -p 6379 -c 100 -n 100000# 03-如果还需要测试其他参数，请自行按照上述样式进行测试即可，这里就不作过多的测试了 测试结果以及对结果的分析如下图： 三种特殊数据类型geospatial-地理位置有没有想过，微信定位，附近的人，打车距离计算等功能 是如何实现的？用 geospatial 就可以实现。这种数据类型是 根据经纬度计算两地之间的距离 【直线距离，两个极点除外】 。 那我们该如何去使用呢？先查询好经纬度：经纬度查询 ，然后进行各种操作。如下图： 小提示： 我们至少需要两个点才能进行操作。越多越好。以下是我准备的几个城市的经纬度： 1234567891011+++ 准备好的城市经纬度+ 北京： 经度： 116.23128 纬度： 40.22077+ 上海： 经度： 121.48941 纬度： 31.40527+ 佛山： 经度： 112.89262 纬度： 22.90026+ 广州： 经度： 113.27324 纬度： 23.15792+ 深圳： 经度： 113.88308 纬度： 22.55329+ 成都： 经度： 104.10194 纬度： 30.65984+ 重庆： 经度： 106.54041 纬度： 29.40268+++ 准备好的城市经纬度 有了上述的经纬度之后，我们就可以使用命令进行操作了。 其实手动添加数据是真的烦，如果要添加 1000 个城市甚至更多，那我们岂不是要累死了。所以，我们可以自己通过写 Java 程序，去读取一个相关的配置文件，然后把多个城市或者全国的城市的坐标添加进去。【这个就自己实现了哈！！！】接下来开始命令操作吧！！！ GEOADD官方介绍： GEOADD 命令 将指定的地理空间位置 （经度、纬度、名称） 添加到指定的 key 中。这些数据将会存储到 sorted set【所以 geospatial 它的底层就是有序集合】。这样的目的是为了方便使用 GEORADIUS 或者 GEORADIUSBYMEMBER 命令对数据进行半径查询等操作。 注意事项： 1、有效的经度 从 -180 度到 180 度 。2、有效的纬度 从 -85.05112878 度到 85.05112878 度 。【所以两个极点是没有坐标的】3、当坐标位置超出上述指定范围时，该命令将会返回一个错误。 1234567891011+++ 使用 GEOADD 命令添加地理位置+ 127.0.0.1:6379&gt; geoadd ChinaCity 116.23 40.22 BeiJing+ 127.0.0.1:6379&gt; geoadd ChinaCity 121.48 31.41 ShangHai+ 127.0.0.1:6379&gt; geoadd ChinaCity 112.89 22.90 FoShan+ 127.0.0.1:6379&gt; geoadd ChinaCity 113.27 23.15 GuangZhou+ 127.0.0.1:6379&gt; geoadd ChinaCity 113.88 22.55 ShenZhen+ 127.0.0.1:6379&gt; geoadd ChinaCity 104.10 30.66 ChengDu+ 127.0.0.1:6379&gt; geoadd ChinaCity 106.54 29.40 ChongQing+++ 使用 GEOADD 命令添加地理位置 到这为止，添加操作完成了。【 GEOADD 命令 是不是挺简单的，哈哈】如下图： GEOPOS官方介绍： GEOPOS 命令 从 key 里返回所有给定位置元素的位置（经度和纬度）。返回值： GEOPOS 命令 返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。当给定的位置元素不存在时， 对应的数组项为空值。 123456+++ GEOPOS 获取位置命令+ 127.0.0.1:6379&gt; geopos ChinaCity BeiJing+ 127.0.0.1:6379&gt; geopos ChinaCity ShangHai FoShan+++ GEOPOS 获取位置命令 到这为止，获取操作完成了。【 GEOPOS 命令 是不是也挺简单的，哈哈】如下图： GEODIST官方介绍： GEODIST 命令 返回两个给定位置之间的距离。如果两个位置之间的其中一个不存在， 那么命令返回空值。指定的单位如下： 123456789+++ 指定单位的参数 unit 必须是以下单位的其中一个：+ m 表示单位为米。+ km 表示单位为千米。+ mi 表示单位为英里。+ ft 表示单位为英尺。+++ 如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位。+++ GEODIST 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这一假设最大会造成 0.5% 的误差。 GEODIST 命令 的具体操作如下图： GEORADIUSGEORADIUS 命令 以给定的经纬度为中心， 返回与中心的距离不超过给定最大距离的所有的位置元素 。详细介绍如下： 1234567891011121314151617+++ 范围可以使用以下其中一个单位：+ m 表示单位为米。+ km 表示单位为千米。+ mi 表示单位为英里。+ ft 表示单位为英尺。+++ 在给定以下可选项时， 命令会返回额外的信息：+ WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。+ WITHCOORD: 将位置元素的经度和维度也一并返回。+ WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。+++ 命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：+ ASC: 根据中心的位置， 按照 从近到远 的方式返回位置元素。+ DESC: 根据中心的位置， 按照 从远到近 的方式返回位置元素。+++ 该命令可以用于查找附近的人，通过半径查询，即圆形搜索。Over！！！ 在默认情况下， GEORADIUS 命令 会返回所有匹配的位置元素 。 虽然用户可以使用 COUNT 选项去获取前 N 个匹配元素， 但是因为命令在内部可能会需要对所有被匹配的元素进行处理， 所以在对一个非常大的区域进行搜索时， 即使只使用 COUNT 选项去获取少量元素， 命令的执行速度也可能会非常慢。 但是从另一方面来说， 使用 COUNT 选项去减少需要返回的元素数量， 对于减少带宽来说仍然是非常有用的 。 123456789+++ GEORADIUS+ 127.0.0.1:6379&gt; georadius ChinaCity 110 30 1000 km+ 127.0.0.1:6379&gt; georadius ChinaCity 110 30 1000 km withdist+ 127.0.0.1:6379&gt; georadius ChinaCity 110 30 1000 km withcoord+ 127.0.0.1:6379&gt; georadius ChinaCity 110 30 1000 km count 1+ 127.0.0.1:6379&gt; georadius ChinaCity 110 30 1000 km count 2+++ GEORADIUS 命令 上述命令对应的结果如下图： GEORADIUSBYMEMBERGEORADIUSBYMEMBER 命令 和 GEORADIUS 命令 一样， 都可以找出位于指定范围内的元素 。 但是 GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点。简而言之，GEORADIUSBYMEMBER 命令 就是指定成员的位置被用作查询的中心。 123456+++ GEORADIUSBYMEMBER 命令+ 127.0.0.1:6379&gt; georadiusbymember ChinaCity FoShan 1000 km+ 127.0.0.1:6379&gt; georadiusbymember ChinaCity FoShan 100 km+++ GEORADIUSBYMEMBER 命令 命令操作及结果如下图： GEOHASHGEOHASH 命令 返回一个或多个位置元素的 Geohash 表示 。【了解一下】 特别提示在 GEOADD 命令 中有这么一句话： 这些数据将会存储到 sorted set ，由此可知，geospatial 类型的底层是 sorted set ，所以我们可以使用有序集合的命令来操作 geospatial 类型 。具体操作如下图： HyperLogLog 类型官方介绍： HyperLogLog 是用来做基数统计的算法，它的的优点是：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 那么问题来了，什么是基数？ 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为 5 。 基数估计就是在误差可接受的范围内，快速计算基数。 12345678910+++ HyperLogLog 应用场景+ 1、网站用户访问量（一个用户访问多次，但还是算作一个人）+ 2、统计注册 IP 数+ 3、统计每日访问 IP 数+ 4、统计页面实时 UV 数+ 5、统计在线用户数+ 6、统计用户每天搜索不同词条的个数+++ HyperLogLog 应用场景 HyperLogLog 类型 的命令只有三个，比较少。具体介绍如下： 1234567+++ HyperLogLog 类型相关命令+ PFADD key element [element ...] 添加指定元素到 HyperLogLog 中。+ PFCOUNT key [key ...] 返回给定 HyperLogLog 的基数估算值。+ PFMERGE destkey sourcekey [sourcekey ...] 将多个 HyperLogLog 合并为一个 HyperLogLog+++ HyperLogLog 类型相关命令 TIPS： 如果允许容错，那么统计功能的实现建议使用 HyperLogLog 类型。 Bitmaps 位图Bitmaps 的底层是 字符串类型，所以它的命令是在 字符串类型命令 里面。其各种命令如下： 1234567+++ Bitmaps 命令+ SETBIT KEY_NAME OFFSET VALUE ： Setbit 命令用于对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。+ GETBIT KEY_NAME OFFSET ： Getbit 命令用于对 key 所储存的字符串值，获取指定偏移量上的位(bit)。+ BITCOUNT KEY [start end] ： Bitcount 命令用于获取 Bitmaps 指定范围值为 1 的个数。+++ Bitmaps 命令 1234567891011121314+++ Bitmaps 命令举例+ 127.0.0.1:6379&gt; setbit sign 1 0+ 127.0.0.1:6379&gt; setbit sign 2 1+ 127.0.0.1:6379&gt; setbit sign 3 0+ 127.0.0.1:6379&gt; setbit sign 4 1+ 127.0.0.1:6379&gt; setbit sign 5 0+ 127.0.0.1:6379&gt; setbit sign 6 1+ 127.0.0.1:6379&gt; setbit sign 7 0+ 127.0.0.1:6379&gt; getbit sign 4+ 127.0.0.1:6379&gt; bitcount sign+++ Bitmaps 命令举例 Redis 事务Redis 事务介绍Redis 事务本质 是一组命令的集合！事务支持一次执行多个命令，一个事务中所有命令都会被序列化。 在事务执行过程中，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总结地说： Redis 事务就是 一次性、顺序性、排他性 的执行一个队列中的一系列命令。 Redis 事务没有隔离级别的概念： 批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。 Redis 不保证原子性： 单个 Redis 命令的执行是原子性的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。也就是说， Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。 1234567+++ Redis 事务的三个阶段【从开始到执行】+ 开始事务【multi】+ 命令入队【……】+ 执行事务【exec】+++ Redis 事务的三个阶段【从开始到执行】 Redis 事务相关命令123456789+++ Redis 事务相关命令+ multi : 标记一个事务块的开始（ queued ）+ exec : 执行所有事务块的命令（ 一旦执行 exec 后，之前加的监控锁都会被取消掉 ） - discard : 取消事务，放弃事务块中的所有命令+ watch key1 key2 ... : 监视一或多个 key ，如果在事务执行之前，被监视的 key 被其他命令改动，则事务被打断 （ 类似乐观锁 ）- unwatch : 取消 watch 对所有 key 的监控+++ Redis 事务相关命令 编译型异常： 这个会导致提交失败。失败原因：命令错误或者语法错误。 如下图： 运行时异常： 事务提交能够成功。具体原因详见下方 TIPS 。如下图： TIPS： 事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚 ，也不会造成后续的指令不做。 Redis 实现乐观锁乐观锁： 顾名思义，总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁。 但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。 悲观锁： 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。 传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java 中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。 两种锁的使用场景： 从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。 Redis 监视测试， 相关命令如下： 1234567891011+++ Redis 监视测试+ 127.0.0.1:6379&gt; set money 1000+ 127.0.0.1:6379&gt; set spend 0+ 127.0.0.1:6379&gt; watch money+ 127.0.0.1:6379&gt; multi- 127.0.0.1:6379&gt; decrby money 200+ 127.0.0.1:6379&gt; incrby spend 200+ 127.0.0.1:6379&gt; exec+++ Redis 监视测试 在这种单线程的操作下，结果没有出现问题【等会我们开多个线程，结果就不一样了，哈哈】。 如下图： 接下来，我们需要再开启一条线程，即线程二。如下图： 此时，我们的 watch 命令 就充当了 Redis 的乐观锁 操作。最终结果是线程一的事务提交失败。 结果如下图： 那么我们该如何来解决这个问题嘞？ 首先： 如果发现事务提交失败，那么就先解除监控。第二： 既然修改失败，那就获取最新的值再次进行监控。最后： 执行相应的操作。 请看下图： Spring Boot 整合 RedisSpring Boot 是未来的主流，所以使用它 集成 Redis 是非常有必要的。接下来就逐步介绍集成过程及其使用。【这部分的代码都安排好了，点击右侧即可下载： 代码资源下载】 第一步： 创建 Spring Boot 项目。【这个就自行创建，这里不过多介绍了】 接着我们导入依赖如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;!--netty--&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-test&lt;/artifactId&gt; &lt;version&gt;2.2.9.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 注意事项： 1、在 Spring Boot 2.x 之后，原来使用的 Jedis 被替换成了 lettuce 。2、Jedis 采用直连方式连接，多个线程操作是不安全的。如需避免这种问题，就需要使用 Jedis 连接池技术。【类似 BIO 模式】3、lettuce 的底层采用 netty ，实例可以在多个线程中共享，所以不存在线程安全问题了。【类似 BIO 模式】 第二步： 编写我们的 application.properties 配置文件。 代码如下： 12345678# 由于当时 8080 端口被占用，所以就把端口设置为了 8082server.port=8082# 设置 Redis 的主机spring.redis.host=127.0.0.1# 设置 Redis 的端口号spring.redis.port=6379 第三步： 编写我们的单元测试代码，并进行测试。 代码和测试结果如下： 123456789101112131415161718192021222324252627282930313233343536373839package club.guoshizhan;import org.junit.jupiter.api.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.test.context.junit4.SpringRunner;import javax.annotation.Resource;/** * @Author: guoshizhan * @Create: 2020/7/31 15:38 * @Description: 测试类 */@RunWith(SpringRunner.class)@SpringBootTestclass MyRedisApplicationTest { @Autowired private RedisTemplate redisTemplate; @Test void contextLoads() { /** * RedisTemplate 模板的相关介绍 * 1、opsForValue 用于操作 String * 2、opsForList 用于操作 List * 3、opsForset 用于操作 Set * …… */ redisTemplate.opsForValue().set(\"Language\", \"Java\"); System.out.println(redisTemplate.opsForValue().get(\"Language\")); }} Redis 的测试结果 如下： 自定义 redisTemplate由上图可知，我们存储的键乱码了。为什么呢？这个是序列化的问题。 先看下图： 那我们如何来解决这个问题呢？ 这个时候我们需要 自定义 redisTemplate ，这样便可解决序列化问题。先按下图把对应的包和类创建好，然后再开始编写我们自定义的类。 如下图： 接着我们在 guoshizhan 包下新建 entity 包，然后在 entity 包里新建 User 实体类。【还未实现序列化】 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package club.guoshizhan.entity;import org.springframework.stereotype.Component;/** * @Author: guoshizhan * @Create: 2020/7/31 22:56 * @Description: User 实体类 */@Componentpublic class User { private String name; private int age; private String address; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public User(String name, int age, String address) { this.name = name; this.age = age; this.address = address; } public User() { } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", address='\" + address + '\\'' + '}'; }} 此时我们去编写一个测试方法，把这个方法放到 MyRedisApplicationTest 类 中。 代码如下： 12345678@Testpublic void testUser() { // 开发中一般使用 json 来传递对象 User user = new User(\"Java\", 25, \"China\"); String jsonUser = new ObjectMapper().writeValueAsString(user); redisTemplate.opsForValue().set(\"user\", jsonUser); System.out.println(redisTemplate.opsForValue().get(\"user\"));} 测试结果以及 后续的一点儿小改动 如下图： 到这里为止，我们控制台输出的信息是不会乱码的，但是我们的 Redis 客户端却会出现乱码 。因为我们还使用的是系统默认的序列化方式，我们还没有自定义我们的 redisTemplate 。 所以，我们现在就来自定义我们的 redisTemplate 吧！！！ 第一步： 编写我们的 RedisConfig 类。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package club.guoshizhan.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import java.net.UnknownHostException;/** * @Author: guoshizhan * @Create: 2020/7/31 17:29 * @Description: Redis 配置类 */@Configurationpublic class RedisConfig { // 编写我们自己的 redisTemplate 【代码来源于：RedisAutoConfiguration 类】 @Bean @SuppressWarnings(\"all\") public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) throws UnknownHostException { RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(factory); // 连接工厂 Jackson2JsonRedisSerializer serializer = new Jackson2JsonRedisSerializer(Object.class); // json 序列化配置 ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); serializer.setObjectMapper(objectMapper); StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // String 的序列化 template.setKeySerializer(stringRedisSerializer); // key 采用 string 的序列化方式 template.setHashKeySerializer(stringRedisSerializer); // hash 的 key 采用 String 的序列化方式 template.setValueSerializer(serializer); // value 序列化方式采用 jackson template.setHashValueSerializer(serializer); // hash 的 value 序列化方式采用 jackson template.afterPropertiesSet(); return template; }} 第二步： 编写我们的 MyRedisApplicationTest 类。 代码如下： 123456789101112131415161718192021222324252627282930313233package club.guoshizhan;import club.guoshizhan.entity.User;import org.junit.jupiter.api.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.test.context.junit4.SpringRunner;/** * @Author: guoshizhan * @Create: 2020/7/31 15:38 * @Description: 测试类 */@RunWith(SpringRunner.class)@SpringBootTestclass MyRedisApplicationTest { @Autowired @Qualifier(\"redisTemplate\") // 指定到我们自己编写的 redisTemplate private RedisTemplate redisTemplate; @Test public void testUser() { // 开发中一般使用 json 来传递对象 User user = new User(\"Java\", 25, \"China\"); redisTemplate.opsForValue().set(\"user\", user); System.out.println(redisTemplate.opsForValue().get(\"user\")); }} 第三步： 点击测试方法进行测试 结果如下图： 自定义 Redis 工具类我们发现 使用系统默认的命令来操作 Redis 比较麻烦，我们想要自己定义一个 Redis 工具类来方便我们的操作。安排！！！ 第一步： 我们在 guoshizhan 包下新建 utils 包，然后在 utils 包里新建 RedisUtils 工具类。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574package club.guoshizhan.utils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;/** * @Author: guoshizhan * @Create: 2020/8/1 0:08 * @Description: 自定义 Redis 工具类 */@Componentpublic class RedisUtils { @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; @Autowired private StringRedisTemplate stringRedisTemplate; /** * 指定缓存失效时间 * * @param key 键 * @param time 时间(秒) * @return */ public boolean expire(String key, long time) { try { if (time &gt; 0) { redisTemplate.expire(key, time, TimeUnit.SECONDS); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 根据key 获取过期时间 * * @param key 键 不能为null * @return 时间(秒) 返回0代表为永久有效 */ public long getExpire(String key) { return redisTemplate.getExpire(key, TimeUnit.SECONDS); } /** * 判断key是否存在 * * @param key 键 * @return true 存在 false不存在 */ public boolean hasKey(String key) { try { return redisTemplate.hasKey(key); } catch (Exception e) { e.printStackTrace(); return false; } } /** * 删除缓存 * * @param key 可以传一个值 或多个 */ @SuppressWarnings(\"unchecked\") public void del(String... key) { if (key != null &amp;&amp; key.length &gt; 0) { if (key.length == 1) { redisTemplate.delete(key[0]); } else { redisTemplate.delete(CollectionUtils.arrayToList(key)); } } } // ============================String============================= /** * 普通缓存获取 * * @param key 键 * @return 值 */ public Object get(String key) { return key == null ? null : redisTemplate.opsForValue().get(key); } /** * 普通缓存放入 * * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key, Object value) { try { redisTemplate.opsForValue().set(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 普通缓存放入并设置时间 * * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean set(String key, Object value, long time) { try { if (time &gt; 0) { redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); } else { set(key, value); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 递增 * * @param key 键 * @return */ public long incr(String key, long delta) { if (delta &lt; 0) { throw new RuntimeException(\"递增因子必须大于0\"); } return redisTemplate.opsForValue().increment(key, delta); } /** * 递减 * * @param key 键 * @return */ public long decr(String key, long delta) { if (delta &lt; 0) { throw new RuntimeException(\"递减因子必须大于0\"); } return redisTemplate.opsForValue().increment(key, -delta); } // ================================Map================================= /** * HashGet * * @param key 键 不能为null * @param item 项 不能为null * @return 值 */ public Object hget(String key, String item) { return redisTemplate.opsForHash().get(key, item); } /** * 获取hashKey对应的所有键值 * * @param key 键 * @return 对应的多个键值 */ public Map&lt;Object, Object&gt; hmget(String key) { return redisTemplate.opsForHash().entries(key); } /** * HashSet * * @param key 键 * @param map 对应多个键值 * @return true 成功 false 失败 */ public boolean hmset(String key, Map&lt;String, Object&gt; map) { try { redisTemplate.opsForHash().putAll(key, map); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * HashSet 并设置时间 * * @param key 键 * @param map 对应多个键值 * @param time 时间(秒) * @return true成功 false失败 */ public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) { try { redisTemplate.opsForHash().putAll(key, map); if (time &gt; 0) { expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 向一张hash表中放入数据,如果不存在将创建 * * @param key 键 * @param item 项 * @param value 值 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value) { try { redisTemplate.opsForHash().put(key, item, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 向一张hash表中放入数据,如果不存在将创建 * * @param key 键 * @param item 项 * @param value 值 * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value, long time) { try { redisTemplate.opsForHash().put(key, item, value); if (time &gt; 0) { expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 删除hash表中的值 * * @param key 键 不能为null * @param item 项 可以使多个 不能为null */ public void hdel(String key, Object... item) { redisTemplate.opsForHash().delete(key, item); } /** * 判断hash表中是否有该项的值 * * @param key 键 不能为null * @param item 项 不能为null * @return true 存在 false不存在 */ public boolean hHasKey(String key, String item) { return redisTemplate.opsForHash().hasKey(key, item); } /** * hash递增 如果不存在,就会创建一个 并把新增后的值返回 * * @param key 键 * @param item 项 * @param by 要增加几(大于0) * @return */ public double hincr(String key, String item, double by) { return redisTemplate.opsForHash().increment(key, item, by); } /** * hash递减 * * @param key 键 * @param item 项 * @param by 要减少记(小于0) * @return */ public double hdecr(String key, String item, double by) { return redisTemplate.opsForHash().increment(key, item, -by); } // ============================set============================= /** * 根据key获取Set中的所有值 * * @param key 键 * @return */ public Set&lt;Object&gt; sGet(String key) { try { return redisTemplate.opsForSet().members(key); } catch (Exception e) { e.printStackTrace(); return null; } } /** * 根据value从一个set中查询,是否存在 * * @param key 键 * @param value 值 * @return true 存在 false不存在 */ public boolean sHasKey(String key, Object value) { try { return redisTemplate.opsForSet().isMember(key, value); } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将数据放入set缓存 * * @param key 键 * @param values 值 可以是多个 * @return 成功个数 */ public long sSet(String key, Object... values) { try { return redisTemplate.opsForSet().add(key, values); } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 将set数据放入缓存 * * @param key 键 * @param time 时间(秒) * @param values 值 可以是多个 * @return 成功个数 */ public long sSetAndTime(String key, long time, Object... values) { try { Long count = redisTemplate.opsForSet().add(key, values); if (time &gt; 0) { expire(key, time); } return count; } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 获取set缓存的长度 * * @param key 键 * @return */ public long sGetSetSize(String key) { try { return redisTemplate.opsForSet().size(key); } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 移除值为value的 * * @param key 键 * @param values 值 可以是多个 * @return 移除的个数 */ public long setRemove(String key, Object... values) { try { Long count = redisTemplate.opsForSet().remove(key, values); return count; } catch (Exception e) { e.printStackTrace(); return 0; } } // ===============================list================================= /** * 获取list缓存的内容 * * @param key 键 * @param start 开始 * @param end 结束 0 到 -1代表所有值 * @return */ public List&lt;Object&gt; lGet(String key, long start, long end) { try { return redisTemplate.opsForList().range(key, start, end); } catch (Exception e) { e.printStackTrace(); return null; } } /** * 获取list缓存的长度 * * @param key 键 * @return */ public long lGetListSize(String key) { try { return redisTemplate.opsForList().size(key); } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 通过索引 获取list中的值 * * @param key 键 * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推 * @return */ public Object lGetIndex(String key, long index) { try { return redisTemplate.opsForList().index(key, index); } catch (Exception e) { e.printStackTrace(); return null; } } /** * 将list放入缓存 * * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, Object value) { try { redisTemplate.opsForList().rightPush(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, Object value, long time) { try { redisTemplate.opsForList().rightPush(key, value); if (time &gt; 0) { expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将list放入缓存 * * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, List&lt;Object&gt; value) { try { redisTemplate.opsForList().rightPushAll(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, List&lt;Object&gt; value, long time) { try { redisTemplate.opsForList().rightPushAll(key, value); if (time &gt; 0) { expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 根据索引修改list中的某条数据 * * @param key 键 * @param index 索引 * @param value 值 * @return */ public boolean lUpdateIndex(String key, long index, Object value) { try { redisTemplate.opsForList().set(key, index, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 移除N个值为value * * @param key 键 * @param count 移除多少个 * @param value 值 * @return 移除的个数 */ public long lRemove(String key, long count, Object value) { try { Long remove = redisTemplate.opsForList().remove(key, count, value); return remove; } catch (Exception e) { e.printStackTrace(); return 0; } }} 第二步： 编写我们的 MyRedisApplicationTest 类。 代码如下： 12345678910111213141516171819202122232425262728package club.guoshizhan;import club.guoshizhan.utils.RedisUtils;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;/** * @Author: guoshizhan * @Create: 2020/7/31 15:38 * @Description: 测试类 */@RunWith(SpringRunner.class)@SpringBootTestpublic class MyRedisApplicationTest { @Autowired private RedisUtils redisUtils; @Test public void redisUtilsTest() { redisUtils.set(\"name\", \"Java\"); System.out.println(redisUtils.get(\"name\")); }} 第三步： 点击测试方法进行测试。 结果如下图： Redis 高级Redis 配置文件详解内存配置： 当需要配置内存大小时，可以使用 1k, 5GB, 4M 等类似的格式进行配置。 其转换方式如下 【不区分大小写】 ： 1234567891011# Note on units: when memory size is needed, it is possible to specify# it in the usual form of 1k 5GB 4M and so forth:## 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## units are case insensitive so 1GB 1Gb 1gB are all the same.（对大小写不敏感） 文件引入： 引入其他的配置文件【做集群需要多个配置文件，这个时候此处就有用处了】。 具体配置如下： 1234567891011121314151617################################## INCLUDES #################################### Include one or more other config files here. This is useful if you# have a standard template that goes to all Redis servers but also need# to customize a few per-server settings. Include files can include# other files, so use this wisely.## Notice option \"include\" won't be rewritten by command \"CONFIG REWRITE\"# from admin or Redis Sentinel. Since Redis always uses the last processed# line as value of a configuration directive, you'd better put includes# at the beginning of this file to avoid overwriting config change at runtime.## If instead you are interested in using includes to override configuration# options, it is better to use include as the last line.## include /path/to/local.conf# include /path/to/other.conf 模块加载： Redis 启动时加载哪些模块。 配置如下： 1234567################################## MODULES ###################################### Load modules at startup. If the server is not able to load modules# it will abort. It is possible to use multiple loadmodule directives.## loadmodule /path/to/my_module.so# loadmodule /path/to/other_module.so 网络配置： 配置 Redis 的主机、端口等等。。常用配置如下： 1234567891011121314151617181920212223# 指定 Redis 只能接受来自此 IP 绑定的网卡的请求，注意此默认值默认外网是不可访问的bind 127.0.0.1# 是否开启保护模式。如果没有指定 bind 和密码，Redis 只会本地进行访问，拒绝外部访问。protected-mode yes# 默认端口，建议生产环境不要使用默认端口避免被恶意扫描到port 6379# TCP 连接中已完成队列(完成三次握手之后)的长度tcp-backlog 511# 配置 unix socket 来让 Redis 支持监听本地连接。【此项默认是被注释掉了的，只因介绍从而把它放开】unixsocket /tmp/redis.sock# 配置 unix socket 使用文件的权限。【此项默认是被注释掉了的，只因介绍从而把它放开】unixsocketperm 700# 客户端连接空闲超过 timeout 将会被断开，为 0 则断开timeout 0# 配置 tcp keepalive 参数tcp-keepalive 300 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485################################## NETWORK ###################################### By default, if no \"bind\" configuration directive is specified, Redis listens# for connections from all the network interfaces available on the server.# It is possible to listen to just one or multiple selected interfaces using# the \"bind\" configuration directive, followed by one or more IP addresses.## Examples:## bind 192.168.1.100 10.0.0.1# bind 127.0.0.1 ::1## ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the# internet, binding to all the interfaces is dangerous and will expose the# instance to everybody on the internet. So by default we uncomment the# following bind directive, that will force Redis to listen only into# the IPv4 loopback interface address (this means Redis will be able to# accept connections only from clients running into the same computer it# is running).## IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES# JUST COMMENT THE FOLLOWING LINE.# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bind 127.0.0.1# Protected mode is a layer of security protection, in order to avoid that# Redis instances left open on the internet are accessed and exploited.## When protected mode is on and if:## 1) The server is not binding explicitly to a set of addresses using the# \"bind\" directive.# 2) No password is configured.## The server only accepts connections from clients connecting from the# IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain# sockets.## By default protected mode is enabled. You should disable it only if# you are sure you want clients from other hosts to connect to Redis# even if no authentication is configured, nor a specific set of interfaces# are explicitly listed using the \"bind\" directive.protected-mode yes# Accept connections on the specified port, default is 6379 (IANA #815344).# If port 0 is specified Redis will not listen on a TCP socket.port 6379# TCP listen() backlog.## In high requests-per-second environments you need an high backlog in order# to avoid slow clients connections issues. Note that the Linux kernel# will silently truncate it to the value of /proc/sys/net/core/somaxconn so# make sure to raise both the value of somaxconn and tcp_max_syn_backlog# in order to get the desired effect.tcp-backlog 511# Unix socket.## Specify the path for the Unix socket that will be used to listen for# incoming connections. There is no default, so Redis will not listen# on a unix socket when not specified.## unixsocket /tmp/redis.sock# unixsocketperm 700# Close the connection after a client is idle for N seconds (0 to disable)timeout 0# TCP keepalive.## If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence# of communication. This is useful for two reasons:## 1) Detect dead peers.# 2) Take the connection alive from the point of view of network# equipment in the middle.## On Linux, the specified value (in seconds) is the period used to send ACKs.# Note that to close the connection the double of the time is needed.# On other kernels the period depends on the kernel configuration.## A reasonable value for this option is 300 seconds, which is the new# Redis default starting with Redis 3.2.1.tcp-keepalive 300 通用配置： 这个是我们基本的配置项。能配置后台启动、日志级别等等。 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839# 是否后台启动，默认是 no ，我们需要自己把它该为 yesdaemonize no# 可以通过 upstart 和 systemd 来管理 Redis 的守护进程。选项如下：# supervised no - 没有监督互动# supervised upstart - 通过将 Redis 置于 SIGSTOP 式来启动信号# supervised systemd - signal systemd 将 READY = 1 写入 $ NOTIFY_SOCKET# supervised auto - 检测 upstart 或 systemd 方法基于 UPSTART_JOB 或 NOTIFY_SOCKET 环境变量supervised no# 如果以后台的方式运行 Redis ，我们需要指定一个 PID 文件pidfile /var/run/redis_6379.pid# 配置日志级别，默认是 notice 。参数如下：# debug# verbose# notice# warningloglevel notice# 配置日志文件的位置，就是把日志输出到哪一个文件logfile \"\"# 是否打开记录 syslog 功能【此项默认是被注释掉了的，只因介绍从而把它放开】syslog-enabled no# syslog 标识符。【此项默认是被注释掉了的，只因介绍从而把它放开】syslog-ident redis# 配置日志的来源。【此项默认是被注释掉了的，只因介绍从而把它放开】syslog-facility local0# 数据库的数量，默认值为 16 。默认使用的数据库是 DB 0，数据库范围在 0 -（database-1）之间# 可以通过 SELECT 命令选择一个 db# 集群环境默认只有 DB 0databases 16# 是否一直显示 logo ，就是启动 Redis 数据库有无那个立方体的图形显示always-show-logo yes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263################################# GENERAL ###################################### By default Redis does not run as a daemon. Use 'yes' if you need it.# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.daemonize yes# If you run Redis from upstart or systemd, Redis can interact with your# supervision tree. Options:# supervised no - no supervision interaction# supervised upstart - signal upstart by putting Redis into SIGSTOP mode# supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET# supervised auto - detect upstart or systemd method based on# UPSTART_JOB or NOTIFY_SOCKET environment variables# Note: these supervision methods only signal \"process is ready.\"# They do not enable continuous liveness pings back to your supervisor.supervised no# If a pid file is specified, Redis writes it where specified at startup# and removes it at exit.## When the server runs non daemonized, no pid file is created if none is# specified in the configuration. When the server is daemonized, the pid file# is used even if not specified, defaulting to \"/var/run/redis.pid\".## Creating a pid file is best effort: if Redis is not able to create it# nothing bad happens, the server will start and run normally.pidfile /var/run/redis_6379.pid# Specify the server verbosity level.# This can be one of:# debug (a lot of information, useful for development/testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably)# warning (only very important / critical messages are logged)loglevel notice# Specify the log file name. Also the empty string can be used to force# Redis to log on the standard output. Note that if you use standard# output for logging but daemonize, logs will be sent to /dev/nulllogfile \"\"# To enable logging to the system logger, just set 'syslog-enabled' to yes,# and optionally update the other syslog parameters to suit your needs.# syslog-enabled no# Specify the syslog identity.# syslog-ident redis# Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.# syslog-facility local0# Set the number of databases. The default database is DB 0, you can select# a different one on a per-connection basis using SELECT &lt;dbid&gt; where# dbid is a number between 0 and 'databases'-1databases 16# By default Redis shows an ASCII art logo only when started to log to the# standard output and if the standard output is a TTY. Basically this means# that normally a logo is displayed only in interactive sessions.## However it is possible to force the pre-4.0 behavior and always show a# ASCII art logo in startup logs by setting the following option to yes.always-show-logo yes 快照配置： 与 Redis 的数据持久化 RDB 有关。【一定时间内执行了多少次，则会持久化到文件】 配置如下： 1234567891011121314151617181920212223# 保存数据到磁盘 【RDB 方式】 :# after 900 sec (15 min) if at least 1 key changed 【15 分钟（900 秒）内至少有一个 key 发生变化就保存数据到磁盘】# after 300 sec (5 min) if at least 10 keys changed 【5 分钟（300 秒）至少有 10 个 key 发生变化就保存数据到磁盘】# after 60 sec if at least 10000 keys changed 【1 分钟（60 秒）至少有 10000 个 key 发生变化就保存数据到磁盘】save 900 1save 300 10save 60 10000# 持久化出现错误后，是否依然进行继续进行工作stop-writes-on-bgsave-error yes# 存储至本地数据库时（持久化到 rdb 文件）是否压缩数据【这需要消耗一些 CPU 资源】，默认为 yesrdbcompression yes# 是否开启RC64校验，默认是 yesrdbchecksum yes# rdb 文件名称dbfilename dump.rdb# rdb 使用上面的 dbfilename 配置指令的文件名保存到这个目录dir ./ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768################################ SNAPSHOTTING ################################## Save the DB on disk:## save &lt;seconds&gt; &lt;changes&gt;## Will save the DB if both the given number of seconds and the given# number of write operations against the DB occurred.## In the example below the behaviour will be to save:# after 900 sec (15 min) if at least 1 key changed# after 300 sec (5 min) if at least 10 keys changed# after 60 sec if at least 10000 keys changed## Note: you can disable saving completely by commenting out all \"save\" lines.## It is also possible to remove all the previously configured save# points by adding a save directive with a single empty string argument# like in the following example:## save \"\"save 900 1save 300 10save 60 10000# By default Redis will stop accepting writes if RDB snapshots are enabled# (at least one save point) and the latest background save failed.# This will make the user aware (in a hard way) that data is not persisting# on disk properly, otherwise chances are that no one will notice and some# disaster will happen.## If the background saving process will start working again Redis will# automatically allow writes again.## However if you have setup your proper monitoring of the Redis server# and persistence, you may want to disable this feature so that Redis will# continue to work as usual even if there are problems with disk,# permissions, and so forth.stop-writes-on-bgsave-error yes# Compress string objects using LZF when dump .rdb databases?# For default that's set to 'yes' as it's almost always a win.# If you want to save some CPU in the saving child set it to 'no' but# the dataset will likely be bigger if you have compressible values or keys.rdbcompression yes# Since version 5 of RDB a CRC64 checksum is placed at the end of the file.# This makes the format more resistant to corruption but there is a performance# hit to pay (around 10%) when saving and loading RDB files, so you can disable it# for maximum performances.## RDB files created with checksum disabled have a checksum of zero that will# tell the loading code to skip the check.rdbchecksum yes# The filename where to dump the DBdbfilename dump.rdb# The working directory.## The DB will be written inside this directory, with the filename specified# above using the 'dbfilename' configuration directive.## The Append Only File will also be created inside this directory.## Note that you must specify a directory here, not a file name.dir ./ 主从复制： 主从复制配置。 配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 指定主节点。旧版本是：slaveof 。【此项默认是被注释掉了的，只因介绍从而把它放开】replicaof# master 的密码。【此项默认是被注释掉了的，只因介绍从而把它放开】masterauth# 当一个 slave 失去和 master 的连接，或者同步正在进行中，slave 的行为有两种可能：# 如果 replica-serve-stale-data 设置为 “yes” (默认值)，slave 会继续响应客户端请求，可能是正常数据，也可能是还没获得值的空数据。# 如果 replica-serve-stale-data 设置为 “no” ，slave 会回复\"正在从 master 同步（SYNC with master in progress）\" 来处理各种请求，除了 INFO 和 SLAVEOF 命令。replica-serve-stale-data yes# 配置从是否为只读，开启后从则不能写入数据，旧版本是：slave-read-only yesreplica-read-only yes# 同步策略: 磁盘或 socket，默认磁盘方式repl-diskless-sync no# 如果非磁盘同步方式开启，可以配置同步延迟时间，以等待 master 产生子进程通过 socket 传输 RDB 数据给 slave 。# 默认值为 5 秒，设置为 0 秒则每次传输无延迟。repl-diskless-sync-delay 5# slave 根据指定的时间间隔向 master 发送 ping 请求。默认 10 秒。【此项默认是被注释掉了的，只因介绍从而把它放开】repl-ping-replica-period 10# 同步的超时时间：slave 在与 master SYNC 期间有大量数据传输，造成超时# 在 slave 角度，master 超时，包括数据、ping 等# 在 master 角度，slave 超时，当 master 发送 REPLCONF ACK pings ，确保这个值大于指定的 repl-ping-slave-period ，否则在主从间流量不高时每次都会检测到超时repl-timeout 60# 是否在 slave 套接字发送 SYNC 之后禁用 TCP_NODELAY# 如果选择 yes，Redis 将使用更少的 TCP 包和带宽来向 slaves 发送数据。但是这将使数据传输到 slave 上有延迟，Linux 内核的默认配置会达到 40 毫秒。# 如果选择 no ，数据传输到 salve 的延迟将会减少但要使用更多的带宽。# 默认我们会为低延迟做优化，但高流量情况或主从之间的跳数过多时，可以设置为 “yes” 。repl-disable-tcp-nodelay no# 设置数据备份的 backlog 大小。同步的超时时间repl-backlog-size 1mb# 从最后一个 slave 断开开始计时多少秒后，backlog 缓冲将会释放。同步的超时时间repl-backlog-ttl 3600# 优先级replica-priority 100# 如果 master 少于 N 个延时小于等于M秒的已连接slave，就可以停止接收写操作。N 个 slave 需要是 “oneline” 状态。# 延时是以秒为单位，并且必须小于等于指定值，是从最后一个从slave接收到的ping（通常每秒发送）开始计数。# 该选项不保证N个slave正确同步写操作，但是限制数据丢失的窗口期。# 例如至少需要3个延时小于等于10秒的slave用下面的指令：【此项默认是被注释掉了的，只因介绍从而把它放开】min-replicas-to-write 3min-replicas-max-lag 10 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228################################# REPLICATION ################################## Master-Replica replication. Use replicaof to make a Redis instance a copy of# another Redis server. A few things to understand ASAP about Redis replication.## +------------------+ +---------------+# | Master | ---&gt; | Replica |# | (receive writes) | | (exact copy) |# +------------------+ +---------------+## 1) Redis replication is asynchronous, but you can configure a master to# stop accepting writes if it appears to be not connected with at least# a given number of replicas.# 2) Redis replicas are able to perform a partial resynchronization with the# master if the replication link is lost for a relatively small amount of# time. You may want to configure the replication backlog size (see the next# sections of this file) with a sensible value depending on your needs.# 3) Replication is automatic and does not need user intervention. After a# network partition replicas automatically try to reconnect to masters# and resynchronize with them.## replicaof &lt;masterip&gt; &lt;masterport&gt;# If the master is password protected (using the \"requirepass\" configuration# directive below) it is possible to tell the replica to authenticate before# starting the replication synchronization process, otherwise the master will# refuse the replica request.## masterauth &lt;master-password&gt;# When a replica loses its connection with the master, or when the replication# is still in progress, the replica can act in two different ways:## 1) if replica-serve-stale-data is set to 'yes' (the default) the replica will# still reply to client requests, possibly with out of date data, or the# data set may just be empty if this is the first synchronization.## 2) if replica-serve-stale-data is set to 'no' the replica will reply with# an error \"SYNC with master in progress\" to all the kind of commands# but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,# SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,# COMMAND, POST, HOST: and LATENCY.#replica-serve-stale-data yes# You can configure a replica instance to accept writes or not. Writing against# a replica instance may be useful to store some ephemeral data (because data# written on a replica will be easily deleted after resync with the master) but# may also cause problems if clients are writing to it because of a# misconfiguration.## Since Redis 2.6 by default replicas are read-only.## Note: read only replicas are not designed to be exposed to untrusted clients# on the internet. It's just a protection layer against misuse of the instance.# Still a read only replica exports by default all the administrative commands# such as CONFIG, DEBUG, and so forth. To a limited extent you can improve# security of read only replicas using 'rename-command' to shadow all the# administrative / dangerous commands.replica-read-only yes# Replication SYNC strategy: disk or socket.## -------------------------------------------------------# WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY# -------------------------------------------------------## New replicas and reconnecting replicas that are not able to continue the replication# process just receiving differences, need to do what is called a \"full# synchronization\". An RDB file is transmitted from the master to the replicas.# The transmission can happen in two different ways:## 1) Disk-backed: The Redis master creates a new process that writes the RDB# file on disk. Later the file is transferred by the parent# process to the replicas incrementally.# 2) Diskless: The Redis master creates a new process that directly writes the# RDB file to replica sockets, without touching the disk at all.## With disk-backed replication, while the RDB file is generated, more replicas# can be queued and served with the RDB file as soon as the current child producing# the RDB file finishes its work. With diskless replication instead once# the transfer starts, new replicas arriving will be queued and a new transfer# will start when the current one terminates.## When diskless replication is used, the master waits a configurable amount of# time (in seconds) before starting the transfer in the hope that multiple replicas# will arrive and the transfer can be parallelized.## With slow disks and fast (large bandwidth) networks, diskless replication# works better.repl-diskless-sync no# When diskless replication is enabled, it is possible to configure the delay# the server waits in order to spawn the child that transfers the RDB via socket# to the replicas.## This is important since once the transfer starts, it is not possible to serve# new replicas arriving, that will be queued for the next RDB transfer, so the server# waits a delay in order to let more replicas arrive.## The delay is specified in seconds, and by default is 5 seconds. To disable# it entirely just set it to 0 seconds and the transfer will start ASAP.repl-diskless-sync-delay 5# Replicas send PINGs to server in a predefined interval. It's possible to change# this interval with the repl_ping_replica_period option. The default value is 10# seconds.## repl-ping-replica-period 10# The following option sets the replication timeout for:## 1) Bulk transfer I/O during SYNC, from the point of view of replica.# 2) Master timeout from the point of view of replicas (data, pings).# 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).## It is important to make sure that this value is greater than the value# specified for repl-ping-replica-period otherwise a timeout will be detected# every time there is low traffic between the master and the replica.## repl-timeout 60# Disable TCP_NODELAY on the replica socket after SYNC?## If you select \"yes\" Redis will use a smaller number of TCP packets and# less bandwidth to send data to replicas. But this can add a delay for# the data to appear on the replica side, up to 40 milliseconds with# Linux kernels using a default configuration.## If you select \"no\" the delay for data to appear on the replica side will# be reduced but more bandwidth will be used for replication.## By default we optimize for low latency, but in very high traffic conditions# or when the master and replicas are many hops away, turning this to \"yes\" may# be a good idea.repl-disable-tcp-nodelay no# Set the replication backlog size. The backlog is a buffer that accumulates# replica data when replicas are disconnected for some time, so that when a replica# wants to reconnect again, often a full resync is not needed, but a partial# resync is enough, just passing the portion of data the replica missed while# disconnected.## The bigger the replication backlog, the longer the time the replica can be# disconnected and later be able to perform a partial resynchronization.## The backlog is only allocated once there is at least a replica connected.## repl-backlog-size 1mb# After a master has no longer connected replicas for some time, the backlog# will be freed. The following option configures the amount of seconds that# need to elapse, starting from the time the last replica disconnected, for# the backlog buffer to be freed.## Note that replicas never free the backlog for timeout, since they may be# promoted to masters later, and should be able to correctly \"partially# resynchronize\" with the replicas: hence they should always accumulate backlog.## A value of 0 means to never release the backlog.## repl-backlog-ttl 3600# The replica priority is an integer number published by Redis in the INFO output.# It is used by Redis Sentinel in order to select a replica to promote into a# master if the master is no longer working correctly.## A replica with a low priority number is considered better for promotion, so# for instance if there are three replicas with priority 10, 100, 25 Sentinel will# pick the one with priority 10, that is the lowest.## However a special priority of 0 marks the replica as not able to perform the# role of master, so a replica with priority of 0 will never be selected by# Redis Sentinel for promotion.## By default the priority is 100.replica-priority 100# It is possible for a master to stop accepting writes if there are less than# N replicas connected, having a lag less or equal than M seconds.## The N replicas need to be in \"online\" state.## The lag in seconds, that must be &lt;= the specified value, is calculated from# the last ping received from the replica, that is usually sent every second.## This option does not GUARANTEE that N replicas will accept the write, but# will limit the window of exposure for lost writes in case not enough replicas# are available, to the specified number of seconds.## For example to require at least 3 replicas with a lag &lt;= 10 seconds use:## min-replicas-to-write 3# min-replicas-max-lag 10## Setting one or the other to 0 disables the feature.## By default min-replicas-to-write is set to 0 (feature disabled) and# min-replicas-max-lag is set to 10.# A Redis master is able to list the address and port of the attached# replicas in different ways. For example the \"INFO replication\" section# offers this information, which is used, among other tools, by# Redis Sentinel in order to discover replica instances.# Another place where this info is available is in the output of the# \"ROLE\" command of a master.## The listed IP and address normally reported by a replica is obtained# in the following way:## IP: The address is auto detected by checking the peer address# of the socket used by the replica to connect with the master.## Port: The port is communicated by the replica during the replication# handshake, and is normally the port that the replica is using to# listen for connections.## However when port forwarding or Network Address Translation (NAT) is# used, the replica may be actually reachable via different IP and port# pairs. The following two options can be used by a replica in order to# report to its master a specific set of IP and port, so that both INFO# and ROLE will report those values.## There is no need to use both the options if you need to override just# the port or the IP address.## replica-announce-ip 5.5.5.5# replica-announce-port 1234 安全设置： 可在此处设置 Redis 的密码。配置如下： 1234567891011121314151617# 设置密码。举个例子： requirepass 123456 。【此项默认是被注释掉了的，只因介绍从而把它放开】requirepass foobared#命令重命名。设置命令为空时禁用命令。【此项默认是被注释掉了的，只因介绍从而把它放开】rename-command CONFIG \"\"# 在 Redis 客户端查看是否有密码以及设置密码等# 查看是否有密码config get requirepass# 设置密码config set requirepass \"123456\"# 登陆验证密码auth 123456 123456789101112131415161718192021222324252627282930313233################################## SECURITY #################################### Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other# commands. This might be useful in environments in which you do not trust# others with access to the host running redis-server.## This should stay commented out for backward compatibility and because most# people do not need auth (e.g. they run their own servers).## Warning: since Redis is pretty fast an outside user can try up to# 150k passwords per second against a good box. This means that you should# use a very strong password otherwise it will be very easy to break.## requirepass foobared# Command renaming.## It is possible to change the name of dangerous commands in a shared# environment. For instance the CONFIG command may be renamed into something# hard to guess so that it will still be available for internal-use tools# but not available for general clients.## Example:## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52## It is also possible to completely kill a command by renaming it into# an empty string:## rename-command CONFIG \"\"## Please note that changing the name of commands that are logged into the# AOF file or transmitted to replicas may cause problems. 客户端设置： 设置能同时连接到 Redis 的最大客户端的数量。 配置如下： 123456789101112################################### CLIENTS ##################################### Set the max number of connected clients at the same time. By default# this limit is set to 10000 clients, however if the Redis server is not# able to configure the process file limit to allow for the specified limit# the max number of allowed clients is set to the current file limit# minus 32 (as Redis reserves a few file descriptors for internal uses).## Once the limit is reached Redis will close all the new connections sending# an error 'max number of clients reached'.# 设置能同时连接到 Redis 的最大客户端的数量# maxclients 10000 内存限制： * * 12345678910111213141516# 内存限制：能够配置最大内存容量【此项默认是被注释掉了的，只因介绍从而把它放开】maxmemory &lt;bytes&gt;# 如果达到上方最大的内存限制，Redis 如何选择删除 key# volatile-lru -&gt; 根据 LRU 算法删除设置过期时间的 key# allkeys-lru -&gt; 根据 LRU 算法删除任何 key# volatile-random -&gt; 随机移除设置过过期时间的 key# allkeys-random -&gt; 随机移除任何 key# volatile-ttl -&gt; 移除即将过期的 key(minor TTL)# noeviction -&gt; 不移除任何 key，只返回一个写错误# 注意：对所有策略来说，如果 Redis 找不到合适的可以删除的 key 都会在写操作时返回一个错误。# 目前为止涉及的命令：set setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby getset mset msetnx exec sortmaxmemory-policy noeviction# LRU 和最小 TTL 算法的样本个数【此项默认是被注释掉了的，只因介绍从而把它放开】maxmemory-samples 5 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788############################## MEMORY MANAGEMENT ################################# Set a memory usage limit to the specified amount of bytes.# When the memory limit is reached Redis will try to remove keys# according to the eviction policy selected (see maxmemory-policy).## If Redis can't remove keys according to the policy, or if the policy is# set to 'noeviction', Redis will start to reply with errors to commands# that would use more memory, like SET, LPUSH, and so on, and will continue# to reply to read-only commands like GET.## This option is usually useful when using Redis as an LRU or LFU cache, or to# set a hard memory limit for an instance (using the 'noeviction' policy).## WARNING: If you have replicas attached to an instance with maxmemory on,# the size of the output buffers needed to feed the replicas are subtracted# from the used memory count, so that network problems / resyncs will# not trigger a loop where keys are evicted, and in turn the output# buffer of replicas is full with DELs of keys evicted triggering the deletion# of more keys, and so forth until the database is completely emptied.## In short... if you have replicas attached it is suggested that you set a lower# limit for maxmemory so that there is some free RAM on the system for replica# output buffers (but this is not needed if the policy is 'noeviction').## maxmemory &lt;bytes&gt;# MAXMEMORY POLICY: how Redis will select what to remove when maxmemory# is reached. You can select among five behaviors:## volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.# allkeys-lru -&gt; Evict any key using approximated LRU.# volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set.# allkeys-lfu -&gt; Evict any key using approximated LFU.# volatile-random -&gt; Remove a random key among the ones with an expire set.# allkeys-random -&gt; Remove a random key, any key.# volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)# noeviction -&gt; Don't evict anything, just return an error on write operations.## LRU means Least Recently Used# LFU means Least Frequently Used## Both LRU, LFU and volatile-ttl are implemented using approximated# randomized algorithms.## Note: with any of the above policies, Redis will return an error on write# operations, when there are no suitable keys for eviction.## At the date of writing these commands are: set setnx setex append# incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd# sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby# zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby# getset mset msetnx exec sort## The default is:## maxmemory-policy noeviction# LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated# algorithms (in order to save memory), so you can tune it for speed or# accuracy. For default Redis will check five keys and pick the one that was# used less recently, you can change the sample size using the following# configuration directive.## The default of 5 produces good enough results. 10 Approximates very closely# true LRU but costs more CPU. 3 is faster but not very accurate.## maxmemory-samples 5# Starting from Redis 5, by default a replica will ignore its maxmemory setting# (unless it is promoted to master after a failover or manually). It means# that the eviction of keys will be just handled by the master, sending the# DEL commands to the replica as keys evict in the master side.## This behavior ensures that masters and replicas stay consistent, and is usually# what you want, however if your replica is writable, or you want the replica to have# a different memory setting, and you are sure all the writes performed to the# replica are idempotent, then you may change this default (but be sure to understand# what you are doing).## Note that since the replica by default does not evict, it may end using more# memory than the one set via maxmemory (there are certain buffers that may# be larger on the replica, or data structures may sometimes take more memory and so# forth). So make sure you monitor your replicas and make sure they have enough# memory to never hit a real out-of-memory condition before the master hits# the configured maxmemory setting.## replica-ignore-maxmemory yes RDB 触发机制： 1、执行 save 方法会生成 dump.rdb 文件。2、执行 flushall 命令生成 dump.rdb 文件。3、退出 Redis 也会生成 dump.rdb 文件。 AOF 配置： 持久化方式 AOF 的配置。 配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940# 每次启动时 Redis 都会先把这个文件的数据读入内存里，先忽略 RDB 文件【默认是不开启 AOF 模式的】appendonly no# 配置生成的 AOF 文件的名称appendfilename “appendonly.aof”# fsync() 系统调用告诉操作系统把数据写到磁盘上，而不是等更多的数据进入输出缓冲区。有些操作系统会真的把数据马上刷到磁盘上；有些则会尽快去尝试这么做。# Redis 支持三种不同的模式：# no： 不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。# always： 每次写操作都立刻写入到 aof 文件。慢，但是最安全。# everysec： 每秒写一次。折中方案。# 默认的 everysec 通常来说能在速度和数据安全性之间取得比较好的平衡。appendfsync everysec# 如果 AOF 的同步策略设置成 “always” 或者 “everysec” ，并且后台的存储进程（后台存储或写入 AOF 日志）会产生很多磁盘 I/O 开销。某些 Linux 的配置下会使 Redis 因为 fsync() 系统调用而阻塞很久。# 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们同步的 write(2) 调用。# 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止 fsync()。# 这就意味着如果有子进程在进行保存操作，那么 Redis 就处于\"不可同步\"的状态。# 这实际上是说，在最差的情况下可能会丢掉 30 秒钟的日志数据。（默认 Linux 设定）# 如果把这个设置成 \"yes\" 带来了延迟问题，就保持 \"no\" ，这是保存持久数据的最安全的方式。no-appendfsync-on-rewrite no#自动重写AOF文件。如果AOF日志文件增大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。#工作原理：Redis记住上次重写时AOF文件的大小（如果重启后还没有写操作，就直接用启动时的AOF大小）#这个基准大小和当前大小做比较。如果当前大小超过指定比例，就会触发重写操作。#你还需要指定被重写日志的最小尺寸，这样避免了达到指定百分比但尺寸仍然很小的情况还要重写。#指定百分比为0会禁用AOF自动重写特性。auto-aof-rewrite-percentage 100# 文件达到大小阈值的时候进行重写auto-aof-rewrite-min-size 64mb#如果设置为yes，如果一个因异常被截断的AOF文件被redis启动时加载进内存，redis将会发送日志通知用户#如果设置为no，erdis将会拒绝启动。此时需要用\"redis-check-aof\"工具修复文件。aof-load-truncated yes#加载时Redis识别出AOF文件以“REDIS”开头字符串，#并加载带此前缀的RDB文件，然后继续加载AOFaof-use-rdb-preamble yes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128############################## APPEND ONLY MODE ################################ By default Redis asynchronously dumps the dataset on disk. This mode is# good enough in many applications, but an issue with the Redis process or# a power outage may result into a few minutes of writes lost (depending on# the configured save points).## The Append Only File is an alternative persistence mode that provides# much better durability. For instance using the default data fsync policy# (see later in the config file) Redis can lose just one second of writes in a# dramatic event like a server power outage, or a single write if something# wrong with the Redis process itself happens, but the operating system is# still running correctly.## AOF and RDB persistence can be enabled at the same time without problems.# If the AOF is enabled on startup Redis will load the AOF, that is the file# with the better durability guarantees.## Please check http://redis.io/topics/persistence for more information.appendonly no# The name of the append only file (default: \"appendonly.aof\")appendfilename \"appendonly.aof\"# The fsync() call tells the Operating System to actually write data on disk# instead of waiting for more data in the output buffer. Some OS will really flush# data on disk, some other OS will just try to do it ASAP.## Redis supports three different modes:## no: don't fsync, just let the OS flush the data when it wants. Faster.# always: fsync after every write to the append only log. Slow, Safest.# everysec: fsync only one time every second. Compromise.## The default is \"everysec\", as that's usually the right compromise between# speed and data safety. It's up to you to understand if you can relax this to# \"no\" that will let the operating system flush the output buffer when# it wants, for better performances (but if you can live with the idea of# some data loss consider the default persistence mode that's snapshotting),# or on the contrary, use \"always\" that's very slow but a bit safer than# everysec.## More details please check the following article:# http://antirez.com/post/redis-persistence-demystified.html## If unsure, use \"everysec\".# appendfsync alwaysappendfsync everysec# appendfsync no# When the AOF fsync policy is set to always or everysec, and a background# saving process (a background save or AOF log background rewriting) is# performing a lot of I/O against the disk, in some Linux configurations# Redis may block too long on the fsync() call. Note that there is no fix for# this currently, as even performing fsync in a different thread will block# our synchronous write(2) call.## In order to mitigate this problem it's possible to use the following option# that will prevent fsync() from being called in the main process while a# BGSAVE or BGREWRITEAOF is in progress.## This means that while another child is saving, the durability of Redis is# the same as \"appendfsync none\". In practical terms, this means that it is# possible to lose up to 30 seconds of log in the worst scenario (with the# default Linux settings).## If you have latency problems turn this to \"yes\". Otherwise leave it as# \"no\" that is the safest pick from the point of view of durability.no-appendfsync-on-rewrite no# Automatic rewrite of the append only file.# Redis is able to automatically rewrite the log file implicitly calling# BGREWRITEAOF when the AOF log size grows by the specified percentage.## This is how it works: Redis remembers the size of the AOF file after the# latest rewrite (if no rewrite has happened since the restart, the size of# the AOF at startup is used).## This base size is compared to the current size. If the current size is# bigger than the specified percentage, the rewrite is triggered. Also# you need to specify a minimal size for the AOF file to be rewritten, this# is useful to avoid rewriting the AOF file even if the percentage increase# is reached but it is still pretty small.## Specify a percentage of zero in order to disable the automatic AOF# rewrite feature.auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb# An AOF file may be found to be truncated at the end during the Redis# startup process, when the AOF data gets loaded back into memory.# This may happen when the system where Redis is running# crashes, especially when an ext4 filesystem is mounted without the# data=ordered option (however this can't happen when Redis itself# crashes or aborts but the operating system still works correctly).## Redis can either exit with an error when this happens, or load as much# data as possible (the default now) and start if the AOF file is found# to be truncated at the end. The following option controls this behavior.## If aof-load-truncated is set to yes, a truncated AOF file is loaded and# the Redis server starts emitting a log to inform the user of the event.# Otherwise if the option is set to no, the server aborts with an error# and refuses to start. When the option is set to no, the user requires# to fix the AOF file using the \"redis-check-aof\" utility before to restart# the server.## Note that if the AOF file will be found to be corrupted in the middle# the server will still exit with an error. This option only applies when# Redis will try to read more data from the AOF file but not enough bytes# will be found.aof-load-truncated yes# When rewriting the AOF file, Redis is able to use an RDB preamble in the# AOF file for faster rewrites and recoveries. When this option is turned# on the rewritten AOF file is composed of two different stanzas:## [RDB file][AOF tail]## When loading Redis recognizes that the AOF file starts with the \"REDIS\"# string and loads the prefixed RDB file, and continues loading the AOF# tail.aof-use-rdb-preamble yes 注意啦！！！ 1、如果我们的 AOF 文件有错误，我们的 Redis 文件时启动不起来的。因此，我们需要修复 AOF 文件。2、Redis 给我们提供了一个工具： redis-check-aof ，用于修复受损的 AOF 文件。3、修复命令为： redis-check-aof –fix appendonly.aof Redis 的发布订阅Redis 发布订阅(pub/sub) 是一种 消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。 举个常用的例子：我们微信关注的公众号会给我们发送消息就属于这种通信模式。【Redis 客户端可以订阅任意数量的频道】 下表列出了关于 Redis 发布订阅常用命令： 1234567891011121314151617# 订阅一个或多个符合给定模式的频道。PSUBSCRIBE pattern [pattern ...]# 查看订阅与发布系统状态。PUBSUB subcommand [argument [argument ...]]# 将信息发送到指定的频道。PUBLISH channel message# 退订所有给定模式的频道。PUNSUBSCRIBE [pattern [pattern ...]]# 订阅给定的一个或多个频道的信息。SUBSCRIBE channel [channel ...]# 指退订给定的频道。UNSUBSCRIBE [channel [channel ...]] 使用 Redis 客户端来实现订阅发布。 如下图： TIPS： 使用 Java 来实现订阅发布先放一放，以后有空来完善。 应用场景： Redis 的发布订阅应用场景在我们生活中还是挺常见的。如下： 123456+++ Redis 订阅发布应用场景+ 1、构建实时消息系统，比如普通的即时聊天，群聊等功能。+ 2、微信的公共号订阅消息推送等。+++ Redis 订阅发布应用场景 Redis 的集群搭建集群简介Redis 是一个开源的 key value 存储系统，受到了广大互联网公司的青睐。但在 Redis3.0 版本之前，它只支持单例模式，在 3.0 版本及以后才支持集群。 Redis 集群采用 P2P 模式，是完全去中心化的，不存在中心节点或者代理节点。并且 Redis 集群是没有统一的入口的，客户端（client）连接集群的时候连接集群中的任意节点（node）即可。集群内部的节点是相互通信的（PING-PONG 机制），每个节点都是一个 Redis 实例。 为了实现 Redis 集群的高可用，即判断节点是否健康（能否正常使用），redis-cluster 有这么一个投票容错机制： 如果集群中超过半数的节点投票认为某个节点挂了，那么这个节点就挂了（fail）。这是判断节点是否挂了的方法。那么如何判断集群是否挂了呢? -&gt; 如果集群中任意一个节点挂了，而且该节点没有从节点（备份节点），那么这个集群就挂了。这是判断集群是否挂了的方法。 那么为什么任意一个节点挂了（没有从节点）这个集群就挂了呢？ 因为集群内置了 16384 个 slot（哈希槽），并且把所有的物理节点映射到了这 16384[0-16383] 个 slot 上，或者说把这些 slot 均等的分配给了各个节点。当需要在 Redis 集群存放一个数据（key-value）时，Redis 会先对这个 key 进行 crc16 算法，然后得到一个结果。再把这个结果对 16384 进行求余，这个余数会对应 [0-16383] 其中一个槽，进而决定 key-value 存储到哪个节点中。所以一旦某个节点挂了，该节点对应的 slot 就无法使用，那么就会导致集群无法正常工作。综上所述，每个 Redis 集群理论上最多可以有 16384 个节点。 集群所需环境： 1、Redis 集群至少需要 3 个节点， 因为投票容错机制要求超过半数节点认为某个节点挂了该节点才是挂了，所以 2 个节点无法构成集群。2、要保证集群的高可用，需要每个节点都有从节点，也就是备份节点，所以 Redis 集群至少需要 6 台服务器。因为我没有那么多服务器，也启动不了那么多虚拟机，所在这里搭建的是伪分布式集群，即一台服务器虚拟运行 6 个 redis 实例，修改端口号为（7001-7006），当然实际生产环境的 Redis 集群搭建和这里是一样的。 简介来源： redis集群搭建（非常详细，适合新手） 集群搭建第一步： 开启虚拟机，打开四个窗口连接我们的同一台虚拟机。 如下图： 第二步： 复制 Redis 配置文件，为每一台从机进行配置。 如下图： 第三步： 修改 redis.conf 、redis-1.conf 、redis-2.conf 和 redis-3.conf 配置文件。 需修改的配置如下： 123456789101112131415161718192021222324# redis.conf 配置文件需修改的地方logfile \"6379.log\" # 这个是修改后的内容dbfilename dump6379.rdb # 这个是修改后的内容# redis-1.conf 配置文件需修改的地方port 6380 # 这个是修改后的内容pidfile /var/run/redis_6380.pid # 这个是修改后的内容logfile \"6380.log\" # 这个是修改后的内容dbfilename dump6380.rdb # 这个是修改后的内容# redis-2.conf 配置文件需修改的地方port 6381 # 这个是修改后的内容pidfile /var/run/redis_6381.pid # 这个是修改后的内容logfile \"6381.log\" # 这个是修改后的内容dbfilename dump6381.rdb # 这个是修改后的内容# redis-3.conf 配置文件需修改的地方port 6382 # 这个是修改后的内容pidfile /var/run/redis_6382.pid # 这个是修改后的内容logfile \"6382.log\" # 这个是修改后的内容dbfilename dump6382.rdb # 这个是修改后的内容 第四步： 开启我们的四个 Redis 服务器，并进行查看。 具体操作如下图： 说明一下： 这个部分的操作是为下面的 Redis 的主从复制 服务的。所以，上述的搭建过程并不是真正意义上的集群搭建。 Redis 的主从复制主从复制简介通过持久化功能，Redis 保证了即使在服务器重启的情况下也不会丢失（或少量丢失）数据，但是由于数据是存储在一台服务器上的，如果这台服务器出现故障，比如硬盘坏了，也会导致数据丢失。为了避免单点故障，我们需要将数据复制多份部署在多台不同的服务器上，即使有一台服务器出现故障其他服务器依然可以继续提供服务。 这就要求当一台服务器上的数据更新后，自动将更新的数据同步到其他服务器上，这时候就用到了 Redis 的主从复制。 Redis 提供了复制（replication）功能来自动实现多台 Redis 服务器的数据同步。 我们可以通过部署多台 Redis ，并在配置文件中指定这几台 Redis 之间的主从关系，主服务器负责写入数据，同时把写入的数据实时同步到从服务器，这种模式叫做 主从复制 ，即 master/slave ，并且 Redis 默认 master 用于写，slave 用于读，向 slave 写数据会导致错误。 注意： 默认情况下，每一台 Redis 服务器都是主节点【如果还没有进行相应的配置】。 主从复制搭建主从复制会使用到的命令如下： 123127.0.0.1:6379&gt; info replication # 查看当前库信息127.0.0.1:6379&gt; slaveof host port # 配置主机【就是去认老大】127.0.0.1:6379&gt; slaveof no one # 如果主机宕机了，从机可使用这条命令让自己成为主机【谋朝篡位】 第一步： 开启四台 Redis 服务器的客户端。 如下图所示： 第二步： 我们使用 1 号机（6380 端口）去配置主机。（此时的 1 号机仍是主机，配置之后会变为从机） 配置如下图： 第三步： 配置完成后，我们去看看我们的主机状态（6379 端口）。 如下图： 第四步： 注意事项与故障测试。 这部分使用文字描述，具体操作自行实现。描述如下： 123456789101112+++ 注意事项与故障测试+ 1、真正的主从复制的配置应该在配置文件中配置，这样配置才是永久的，而我们使用命令配置只是暂时的。+ 2、主机负责写，从机负责读且从机不能写。（从机如果去写，会报错： (error) READONLY You can't write against a read only replica.）- 如果主机服务器（6379 端口）突然宕机了（我们把它断开连接），那么从机依旧会连接到主机，但是没有写操作。- 如果此时主机又恢复正常了，从机依旧可以获取到主机写的信息。+ 如果是使用命令行来配置的主从复制，这个时候从机如果重启，就会变会到主机，就无法获取到他原来主机的值。+ 这个时候如果把它变回从机，那么它又可以获取到原来主机的值。+++ 注意事项与故障测试 宕机后手动配置主机如果我们的 6379 机子宕机了，那怎么办呢？【现在我们先手动配置，稍后讲哨兵模式（自动配置）】 如下图： 我们先把集群配置成上图的第二种方式。【注意观察 6380 机子的信息】 如下图： 此时，我们把 6379 主机断开（使用 shutdown + exit 命令） ，那就没有主机了。那么 6380 机子可能成为主机吗？（需手动选择） 系统能不能在主机宕机之后自动选择主机呢？（哨兵模式，稍后讲） 我们先来手动配置，把 6380 机子设置为主机。如下图： 那么问题来了，如果 6379 又恢复正常了，谁会是主机呢？【6380 仍是主机，否则怎么叫谋朝篡位呢】 如下图： 温馨提示： 主机宕机的手动解决方案就是这样了。接下来介绍 自动解决方案： 哨兵模式 。 哨兵模式详解哨兵模式简介主从切换技术的方法是： 当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要 人工干预，费事费力，还会造成一段时间内服务不可用， 这不是一种推荐的方式。 更多时候， 我们优先考虑 哨兵模式 ：从 Redis2.8 开始正式提供了 Sentinel(哨兵)架构来解决这个问题。哨兵模式 就是谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。 哨兵模式 是一种特殊的模式， 首先 Redis 提供了哨兵的命令， 哨兵是一个独立的进程， 作为进程， 它会独立运行。其原理是哨兵通过发送命令， 等待 Redis 服务器响应， 从而监控运行的多个 Redis 实例。 哨兵模式如下图： 这里的哨兵有两个作用： 1、通过发送命令， 让 Redis 服务器返回监控其运行状态的信息， 包括主服务器和从服务器。2、当哨兵监测到 master 宕机， 会自动将 slave 切换成 master， 然后通过发布订阅模式通知其他的从服务器，并修改配置文件，让它们切换主机。 然而，一个哨兵进程对 Redis 服务器进行监控， 可能会出现问题【可能哨兵挂了】。 为此， 我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了 多哨兵模式 。如下图： 假设主服务器宕机，哨兵 1 先检测到这个结果， 系统并不会马上进行 failover 过程， 仅仅是哨兵 1 主观的认为主服务器不可用， 这个现象称为 主观下线 。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票， 投票的结果由一个哨兵发起， 进行 failover[故障转移] 操作。切换成功后， 就会通过 发布订阅模式 ， 让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为 客观下线 。 哨兵模式配置第一步： 明确我们的主从配置模式。 现在的配置模式 【一主三从】 如下图： 第二步： 配置我们的哨兵配置文件 sentinel.conf 。 配置文件内容及截图如下： sentinel.conf1234567############################################################################################ sentinel【固定的】 monitor【固定的】 监控的名称 主机 端口号 是否选举sentinel monitor myredis 127.0.0.1 6379 1# 上述的数字 1 表示： 当主机挂了，哨兵进行投票给从机，哪个从机票数多，谁就能够成为主机。########################################################################################### 第三步： 启动哨兵模式。 如下图： 第四步： 关闭主机，查看哨兵模式是否起作用。 如下图： 那么问题来了，如果 6379 机子恢复了，会出现什么情况呢？ 如下图： 优缺点及问题123456789101112+++ 哨兵模式优缺点+++ 优点+ 1、哨兵集群，基于主从复制模式，所有的主从配置优点，它全有。+ 2、主从可以切换，故障可以转移，系统的可用性就会更好。+ 3、哨兵模式就是主从模式的升级，手动到自动，更加健壮！--- 缺点- 1、Redis 不好在线扩容， 集群容量一旦到达上限， 在线扩容就十分麻烦!- 2、实现哨兵模式的配置其实是很麻烦的，里面有很多选择!+++ 哨兵模式优缺点 问题如下图：就是我恢复 6379 机子时，主机发生了变化，不是 6381了， 而是 6382。由于时间原因，暂未查明，以后看到把它搞定。 哨兵模式配置文件哨兵模式配置文件 详解如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#Example sentinel.conf#哨兵sentinel实例运行的端口 默认26379port 26379#哨兵sentinel的工作目录dir /tmp#哨兵sentinel监控的redis主节点的 ip port#master-name可以自己命名的主节点名字，只能由字母A-z、数字0-9、这三个字符\".-_\"组成。#quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了#sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;sentinel monitor mymaster 127.0.0.1 6379 2 #当在Redis实例中开启了requirepass foobared授权密码，这样所有连接Redis实例的客户端都要提供密码 #设置哨兵sentinel连接主从的密码，注意必须为主从设置一样的验证密码# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;sentinel auth-pass mymaster XXX#指定多少毫秒之后主节点没有应答哨兵，此时哨兵主观上认为主节点下线，默认30秒# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;sentinel down-after-milliseconds mymaster 30000# 这个配置项指定了在发生failover主备切换（选举）时多可以有多少个slave同时对新的master进行同步，数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为replication而不可用。可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态。# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;sentinel parallel-syncs mymaster 1#故障转移的超时时间failover-timeout可以用在以下这些方面：#1. 同一个sentinel对同一个master两次failover之间的间隔时间。#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。#3.当想要取消一个正在进行的failover所需要的时间。#4.当进行failover时，配置所有slaves指向新的master所需的大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了#默认三分钟# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;sentinel failover-timeout mymaster 180000#SCRIPTS EXECUTION#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。#对于脚本的运行结果有以下规则：#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。#一个脚本的大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配 置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无 法正常启动成功。#通知脚本# sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;sentinel notification-script mymaster /var/redis/notify.sh#客户端重新配置主节点参数脚本# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。#以下参数将会在调用脚本时传给脚本:# &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;# 目前&lt;state&gt;总是“failover”, # &lt;role&gt;是“leader”或者“observer”中的一个。#参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的# 这个脚本应该是通用的，能被多次调用，不是针对性的。# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;sentinel client-reconfig-script mymaster /var/redis/reconfig.sh 缓存穿透和雪崩缓存穿透简介缓存穿透的概念： 用户想要查询一个数据， 发现 Redis 内存数据库没有， 也就是缓存没有命中， 于是向持久层数据库查询。发现也没有，于是本次查询失败。 当用户很多的时候，缓存都没有命中(秒杀!)，于是都去请求了持久层数据库，这会给持久层数据库造成很大的压力，这时候就相当于出现了 缓存穿透 。 解决方案： 布隆过滤器 是一种数据结构， 对所有可能查询的参数以 hash 形式存储， 在控制层先进行校验， 不符合则丢弃， 从而避免了对底层存储系统的查询压力； 缓存空对象：当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。 但是这种方法会存在两个问题： 1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键。 2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。 缓存击穿这里需要注意缓存穿透和缓存击穿的区别， 缓存击穿 是指一个 key 非常热点（如微博热搜）， 在不停的扛着大并发， 大并发集中对这一个点进行访问， 当这个 key 在失效的瞬间， 持续的大并发就穿破缓存， 直接请求数据库， 就像在一个屏障上凿开了一个洞。 当某个 key 在过期的瞬间， 有大量的请求并发访问， 这类数据一般是热点数据， 由于缓存过期， 会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。 解决方案1、设置热点数据永不过期：从缓存层面来看， 没有设置过期时间， 所以不会出现热点 key 过期后产生的问题。2、加互斥锁分布式锁：使用分布式锁， 保证对于每个key同时只有一个线程去查询后端服务， 其他线程没有获得分布式锁的权限， 因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。 缓存雪崩缓存雪崩 是指在某一个时间段工缓存集中过期失效。产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。 其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。11!I 解决方案1、Redis 高可用这个思想的含义是， 既然red is有可能挂掉， 那我多增设几台red is， 这样一台挂掉之群。(异地多活!)2、限流降级这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的询数据和写缓存，其他线程等待。3、数据预热数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分将发生大并发访问前手动触发加载缓存不同的key， 设置不同的过期时间， 让缓存失后其他的还可以继续工作，其实就是搭建的集的线程数量。比如对某个key只允许一个线程查分可能大量访问的数据就会加载到缓存中。在即效的时间点尽量均匀。 Redis 面试题redis 是什么？都有哪些使用场景？ 123456789101112Redis（Remote Dictionary Server ) : 即远程字典服务 ，是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、高性能的 NOSQL 系列的非关系型数据库 ，并提供多种语言的 API 。【———— 百度百科】# Redis 的应用场景1、缓存（数据查询、短连接、新闻内容、商品内容等等）2、聊天室的在线好友列表3、任务队列。（秒杀、抢购、12306 等等）4、应用排行榜5、网站访问统计6、数据过期处理（可以精确到毫秒7、分布式集群架构中的 session 分离8、发布订阅系统9、地图信息分析 redis 有哪些功能？ 123456# Redis 的功能数据缓存功能分布式锁的功能支持数据持久化支持事务支持消息队列 redis 和 memecache 有什么区别？ DJFASFDJAKLFASDLF; 123memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型redis 的速度比 memcached 快很多redis 可以持久化其数据 redis 为什么是单线程的？ 因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。 什么是缓存穿透？怎么解决？ 缓存穿透： 指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 redis 支持的数据类型有哪些？ string、list、hash、set、zset。 redis 支持的 java 客户端都有哪些？ Redisson、Jedis、lettuce等等，官方推荐使用Redisson。 jedis 和 redisson 有哪些区别？ Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。 Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。 怎么保证缓存和数据库数据的一致性？ 合理设置缓存的过期时间。 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。 redis 持久化有几种方式？ Redis 的持久化有两种方式，或者说有两种策略： RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。 AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。 redis 怎么实现分布式锁？ Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。 占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。 redis 分布式锁有什么缺陷？ Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。 redis 如何做内存优化？ 尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。 比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。 redis 淘汰策略有哪些？ volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。 volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。 volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。 allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。 allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。 no-enviction（驱逐）：禁止驱逐数据。 redis 常见的性能问题有哪些？该如何解决？ 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。","link":"/redis.html"},{"title":"数据结构入门","text":"内容概要： 线性表和链表 栈和队列 数组和广义表 树和二叉树 图的知识 线性表和链表链表与单链表介绍 单链表的应用基本介绍 代码实现单链表的 创建、遍历、插入以及顺序插入 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139public class SingleLinkedListTest { public static void main(String[] args) { // 01-创建几个节点 HeroNode heroNode1 = new HeroNode(1, \"松江\", \"及时雨\"); HeroNode heroNode2 = new HeroNode(2, \"卢俊义\", \"玉麒麟\"); HeroNode heroNode3 = new HeroNode(3, \"吴用\", \"智多星\"); HeroNode heroNode4 = new HeroNode(4, \"林冲\", \"豹子头\"); // 02-创建一个链表 SingleLinkedList singleLinkedList = new SingleLinkedList();// singleLinkedList.add(heroNode1);// singleLinkedList.add(heroNode4);// singleLinkedList.add(heroNode3);// singleLinkedList.add(heroNode2); // 按照顺序加入 singleLinkedList.addByOrder(heroNode1); singleLinkedList.addByOrder(heroNode4); singleLinkedList.addByOrder(heroNode3); singleLinkedList.addByOrder(heroNode2); singleLinkedList.addByOrder(heroNode2); // 03-显示单链表 singleLinkedList.showList(); }}/** * 定义 SingleLinkedList 单链表管理我们的英雄 */class SingleLinkedList { // 01-初始化一个头节点，头节点不要动，不存放具体的数据 private HeroNode head = new HeroNode(0, \"\", \"\"); public HeroNode getHead() { return head; } // 02-添加节点到单向链表，直接添加到链表尾部 /** * 思路分析：当不考虑编号顺序时 * 1. 找到当前链表的最后节点 * 2. 将最后这个节点的 next 指向新的节点 */ public void add(HeroNode heroNode) { // 因为头节点不能动，所以我们需要一个辅助变量 temp HeroNode temp = head; // 遍历链表 while (true) { // 找到链表的最后 if (temp.next == null) { break; } // 如果没有找到最后，将 temp 后移 temp = temp.next; } // 当退出 while 循环时，temp 就指向了链表的最后 temp.next = heroNode; } // 根据排名将英雄添加到指定位置，即按照顺序添加 public void addByOrder(HeroNode heroNode){ HeroNode temp = head; boolean flag = false; // 标志添加的编号是否存在，默认为 false while (true){ if (temp.next == null){ // 说明 temp 已经在链表最后 break; } if(temp.next.no &gt; heroNode.no){ break; } else if(temp.next.no == heroNode.no){ // 编号已经存在 flag = true; // 说明编号存在 break; } temp = temp.next; } if(flag){ // 不能添加，编号存在 System.out.printf(\"待插入的英雄编号 %d 已经存在了，不能加入！\", heroNode.no); } else { heroNode.next = temp.next; temp.next = heroNode; } } // 显示链表[遍历] public void showList() { // 判断链表是否为空 if (head.next == null) { System.out.println(\"链表为空\"); return; } HeroNode temp = head.next; while (true) { if (temp == null) { break; } System.out.println(temp); // 将 temp 后移，否则是死循环 temp = temp.next; } }}/** * 单链表 */class HeroNode { public int no; public String name; public String nickname; public HeroNode next; // 指向下一个节点 // 构造器 public HeroNode(int no, String name, String nickname) { this.no = no; this.name = name; this.nickname = nickname; } // 为了显示方便，重写 toString @Override public String toString() { return \"HeroNode{\" + \"no=\" + no + \", name='\" + name + '\\'' + \", nickname='\" + nickname + '\\'' + '}'; }} 单链表的节点信息的 修改操作 ，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839/* 以下三行代码加入到 main 方法里面 */// 04-测试修改节点的代码HeroNode heroNode = new HeroNode(2,\"小卢\",\"玉麒麟~~~\");singleLinkedList.update(heroNode);singleLinkedList.showList();/* 以下 update 方法加入到 SingleLinkedList 类里面 */// 修改节点的信息，根据 no 编号来修改public void update(HeroNode heroNode) { // 判断链表是否为空 if (head.next == null) { System.out.println(\"链表为空！！！\"); return; } HeroNode temp = head.next; boolean flag = false; while (true) { if (temp.next == null) { break; // 到达了链表的最后 } if (temp.no == heroNode.no) { flag = true; break; } temp = temp.next; } if (flag) { temp.name = heroNode.name; temp.nickname = heroNode.nickname; } else { System.out.printf(\"没有找到编号为 %d 的节点，不能修改！！！\", heroNode.no); }} 单链表的节点信息的 删除操作 ，代码如下： 1234567891011121314151617181920212223242526272829303132/* 以下四行代码加入到 main 方法里面 */// 05-删除一个节点singleLinkedList.delete(1);singleLinkedList.delete(5);System.out.println(\"删除后链表的情况~~~~~\");singleLinkedList.showList();/* 以下 delete 方法加入到 SingleLinkedList 类里面 */// 根据 no 删除节点public void delete(int no) { HeroNode temp = head; boolean flag = false; while (true) { if (temp.next == null) { break; } if (temp.next.no == no) { // 找到待删除结点的前一个结点 temp flag = true; break; } temp = temp.next; } if (flag) { temp.next = temp.next.next; } else { System.out.printf(\"要删除的 %d 节点不存在\\n\", no); }} 单链表面试题 解决 第一个 题目：求单链表中有效节点的个数 ，代码如下： 12345678910111213141516171819202122232425/* 以下三行代码加入到 main 方法里面 */HeroNode head = singleLinkedList.getHead();int length = SingleLinkedList.getLength(head);System.out.println(\"有效节点个数为：\" + length);/* 以下 getLength 方法加入到 SingleLinkedList 类里面 */// 获取单链表的节点个数（如果是带头节点的单链表，则不统计头节点）public static int getLength(HeroNode heroNode) { if (heroNode.next == null) { return 0; } int length = 0; // 定义一个辅助遍历，这里就体现了没有统计头节点 HeroNode cur = heroNode.next; while (cur != null) { length++; cur = cur.next; } return length;} 解决 第二个 题目：查找单链表中的倒数第 k 个节点【新浪面试题】 ，代码如下： 123456789101112131415161718192021222324252627282930313233/* 以下四行代码加入到 main 方法里面 */HeroNode res1 = SingleLinkedList.findNode(singleLinkedList.getHead(), 2);System.out.println(\"res = \" + res1);HeroNode res2 = SingleLinkedList.findNode(singleLinkedList.getHead(), 5);System.out.println(\"res = \" + res2);// 查找单链表中的倒数第 k 个节点 【新浪面试题】/** * 思路分析： * 1. 编写一个方法，接收 head 节点，同时接收一个 index * 2. index 表示是倒数第 index 个节点 * 3. 先把链表从头到尾遍历，得到链表的总长度，使用 getLength 方法 * 4. 得到 size 后，我们从链表的第一个车开始遍历 （size-index） 个，就可以得到 * 5. 如果找到了，则返回该节点，否则返回 null */public static HeroNode findNode(HeroNode head, int index) { if (head.next == null) { return null; } int length = getLength(head); if (index &lt;= 0 || index &gt; length) { return null; } HeroNode cur = head.next; for (int i = 0; i &lt; (length - index); i++) { cur = cur.next; } return cur;} 解决 第三个 题目：单链表的反转【腾讯面试题】 ，代码如下： 123456789101112131415161718192021222324252627282930313233/* 以下五行代码加入到 main 方法里面 */// 单链表的反转测试System.out.println(\"原来链表的情况~~~\");singleLinkedList.showList();System.out.println(\"反转后链表的情况~~~\");SingleLinkedList.reverseList(head);singleLinkedList.showList();// 将单链表反转public static void reverseList(HeroNode head) { // 如果当前链表为空，或者只有一个节点，无需反转，直接返回 if (head.next == null || head.next.next == null) { return; } // 定义一个辅助变量，帮助遍历原先的链表 HeroNode cur = head.next; HeroNode next = null; HeroNode reverseHead = new HeroNode(0, \"\", \"\"); // 遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表 reverseHead 的最前端 while (cur != null) { next = cur.next; cur.next = reverseHead.next; // 将 cur 的下一个节点指向新的链表的最前端 reverseHead.next = cur; // 将 cur 连接到新的链表 cur = next; // 让 cur 后移 } // 将 head.next 指向 reverseHead.next ，实现单链表的反转 head.next = reverseHead.next;} 解决 第四个 题目：从尾到头打印单链表【百度面试题：要求方式1：反向遍历。要求方式2：Stack 栈】 ，代码如下： 12345678910111213141516171819202122232425// 逆序打印，以下一行加入到 main方法中SingleLinkedList.revesrePrint(head);// 实现逆序打印public static void revesrePrint(HeroNode head){ if(head.next == null){ return; } Stack&lt;HeroNode&gt; stack = new Stack&lt;&gt;(); HeroNode cur = head.next; // 压栈 while (cur != null){ stack.push(cur); cur = cur.next; } // 出栈 while (stack.size() &gt; 0){ System.out.println(stack.pop()); }} 双向链表基本介绍学完单链表发现，单链表只能从头结点开始访问链表中的数据元素，如果需要逆序访问单链表中的数据元素将极其低效。因而出现了 双链表结构 。双链表 是链表的一种，由节点组成，每个数据结点中都有两个指针，分别指向 直接后继 和 直接前驱 。双链表结构如下图： 应用实现使用 双链表 对上述单链表的功能进行再次实现，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183/** * @Author: guoshizhan * @Create: 2020/5/27 12:51 * @Description: 双向链表案例 */public class DoubleLinkedListTest { public static void main(String[] args) { System.out.println(\"双向链表测试~~~\"); // 01-创建几个节点 HeroDoubleNode heroNode1 = new HeroDoubleNode(1, \"松江\", \"及时雨\"); HeroDoubleNode heroNode2 = new HeroDoubleNode(2, \"卢俊义\", \"玉麒麟\"); HeroDoubleNode heroNode3 = new HeroDoubleNode(3, \"吴用\", \"智多星\"); HeroDoubleNode heroNode4 = new HeroDoubleNode(4, \"林冲\", \"豹子头\"); DoubleLinkedList doubleLinkedList = new DoubleLinkedList(); doubleLinkedList.add(heroNode1); doubleLinkedList.add(heroNode2); doubleLinkedList.add(heroNode3); doubleLinkedList.add(heroNode4); doubleLinkedList.showList(); // 修改测试 HeroDoubleNode newNode = new HeroDoubleNode(4, \"Jack\", \"Jacky\"); doubleLinkedList.update(newNode); System.out.println(\"修改后双向链表~~~\"); doubleLinkedList.showList(); // 删除测试 doubleLinkedList.delete(3); System.out.println(\"删除后双向链表~~~\"); doubleLinkedList.showList(); }}class DoubleLinkedList { // 01-初始化一个头节点，头节点不要动，不存放具体的数据 private HeroDoubleNode head = new HeroDoubleNode(0, \"\", \"\"); // 02-返回头节点 public HeroDoubleNode getHead() { return head; } // 03-显示链表[遍历] public void showList() { // 判断链表是否为空 if (head.next == null) { System.out.println(\"链表为空\"); return; } HeroDoubleNode temp = head.next; while (true) { if (temp == null) { break; } System.out.println(temp); // 将 temp 后移，否则是死循环 temp = temp.next; } } // 04-添加节点到双向链表最后 /** * 思路分析：当不考虑编号顺序时 * 1. 找到当前链表的最后节点 * 2. 将最后这个节点的 next 指向新的节点 */ public void add(HeroDoubleNode heroNode) { // 因为头节点不能动，所以我们需要一个辅助变量 temp HeroDoubleNode temp = head; // 遍历链表 while (true) { // 找到链表的最后 if (temp.next == null) { break; } // 如果没有找到最后，将 temp 后移 temp = temp.next; } // 当退出 while 循环时，temp 就指向了链表的最后 temp.next = heroNode; heroNode.pre = temp; } // 05-修改节点的信息，根据 no 编号来修改 public void update(HeroDoubleNode heroNode) { // 判断链表是否为空 if (head.next == null) { System.out.println(\"链表为空！！！\"); return; } HeroDoubleNode temp = head.next; boolean flag = false; while (true) { if (temp == null) { break; // 到达了链表的最后 } if (temp.no == heroNode.no) { flag = true; break; } temp = temp.next; } if (flag) { temp.name = heroNode.name; temp.nickname = heroNode.nickname; } else { System.out.printf(\"没有找到编号为 %d 的节点，不能修改！！！\", heroNode.no); } } /** * 06-删除节点思路分析： * 1. 对于双向链表，我们可以直接找到要删除的这个节点 * 2. 找到后，自我删除节点即可 */ public void delete(int no) { if (head.next == null){ System.out.println(\"链表为空，无法删除！！！\"); return; } HeroDoubleNode temp = head.next; boolean flag = false; while (true) { if (temp == null) { break; } if (temp.no == no) { // 找到待删除结点的前一个结点 temp flag = true; break; } temp = temp.next; } if (flag) { temp.pre.next = temp.next; if (temp.next != null){ temp.next.pre = temp.pre; } } else { System.out.printf(\"要删除的 %d 节点不存在\\n\", no); } }}class HeroDoubleNode { public int no; public String name; public String nickname; public HeroDoubleNode next; // 指向下一个节点 public HeroDoubleNode pre; // 指向前一个节点 // 构造器 public HeroDoubleNode(int no, String name, String nickname) { this.no = no; this.name = name; this.nickname = nickname; } // 为了显示方便，重写 toString @Override public String toString() { return \"HeroNode{\" + \"no=\" + no + \", name='\" + name + '\\'' + \", nickname='\" + nickname + '\\'' + '}'; }} 环形链表基本介绍环形链表 ，类似于单链表，也是一种链式存储结构，环形链表由单链表演化过来。单链表的最后一个结点的链域指向 NULL ，而环形链表则 首位相连 ，组成环状数据结构。如下图： 约瑟夫环问题而在环形链表中，最为著名的即是 约瑟夫环问题 ，也称之为 丢手帕问题 。介绍如下图： 解决 约瑟夫环问题 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/** * @Author: guoshizhan * @Create: 2020/5/27 18:22 * @Description: 约瑟夫问题 */public class Josephu { public static void main(String[] args) { // 创建链表 CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList(); circleSingleLinkedList.addBoy(5); // 加入 5 个节点 circleSingleLinkedList.showNode(); // 出圈操作 circleSingleLinkedList.countBoyNode(1, 2, 5); }}/** * 创建一个环形单项链表 */class CircleSingleLinkedList { // 创建一个 first 节点 private BoyNode first = null; // 添加节点，构建一个环形链表 public void addBoy(int num) { if (num &lt; 1) { System.out.println(\"参数小于 1 ，不正确！！！\"); return; } // 辅助节点，用于构建环形链表 BoyNode curNode = null; // 使用 for 循环构建环形链表 for (int i = 1; i &lt;= num; i++) { // 根据编号创建节点 BoyNode boyNode = new BoyNode(i); // 如果三第一个节点 if (i == 1) { first = boyNode; first.setNext(first); curNode = first; // 让 curNode 指向第一个节点 } else { curNode.setNext(boyNode); boyNode.setNext(first); curNode = boyNode; } } } // 遍历当前的环形链表 public void showNode() { if (first == null) { System.out.println(\"链表为空，没有节点~~~\"); } BoyNode temp = first; while (true) { System.out.printf(\"节点的编号 %d \\n\", temp.getNo()); if (temp.getNext() == first) { break; } temp = temp.getNext(); } } // 根据用户的输入，计算节点出圈顺序 /** * @param startsNo 表示从第几个节点开始数数 * @param countNum 表示数几下 * @param nums 表示最初有多少个节点在圈中 */ public void countBoyNode(int startsNo, int countNum, int nums) { // 对参数进行校验 if (first == null || startsNo &lt; 1 || startsNo &gt; nums) { System.out.println(\"参数输入有误，请重新输入！！！\"); return; } // 创建辅助变量 BoyNode helper = first; while (true) { if (helper.getNext() == first) { break; } helper = helper.getNext(); } // 节点报数前，先让 first 和 helper 移动 k-1 次 for (int i = 0; i &lt; (startsNo - 1); i++) { first = first.getNext(); helper = helper.getNext(); } // 出圈操作 while (true) { // 说明圈中只有一个节点 if (helper == first) { break; } for (int i = 0; i &lt; (countNum - 1); i++) { first = first.getNext(); helper = helper.getNext(); } // 这是 first 着指向的节点就是要出圈节点 System.out.printf(\"%d 节点出圈\\n\", first.getNo()); first = first.getNext(); helper.setNext(first); } System.out.printf(\"最后留在圈中的节点是 %d \\n\", first.getNo()); }}/** * 创建一个 BoyNode 类，表示一个节点 */class BoyNode { private int no; // 编号 private BoyNode next; // 指向下一个节点，默认为 null public int getNo() { return no; } public void setNo(int no) { this.no = no; } public BoyNode getNext() { return next; } public void setNext(BoyNode next) { this.next = next; } public BoyNode(int no) { this.no = no; }} 栈和队列栈的知识认识栈 数组模拟栈数组模拟栈的 思路分析 如下图： 数组模拟栈的 代码实现 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/** * @Author: guoshizhan * @Create: 2020/5/27 21:46 * @Description: 栈的知识 */public class ArrayStackTest { public static void main(String[] args) { ArrayStack stack = new ArrayStack(4); String key; boolean loop = true; Scanner scanner = new Scanner(System.in); while (loop) { System.out.println(\"show: 显示栈\"); System.out.println(\"push: 压栈\"); System.out.println(\"pop: 出栈\"); System.out.println(\"exit: 退出程序\"); System.out.println(\"请输入相关操作：\"); key = scanner.next(); switch (key) { case \"show\": stack.showStack(); break; case \"push\": System.out.println(\"请输入一个数：\"); int value = scanner.nextInt(); stack.push(value); break; case \"pop\": try { int res = stack.pop(); System.out.printf(\"出栈的数据是 %d \\n\",res); } catch (Exception e){ System.out.println(e.getMessage()); } break; case \"exit\": scanner.close(); loop = false; break; default: break; } } System.out.println(\"程序退出了！！！\"); }}// 定义一个 ArrayStack 表示栈class ArrayStack { private int maxSize; // 栈的大小 private int[] stack; // 数组模拟栈，数据就放在该数组中 private int top = -1; // top 表示栈顶，初始值为 -1 // 构造器 public ArrayStack(int maxSize) { this.maxSize = maxSize; stack = new int[maxSize]; } // 栈满 public boolean isFull() { return top == maxSize - 1; } // 栈空 public boolean isEmpty() { return top == -1; } // 入栈-push public void push(int value) { if (isFull()) { System.out.println(\"栈满！！！\"); return; } top++; stack[top] = value; } // 出栈-pop public int pop() { if (isEmpty()) { throw new RuntimeException(\"栈空，没有数据！！！\"); } int value = stack[top]; top--; return value; } // 遍历栈 public void showStack() { if (isEmpty()) { System.out.println(\"栈空，没有数据！！！\"); return; } for (int i = top; i &gt;= 0; i--) { System.out.printf(\"stack[%d] = %d\\n\", i, stack[i]); } }} 栈实现计算器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186/** * @Author: guoshizhan * @Create: 2020/5/28 10:28 * @Description: 实现计算器【中缀表达式】 */public class Calculator { public static void main(String[] args) { // 定义需要扫描的表达式 String expression = \"30+50*6-2\"; // 创建数栈和符号栈 ArrayStack numStack = new ArrayStack(10); ArrayStack operStack = new ArrayStack(10); // 定义相关变量 int index = 0; int num1; int num2; int oper; int res = 0; char ch; String keepNum = \"\"; while (true) { // 得到表达式的每一个字符 ch = expression.substring(index, index + 1).charAt(0); // 判断 ch 是数字还是运算符 if (operStack.isOper(ch)) { // 如果是运算符 // 判断当前符号栈是否为空 if (!operStack.isEmpty()) { if (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) { num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); // 把运算结果如符号栈 numStack.push(res); // 将当前操作符如符号栈 operStack.push(ch); } else { // 如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈 operStack.push(ch); } } else { // 如果为空，直接入符号栈 operStack.push(ch); } } else { // 如果是数，则直接入数栈// numStack.push(ch - 48); // 不能发现一个数时就直接入栈，如果是多位数，则运算出错 keepNum += ch; if (index == expression.length() - 1) { numStack.push(Integer.parseInt(keepNum)); } else { // 判断后一位是否是操作符 if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) { numStack.push(Integer.parseInt(keepNum)); keepNum = \"\"; } } } // 让 index + 1，并判断是否扫描到 expression 最后 index++; if (index &gt;= expression.length()) { break; } } while (true) { // 如果符号栈为空，则计算到最后的结果 if (operStack.isEmpty()) { break; } else { num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); numStack.push(res); } } // 输出最终结果 System.out.println(\"表达式最终结果：\" + res); }}// 定义一个 ArrayStack 表示栈class ArrayStack { private int maxSize; // 栈的大小 private int[] stack; // 数组模拟栈，数据就放在该数组中 private int top = -1; // top 表示栈顶，初始值为 -1 // 构造器 public ArrayStack(int maxSize) { this.maxSize = maxSize; stack = new int[maxSize]; } // 栈满 public boolean isFull() { return top == maxSize - 1; } // 栈空 public boolean isEmpty() { return top == -1; } // 入栈-push public void push(int value) { if (isFull()) { System.out.println(\"栈满！！！\"); return; } top++; stack[top] = value; } // 出栈-pop public int pop() { if (isEmpty()) { throw new RuntimeException(\"栈空，没有数据！！！\"); } int value = stack[top]; top--; return value; } // 遍历栈 public void showStack() { if (isEmpty()) { System.out.println(\"栈空，没有数据！！！\"); return; } for (int i = top; i &gt;= 0; i--) { System.out.printf(\"stack[%d] = %d\\n\", i, stack[i]); } } // 返回运算符的优先级，优先级使用数字表示，数字越大，优先级越高 public int priority(int oper) { if (oper == '*' || oper == '/') { return 1; } else if (oper == '+' || oper == '-') { return 0; } else { return -1; } } // 判断是不是一运算符 public boolean isOper(char val) { return val == '+' || val == '-' || val == '*' || val == '/'; } // 计算方法 public int cal(int num1, int num2, int oper) { int res = 0; switch (oper) { case '+': res = num1 + num2; break; case '-': res = num2 - num1; break; case '*': res = num2 * num1; break; case '/': res = num2 / num1; break; default: break; } return res; } // 获取栈顶的值 public int peek() { return stack[top]; }} 前、中、后缀表达式前缀表达式 基本介绍如下： 中缀表达式 基本介绍如下： 后缀表达式 基本介绍如下： 逆波兰计算器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * @Author: guoshizhan * @Create: 2020/5/28 15:03 * @Description: 逆波兰计算器 */public class PolandNotation { public static void main(String[] args) { // 先定义逆波兰表达式 (3+4)*5-6 ==&gt; 3 4 + 5 * 6 - String suffixExpression = \"3 4 + 5 * 6 -\"; /** * 思路分析： * 1. 先将 suffixExpression 放到 ArrayList 中 * 2. 将 ArrayList 传递给一个方法，然后遍历 ArrayList，配合栈完成计算 */ List&lt;String&gt; list = getListstring(suffixExpression); System.out.println(list); int res = calculate(list); System.out.println(\"逆波兰表达式最终结果：\" + res); System.out.println(); // 定义逆波兰表达式 4*5-8+60+8/2 ==&gt; 4 5 * 8 - 60 + 8 2 / + String suffixExp = \"4 5 * 8 - 60 + 8 2 / +\"; List&lt;String&gt; stringList = getListstring(suffixExp); System.out.println(stringList); int calculate = calculate(stringList); System.out.println(\"逆波兰表达式最终结果：\" + calculate); } public static List&lt;String&gt; getListstring(String suffixExpression) { // 将 suffixExpression 分割 String[] strings = suffixExpression.split(\" \"); List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String string : strings) { list.add(string); } return list; } // 完成逆波兰表达式的运算 public static int calculate(List&lt;String&gt; ls) { // 创建栈 Stack&lt;String&gt; strings = new Stack&lt;&gt;(); for (String item : ls) { if (item.matches(\"\\\\d+\")) { //匹配多位数 strings.push(item); } else { // pop 出两个数并运算，然后入栈 int num2 = Integer.parseInt(strings.pop()); int num1 = Integer.parseInt(strings.pop()); int res = 0; if (item.equals(\"+\")) { res = num1 + num2; } else if (item.equals(\"-\")) { res = num1 - num2; } else if (item.equals(\"*\")) { res = num1 * num2; } else if (item.equals(\"/\")) { res = num1 / num2; } else { throw new RuntimeException(\"运算符有误！！！\"); } // 把 res 入栈 strings.push(res + \"\"); } } // 最后留在栈中的数就是结果 return Integer.parseInt(strings.pop()); }} 中缀转后缀中缀表达式 转化为 后缀表达式 ，难度有点大，详情如下图： 中缀表达式 转化为 后缀表达式 代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 以下七行代码是 main 方法中代码// 将中缀表达式转化为后缀表达式String expression = \"1+((20+3)*4)-5\";List&lt;String&gt; list1 = toInfixExpressionList(expression);System.out.println(list1);List&lt;String&gt; list2 = parseSuffixExpressionList(list1);System.out.println(list2);int calculate1 = calculate(list2);System.out.println(calculate1);// 将中缀表达式转化成对应的 Listpublic static List&lt;String&gt; toInfixExpressionList(String s) { // 定义一个 List，存放中缀表达式对应的内容 List&lt;String&gt; ls = new ArrayList&lt;&gt;(); int i = 0; // 这是一个指针，用于遍历中缀表达式字符串 String str; char c; do { // 如果 c 是一个非数字 if ((c = s.charAt(i)) &lt; 48 || (c = s.charAt(i)) &gt; 57) { ls.add(\"\" + c); i++; } else { str = \"\"; while (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= 48 &amp;&amp; (c = s.charAt(i)) &lt;= 57) { str += c; i++; } ls.add(str); } } while (i &lt; s.length()); return ls;}// 转化成后缀表达式操作：ArrayList [1, +, (, (, 20, +, 3, ), *, 4, ), -, 5] ==&gt; ArrayList [1,20,3,+,4,*,+,5,-]public static List&lt;String&gt; parseSuffixExpressionList(List&lt;String&gt; ls) { Stack&lt;String&gt; chStack = new Stack&lt;&gt;(); // 符号栈 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 遍历 ls for (String item : ls) { if (item.matches(\"\\\\d+\")) { list.add(item); } else if (item.equals(\"(\")) { chStack.push(item); } else if (item.equals(\")\")) { while (!chStack.peek().equals(\"(\")) { list.add(chStack.pop()); } chStack.pop(); // 消除小括号 } else { while (chStack.size() != 0 &amp;&amp; Operaation.getValue(chStack.peek()) &gt;= Operaation.getValue(item)) { list.add(chStack.pop()); } chStack.push(item); } } while (chStack.size() != 0) { list.add(chStack.pop()); } return list;} 逆波兰计算器完整版 逆波兰计算器完整版 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Stack;import java.util.regex.Pattern;public class ReversePolishMultiCalc { /** * 匹配 + - * / ( ) 运算符 */ static final String SYMBOL = \"\\\\+|-|\\\\*|/|\\\\(|\\\\)\"; static final String LEFT = \"(\"; static final String RIGHT = \")\"; static final String ADD = \"+\"; static final String MINUS= \"-\"; static final String TIMES = \"*\"; static final String DIVISION = \"/\"; public static void main(String[] args) { //String math = \"9+(3-1)*3+10/2\"; String math = \"12.8 + (2 - 3.55)*4+10/5.0\"; try { doCalc(doMatch(math)); } catch (Exception e) { e.printStackTrace(); } } /** * 加減 + - */ static final int LEVEL_01 = 1; /** * 乘除 * / */ static final int LEVEL_02 = 2; /** * 括号 */ static final int LEVEL_HIGH = Integer.MAX_VALUE; static Stack&lt;String&gt; stack = new Stack&lt;&gt;(); static List&lt;String&gt; data = Collections.synchronizedList(new ArrayList&lt;String&gt;()); /** * 去除所有空白符 * @param s * @return */ public static String replaceAllBlank(String s ){ // \\\\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \\f\\n\\r\\t\\v] return s.replaceAll(\"\\\\s+\",\"\"); } /** * 判断是不是数字 int double long float * @param s * @return */ public static boolean isNumber(String s){ Pattern pattern = Pattern.compile(\"^[-\\\\+]?[.\\\\d]*$\"); return pattern.matcher(s).matches(); } /** * 判断是不是运算符 * @param s * @return */ public static boolean isSymbol(String s){ return s.matches(SYMBOL); } /** * 匹配运算等级 * @param s * @return */ public static int calcLevel(String s){ if(\"+\".equals(s) || \"-\".equals(s)){ return LEVEL_01; } else if(\"*\".equals(s) || \"/\".equals(s)){ return LEVEL_02; } return LEVEL_HIGH; } /** * 匹配 * @param s * @throws Exception */ public static List&lt;String&gt; doMatch (String s) throws Exception{ if(s == null || \"\".equals(s.trim())) throw new RuntimeException(\"data is empty\"); if(!isNumber(s.charAt(0)+\"\")) throw new RuntimeException(\"data illeagle,start not with a number\"); s = replaceAllBlank(s); String each; int start = 0; for (int i = 0; i &lt; s.length(); i++) { if(isSymbol(s.charAt(i)+\"\")){ each = s.charAt(i)+\"\"; //栈为空，(操作符，或者 操作符优先级大于栈顶优先级 &amp;&amp; 操作符优先级不是( )的优先级 及是 ) 不能直接入栈 if(stack.isEmpty() || LEFT.equals(each) || ((calcLevel(each) &gt; calcLevel(stack.peek())) &amp;&amp; calcLevel(each) &lt; LEVEL_HIGH)){ stack.push(each); }else if( !stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek())){ //栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈 while (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()) ){ if(calcLevel(stack.peek()) == LEVEL_HIGH){ break; } data.add(stack.pop()); } stack.push(each); }else if(RIGHT.equals(each)){ // ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈 while (!stack.isEmpty() &amp;&amp; LEVEL_HIGH &gt;= calcLevel(stack.peek())){ if(LEVEL_HIGH == calcLevel(stack.peek())){ stack.pop(); break; } data.add(stack.pop()); } } start = i ; //前一个运算符的位置 }else if( i == s.length()-1 || isSymbol(s.charAt(i+1)+\"\") ){ each = start == 0 ? s.substring(start,i+1) : s.substring(start+1,i+1); if(isNumber(each)) { data.add(each); continue; } throw new RuntimeException(\"data not match number\"); } } //如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+， //应该依次出栈入列，可以直接翻转整个stack 添加到队列 Collections.reverse(stack); data.addAll(new ArrayList&lt;&gt;(stack)); System.out.println(data); return data; } /** * 算出结果 * @param list * @return */ public static Double doCalc(List&lt;String&gt; list){ Double d = 0d; if(list == null || list.isEmpty()){ return null; } if (list.size() == 1){ System.out.println(list); d = Double.valueOf(list.get(0)); return d; } ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) { list1.add(list.get(i)); if(isSymbol(list.get(i))){ Double d1 = doTheMath(list.get(i - 2), list.get(i - 1), list.get(i)); list1.remove(i); list1.remove(i-1); list1.set(i-2,d1+\"\"); list1.addAll(list.subList(i+1,list.size())); break; } } doCalc(list1); return d; } /** * 运算 * @param s1 * @param s2 * @param symbol * @return */ public static Double doTheMath(String s1,String s2,String symbol){ Double result ; switch (symbol){ case ADD : result = Double.valueOf(s1) + Double.valueOf(s2); break; case MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); break; case TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); break; case DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); break; default : result = null; } return result; }} 队列知识认识队列队列 是一种 先进先出 的数据结构，也是常见的数据结构之一。日常生活中的 排队买东西 就是一种典型的队列。 数组模拟队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130public class ArrayQueueTest { public static void main(String[] args) { // 创建一个队列 ArrayQueue arrayQueue = new ArrayQueue(3); char key = ' '; // 接收用户输入 Scanner scanner = new Scanner(System.in); boolean loop = true; while (loop) { System.out.println(\"s ：显示队列（show）\"); System.out.println(\"e ：退出程序（exit）\"); System.out.println(\"a ：添加数据到队列（add）\"); System.out.println(\"g ：从队列取出数据（get）\"); System.out.println(\"h ：查看队列头数据（head）\"); key = scanner.next().charAt(0); // 接收一个字符 switch (key) { case 's': arrayQueue.showQueue(); break; case 'e': scanner.close(); loop = false; System.out.println(\"程序已经退出！！！\"); System.exit(0); break; case 'a': System.out.println(\"请输入一个整数：\"); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case 'g': try { int queue = arrayQueue.getQueue(); System.out.printf(\"取出的数据是：%d\\n\", queue); }catch (Exception e){ System.out.println(e.getMessage()); } break; case 'h': try { int res = arrayQueue.headQueue(); System.out.printf(\"队列头的数据是：%d\\n\", res); }catch (Exception e){ System.out.println(e.getMessage()); } break; default: break; } } }}/** * 使用数组模拟队列 */class ArrayQueue { private int maxSize; // 表示数组最大容量 private int front; // 队列头 private int rear; // 队列尾 private int[] arr; // 此数组用于存放数据，模拟队列 // 01-创建队列构造器 public ArrayQueue(int arrMaxSize) { maxSize = arrMaxSize; arr = new int[maxSize]; front = -1; // 指向队列头部，即队列头的前一个位置 rear = -1; // 指向队列尾部，即队列最后一个数据 } // 02-判断队列是否满 public boolean isFull() { return rear == maxSize - 1; } // 03-判断队列是否为空 public boolean isEmpty() { return rear == front; } // 04-添加数据到队列 public void addQueue(int num) { // 判断队列是否满 if (isFull()) { System.out.println(\"队列满了，无法加入数据！！！\"); return; } rear++; // rear 后移一位 arr[rear] = num; } // 05-获取队列的数据，即出队列 public int getQueue() { // 判断队列是否为空 if (isEmpty()) { throw new RuntimeException(\"队列为空，不能取数据！！！\"); } front++; return arr[front]; } // 06-显示队列的所有数据 public void showQueue() { if (isEmpty()) { System.out.println(\"队列为空，没有数据！！！\"); } for (int i = 0; i &lt; arr.length; i++) { System.out.printf(\"arr[%d] = %d\\n\", i, arr[i]); } } // 07-显示队列的头数据 public int headQueue() { if (isEmpty()) { throw new RuntimeException(\"队列为空，没有数据！！！\"); } return arr[++front]; }} 数组模拟队列 会出现一个小问题：数组不能够重复使用 。比如队列最大值为 3 ，添加 3 个数之后然后取出，再次添加就出现了队列满的情况。为了解决这个问题，就有了环形队列。接着往下看！！！ 环形队列环形队列 就是一个环，队列头和队列尾可以循环重合 ，且避免了普通队列的缺点，就是有点难理解而已，其实它的本质仍然是一个队列，一样有队列头，队列尾。它的特点一样是 先进先出（FIFO） 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150public class ArrayCircleQueueTest { public static void main(String[] args) { // 创建一个队列，构造方法里面的参数4代表队列的有效数据最大是 3 ArrayCircleQueue arrayQueue = new ArrayCircleQueue(4); char key = ' '; // 接收用户输入 Scanner scanner = new Scanner(System.in); boolean loop = true; while (loop) { System.out.println(\"s ：显示队列（show）\"); System.out.println(\"e ：退出程序（exit）\"); System.out.println(\"a ：添加数据到队列（add）\"); System.out.println(\"g ：从队列取出数据（get）\"); System.out.println(\"h ：查看队列头数据（head）\"); key = scanner.next().charAt(0); // 接收一个字符 switch (key) { case 's': arrayQueue.showQueue(); break; case 'e': scanner.close(); loop = false; System.out.println(\"程序已经退出！！！\"); System.exit(0); break; case 'a': System.out.println(\"请输入一个整数：\"); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case 'g': try { int queue = arrayQueue.getQueue(); System.out.printf(\"取出的数据是：%d\\n\", queue); } catch (Exception e) { System.out.println(e.getMessage()); } break; case 'h': try { int res = arrayQueue.headQueue(); System.out.printf(\"队列头的数据是：%d\\n\", res); } catch (Exception e) { System.out.println(e.getMessage()); } break; default: break; } } }}/** * 使用数组模拟环形队列 */class ArrayCircleQueue { private int maxSize; // 表示数组最大容量 private int front; // 队列头 private int rear; // 队列尾 private int[] arr; // 此数组用于存放数据，模拟队列 // 01-创建队列构造器 public ArrayCircleQueue(int arrMaxSize) { maxSize = arrMaxSize; arr = new int[maxSize]; front = 0; // 指向队列头部，即队列头的前一个位置，可以不写，默认就是0 rear = 0; // 指向队列尾部，即队列最后一个数据，可以不写，默认就是0 } // 02-判断队列是否满 public boolean isFull() { return (rear + 1) % maxSize == front; } // 03-判断队列是否为空 public boolean isEmpty() { return rear == front; } // 04-添加数据到队列 public void addQueue(int num) { // 判断队列是否满 if (isFull()) { System.out.println(\"队列满了，无法加入数据！！！\"); return; } arr[rear] = num; rear = (rear + 1) % maxSize; // rear 后移一位，但是必须考虑取模 } // 05-获取队列的数据，即出队列 public int getQueue() { // 判断队列是否为空 if (isEmpty()) { throw new RuntimeException(\"队列为空，不能取数据！！！\"); } /** * 这里需要进行分析： * 1. front 是指向队列的第一个元素 * 2. 需要先把 front 的值保存到一个临时变量 * 3. 然后再将 front 后移，这里需要考虑取模，否则会报数组越界异常 * 4. 将临时保存的变量返回 */ int value = arr[front]; front = (front + 1) % maxSize; return value; } // 06-显示队列的所有数据 public void showQueue() { if (isEmpty()) { System.out.println(\"队列为空，没有数据！！！\"); } /** * 如何遍历环形队列？ * 1. 从 front 开始遍历 * 2. 遍历 (rear + maxSize - front) % maxSize 个 */ for (int i = front; i &lt; front + size(); i++) { System.out.printf(\"arr[%d] = %d\\n\", i % maxSize, arr[i % maxSize]); } } // 07-显示队列的头数据 public int headQueue() { if (isEmpty()) { throw new RuntimeException(\"队列为空，没有数据！！！\"); } return arr[front]; } // 08-求出当前队列有效数据的个数 public int size() { return (rear + maxSize - front) % maxSize; }} 递归和回溯迷宫问题 迷宫问题 代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * @Author: guoshizhan * @Create: 2020/5/29 12:03 * @Description: 迷宫问题 */public class Maze { public static void main(String[] args) { // 01-创建二维数组，模拟模拟迷宫 int[][] maze = new int[8][7]; // 02-初始化迷宫，使用 1 表示墙 for (int i = 0; i &lt; 7; i++) { maze[0][i] = 1; maze[7][i] = 1; } for (int i = 0; i &lt; 8; i++) { maze[i][0] = 1; maze[i][6] = 1; } maze[3][1] = 1; maze[3][2] = 1; // 03-打印迷宫看一下 for (int i = 0; i &lt; maze.length; i++) { for (int j = 0; j &lt; 7; j++) { System.out.print(maze[i][j] + \" \"); } System.out.println(); } // 04-找迷宫出口 findWay(maze, 1, 1); // 05-打印新迷宫 System.out.println(\"--------------\"); for (int i = 0; i &lt; maze.length; i++) { for (int j = 0; j &lt; 7; j++) { System.out.print(maze[i][j] + \" \"); } System.out.println(); } } /** * 使用递归回溯来使小球走出迷宫 * * @param maze 表示迷宫 * @param i j 表示坐标，即从那个位置出发 (1,1) * @return 如果找到通路，就返回 true ，否则返回 false * &lt;p&gt; * 补充说明： * 1. 如果小球能到达 maze[6][5], 则说明通路找到 * 2. 约定：当 maze[i][j] 为 0 表示该点没有走过，1 表示墙，2 表示可以走，3 表示高点走过，但是走不通 * 3. 走迷宫时，需要确定一个策略 ：下-&gt;右-&gt;上-&gt;左，如果该点走不通，再回溯 */ public static boolean findWay(int[][] maze, int i, int j) { if (maze[6][5] == 2) { // 通路已经找到，OK return true; } else { if (maze[i][j] == 0) { // 如果当前这个点没有走过 // 按照策略走：下-&gt;右-&gt;上-&gt;左 maze[i][j] = 2; // 假定该店可以走通 if (findWay(maze, i + 1, j)) { // 向下走 return true; } else if (findWay(maze, i, j + 1)) { // 向右走 return true; } else if (findWay(maze, i - 1, j)) { // 向上走 } else if (findWay(maze, i, j - 1)) { // 向左走 return true; } else { // 说明该店走不通，是死路 maze[i][j] = 3; return false; } } else { // 如果 maze[i][j] != 0，那么可能情况为 1，2，3，那么直接返回 false return false; } } return false; }} 八皇后问题 八皇后问题 问题代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * @Author: guoshizhan * @Create: 2020/5/29 17:12 * @Description: 八皇后问题 */public class Queue8 { // 定义一个 max 表示右多少个皇后 int max = 8; // 定义数组 array，保存处理结果，例如：arr = {0, 4, 7, 5, 2, 6, 1, 3} int[] array = new int[max]; // 用于记录解法个数 static int count = 0; // 用于记录冲突次数 static int judgeCount = 0; public static void main(String[] args) { Queue8 queue8 = new Queue8(); queue8.check(0); System.out.println(\"一共有 \" + count + \" 种解法！！！\"); System.out.println(\"一共有 \" + judgeCount + \" 次冲突！！！\"); } // 放置第 n 个皇后 private void check(int n) { if (n == max) { print(); return; } // 依此放入皇后，并判断是否冲突 for (int i = 0; i &lt; max; i++) { // 先把当前这个皇后 n ，放到该行第 1 列 array[n] = i; // 判断放置第 n 个皇后到 i 列是否冲突 if (judge(n)) { check(n + 1); } // 如果冲突，就继续执行 array[n] == i; } } // 检测当前皇后是否和前面已经摆好的皇后冲突，n 表示第 n 个皇后 private boolean judge(int n) { judgeCount++; for (int i = 0; i &lt; n; i++) { if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) { return false; } } return true; } // 将皇后摆放的位置输出 public void print() { count++; for (int i = 0; i &lt; array.length; i++) { System.out.print(array[i] + \" \"); } System.out.println(); }} 数组和广义表稀疏数组基本介绍稀疏数组 可以看做是 普通数组的压缩 ，当一个数组中 大部分元素为 0 或者为同一个值 的数组时，可以使用稀疏数组来保存该数组。 应用案例棋盘存档案例 就是一个 稀疏数组 的实际应用案例。参考下图： 案例分析 代码实现使用 稀疏数组 实现的 棋盘存档案例 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142public class SparseArray { public static void main(String[] args) throws Exception { // 01-创建一个原始的二维数组 11 * 11 , 0 表示没有棋子， 1 表示黑子 , 2 表示蓝子 int chessArray[][] = new int[11][11]; chessArray[1][2] = 1; chessArray[2][3] = 2; chessArray[4][5] = 2; // 02-输出原始的二维数组 System.out.println(\"原始的二维数组：\\n-----------------------------------------\"); for (int[] row : chessArray) { for (int data : row) { System.out.printf(\"%d\\t\", data); } System.out.println(); } // 03-遍历二维数组 得到非0数据的个数 int sum = 0; for (int i = 0; i &lt; chessArray.length; i++) { for (int j = 0; j &lt; chessArray.length; j++) { if (chessArray[i][j] != 0) { sum++; } } } // 04-创建对应的稀疏数组并赋值 int sparseArr[][] = new int[sum + 1][3]; sparseArr[0][0] = chessArray.length; sparseArr[0][1] = chessArray[0].length; sparseArr[0][2] = sum; // 05-遍历原始二维数组，将非0的值存放到 sparseArr 中 int count = 0; // count 对应稀疏数组的行，用来记录第几个非0数据 for (int i = 0; i &lt; chessArray.length; i++) { for (int j = 0; j &lt; chessArray.length; j++) { if (chessArray[i][j] != 0) { count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArray[i][j]; } } } // 06-输出稀疏数组 System.out.println(); System.out.println(\"原始二维数组转为稀疏数组后：\\n-----------------------------------------\"); for (int i = 0; i &lt; sparseArr.length; i++) { System.out.printf(\"%d\\t%d\\t%d\\t\\n\", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]); } System.out.println(); // 07-将稀疏数组恢复成原始的二维数组，思路见案例分析 int chessArr[][] = new int[sparseArr[0][0]][sparseArr[0][1]]; for (int i = 1; i &lt; sparseArr.length; i++) { chessArr[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; } // 08-输出恢复后的二维数组 System.out.println(\"从稀疏数组恢复到原始二维数组：\\n-----------------------------------------\"); for (int[] row : chessArr) { for (int data : row) { System.out.printf(\"%d\\t\", data); } System.out.println(); } System.out.println(); // 09-将稀疏数组保存到磁盘 File file = new File(\"data.txt\"); sparseToDisk(file, sparseArr); // 10-从磁盘读取稀疏数组并打印 System.out.println(\"从磁盘读取稀疏数组并打印：\\n-----------------------------------------\"); int[][] ints = diskToSparse(file, sparseArr); for (int[] anInt : ints) { for (int i : anInt) { System.out.printf(\"%d\\t\", i); } System.out.println(); } } /** * 将稀疏数组存入磁盘（文件） */ public static void sparseToDisk(File file, int[][] arr) throws IOException { if (!file.exists()) { file.createNewFile(); } FileWriter writer = new FileWriter(file); for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; 3; j++) { int num = arr[i][j]; // 把 num 装箱，方便后面的写入以及读取文件 Integer integer = new Integer(num); // 拼接空的字符串的目的：更方便读取文件，即从文件读取并还原稀疏数组 writer.write(integer.toString() + \" \"); } writer.write(\"\\r\\n\"); } writer.flush(); writer.close(); } /** * 从文件获取稀疏数组 */ public static int[][] diskToSparse(File file, int[][] arr) throws Exception { BufferedReader reader = new BufferedReader(new FileReader(file)); int[][] sparseArray = new int[arr.length][3]; for (int i = 0; i &lt; arr.length; i++) { // 读取一整行 String s = reader.readLine(); // 以空格分割字符串 String[] split = s.split(\" \"); int j = 0; for (String s1 : split) { sparseArray[i][j++] = Integer.valueOf(s1); } } reader.close(); return sparseArray; }} 树和二叉树树的初识为什么需要树 树的常用术语 二叉树二叉树的概念 二叉树的遍历 二叉树的 前序遍历 、 中序遍历 、 后序遍历 代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193/** * @Author: guoshizhan * @Create: 2020/6/29 12:50 * @Description: 二叉树的前序遍历、中序遍历和后序遍历 */public class BinaryTreeTest { public static void main(String[] args) { // 创建二叉树 BinaryTree binaryTree = new BinaryTree(); // 创建结点 Node node1 = new Node(1, \"典韦\"); Node node2 = new Node(2, \"妲己\"); Node node3 = new Node(3, \"廉颇\"); Node node4 = new Node(4, \"亚瑟\"); Node node5 = new Node(5, \"后羿\"); Node node6 = new Node(6, \"女娲\"); Node node7 = new Node(7, \"张良\"); Node node8 = new Node(8, \"刘备\"); // 构建结点之间的关系 node1.setLeft(node2); node1.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); node3.setRight(node7); node4.setLeft(node8); // 形成二叉树 binaryTree.setRoot(node1); System.out.println(\"前序遍历：\"); binaryTree.preOrder(); System.out.println(\"=======================\"); System.out.println(\"中序遍历：\"); binaryTree.infixOrder(); System.out.println(\"=======================\"); System.out.println(\"后序遍历：\"); binaryTree.postOrder(); }}// 编写二叉树类class BinaryTree { private Node root; public void setRoot(Node root) { this.root = root; } // 前序遍历 public void preOrder() { if (this.root != null) { this.root.preOrder(); } else { System.out.println(\"The Binary Tree is null !!!\"); } } // 中序遍历 public void infixOrder() { if (this.root != null) { this.root.infixOrder(); } else { System.out.println(\"The Binary Tree is null !!!\"); } } // 后序遍历 public void postOrder() { if (this.root != null) { this.root.postOrder(); } else { System.out.println(\"The Binary Tree is null !!!\"); } } }// 编写结点类class Node { private int no; private String name; private Node left; private Node right; public Node(int no, String name) { this.no = no; this.name = name; } public int getNo() { return no; } @Override public String toString() { return \"Node{\" + \"no=\" + no + \", name='\" + name + '\\'' + '}'; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Node getLeft() { return left; } public void setLeft(Node left) { this.left = left; } public Node getRight() { return right; } public void setRight(Node right) { this.right = right; } // 编写前序遍历方法 public void preOrder() { // 输出父结点 System.out.println(this); // 递归向左子树前序遍历 if (this.left != null) { this.left.preOrder(); } // 递归向右子树前序遍历 if (this.right != null) { this.right.preOrder(); } } // 编写中序遍历方法 public void infixOrder() { // 递归向左子树前序遍历 if (this.left != null) { this.left.infixOrder(); } // 输出父结点 System.out.println(this); // 递归向右子树前序遍历 if (this.right != null) { this.right.infixOrder(); } } // 编写后序遍历方法 public void postOrder() { // 递归向左子树前序遍历 if (this.left != null) { this.left.postOrder(); } // 递归向右子树前序遍历 if (this.right != null) { this.right.postOrder(); } // 输出父结点 System.out.println(this); } } 二叉树的查找 查找要求： 1、请编写前序查找，中序查找和后序查找的方法。 2、分别使用三种查找方式，查找 heroNO = 5 的节点 3、分析各种查找方式，分别比较了多少次 二叉树的 三种查找方式 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160/** * 以下三种遍历查找的方法写在 Node 类中 */ // 前序遍历查找public Node preOrderSearch(int no) { System.out.println(\"前序遍历次数~~~\"); if (this.no == no) { return this; } // 判断当前结点的左子结点是否为空，如果不为空，则递归前序遍历。找到结点则返回 Node resNode = null; if (this.left != null) { resNode = this.left.preOrderSearch(no); } // 如果找到，就返回 resNode if (resNode != null) { return resNode; } // 如果没有找到，则向右递归 if (this.right != null) { resNode = this.right.preOrderSearch(no); } return resNode;}// 中序遍历查找public Node infixOrderSearch(int no) { // 判断当前结点的左子结点是否为空，如果不为空，则递归前序遍历。找到结点则返回 Node resNode = null; if (this.left != null) { resNode = this.left.infixOrderSearch(no); } // 如果找到，就返回 resNode if (resNode != null) { return resNode; } System.out.println(\"中序遍历次数~~~\"); if (this.no == no) { return this; } // 如果没有找到，则向右递归 if (this.right != null) { resNode = this.right.infixOrderSearch(no); } return resNode;}// 后序遍历查找public Node postOrderSearch(int no) { // 判断当前结点的左子结点是否为空，如果不为空，则递归前序遍历。找到结点则返回 Node resNode = null; if (this.left != null) { resNode = this.left.postOrderSearch(no); } // 如果找到，就返回 resNode if (resNode != null) { return resNode; } // 如果没有找到，则向右递归 if (this.right != null) { resNode = this.right.postOrderSearch(no); } // 如果左右子树都没有找到，就比较当前结点 System.out.println(\"后序遍历次数~~~\"); if (this.no == no) { return this; } return resNode;}/** * 以下三种遍历查找的方法写在 BinaryTree 类中 */// 前序遍历查找public Node preOrderSearch(int no) { if (root != null) { return root.preOrderSearch(no); } else { return null; }}// 前序遍历查找public Node infixOrderSearch(int no) { if (root != null) { return root.infixOrderSearch(no); } else { return null; }}// 前序遍历查找public Node postOrderSearch(int no) { if (root != null) { return root.postOrderSearch(no); } else { return null; }}/** * 以下代码写在 BinaryTreeTest 类的 main 方法中 */// 前序遍历查找System.out.println(\"前序遍历查找：\");int findNum = 5;Node resNode1 = binaryTree.preOrderSearch(findNum);if (resNode1 != null) { System.out.printf(\"查找成功，信息为：no = %d , name = %s\", resNode1.getNo(), resNode1.getName());} else { System.out.printf(\"没有找到编号为 %d 的结点！！！\", findNum);}System.out.println(\"\\n====================================\");// 中序遍历查找System.out.println(\"中序遍历查找：\");Node resNode2 = binaryTree.infixOrderSearch(findNum);if (resNode2 != null) { System.out.printf(\"查找成功，信息为：no = %d , name = %s\", resNode2.getNo(), resNode2.getName());} else { System.out.printf(\"没有找到编号为 %d 的结点！！！\", findNum);}System.out.println(\"\\n====================================\");// 后序遍历查找System.out.println(\"后序遍历查找：\");Node resNode3 = binaryTree.postOrderSearch(findNum);if (resNode3 != null) { System.out.printf(\"查找成功，信息为：no = %d , name = %s\", resNode3.getNo(), resNode3.getName());} else { System.out.printf(\"没有找到编号为 %d 的结点！！！\", findNum);} 二叉树的删除 注意： 非叶子结点的 删除操作 遵照上图的规定，不同的删除策略会导致结果不同。 二叉树的 删除操作 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 删除结点，此方法加入到 Node 类中public void delNode(int no) { if (this.left != null &amp;&amp; this.left.no == no) { this.left = null; return; } if (this.right != null &amp;&amp; this.right.no == no) { this.right = null; return; } if (this.left != null) { this.left.delNode(no); } if (this.right != null) { this.right.delNode(no); }}// 删除结点，此方法加入到 BinaryTree 类中public void delNode(int no) { if (root != null) { if (root.getNo() == no) { root = null; } else { root.delNode(no); } } else { System.out.println(\"空树，不能删除！！！\"); }}// 以下代码加入到 BinaryTreeTest 类中的 main方法中System.out.println(\"删除前：\");binaryTree.preOrder();binaryTree.delNode(findNum);System.out.println(\"删除后：\");binaryTree.preOrder(); 顺序存储二叉树 顺序存储二叉树 代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @Author: guoshizhan * @Create: 2020/6/29 20:56 * @Description: 顺序存储二叉树的遍历 */public class ArrayBinaryTreeTest { public static void main(String[] args) { int[] arr = {1, 2, 3, 4, 5, 6, 7}; ArrayBinaryTree arrayBinaryTree = new ArrayBinaryTree(arr); arrayBinaryTree.preOrder(); }}// 编写 ArrayBinaryTree 类，实现顺序存储二叉树的遍历class ArrayBinaryTree { // 存储数据结点的数组 private int[] arr; public ArrayBinaryTree(int[] arr) { this.arr = arr; } // 重载 preOrder 方法 public void preOrder() { this.preOrder(0); } // 编写一个方法，完成顺手二叉树的前序遍历，index 是数组的索引 public void preOrder(int index) { if (arr == null || arr.length == 0) { System.out.println(\"The array is empty !!!\"); } System.out.println(arr[index]); // 向左递归 if ((index * 2 + 1) &lt; arr.length) { preOrder(2 * index + 1); } // 向右递归 if ((index * 2 + 2) &lt; arr.length) { preOrder(2 * index + 2); } }}/** 输出结果： * 1 * 2 * 4 * 5 * 3 * 6 * 7 */ 线索化二叉树在二叉树的结点上加上线索的二叉树 称为 线索二叉树 ，对二叉树以某种遍历方式（如先序、中序、后序或层次等）进行遍历，使其变为线索二叉树的过程称为对二叉树进行线索化。 【———— 百度百科】 线索化应用案例 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395/** * @Author: guoshizhan * @Create: 2020/7/4 14:35 * @Description: 线索化二叉树 */public class ThreadedBinaryTreeTest { public static void main(String[] args) { // 测试中序线索二叉树 Node node1 = new Node(1, \"典韦\"); Node node2 = new Node(3, \"廉颇\"); Node node3 = new Node(6, \"女娲\"); Node node4 = new Node(8, \"刘备\"); Node node5 = new Node(10, \"妲己\"); Node node6 = new Node(14, \"亚瑟\"); node1.setLeft(node2); node1.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); ThreadedBinaryTree tbt = new ThreadedBinaryTree(); tbt.setRoot(node1); tbt.threadedNode(); // 查看结果，以 10 号节点为例 Node leftNode = node5.getLeft(); Node rightNode = node5.getRight(); System.out.println(\"10 号节点的前驱结点是： \" + leftNode); System.out.println(\"10 号节点的后继结点是： \" + rightNode); }}// 编写线索化二叉树类class ThreadedBinaryTree { private Node root; private Node pre = null; // 指向当前节点的前驱结点 public void setRoot(Node root) { this.root = root; } public void threadedNode() { this.threadedNode(root); } // 编写 “中序线索化” 方法，node 表示需要线索化的结点 public void threadedNode(Node node) { // 如果 node == null ，无法线索化 if (node == null) { System.out.println(\"node is null, so it is not be operated !!!\"); return; } /** * 中序线索化思路分析： * 1、先线索化左子树 * 2、再线索化当前节点【这是重点，也是难点】 * 3、最后线索化右子树 */ // 1、先线索化左子树 threadedNode(node.getLeft()); // 2、再线索化当前节点【这是重点，也是难点】 if (node.getLeft() == null) { node.setLeft(pre); // 让节点的左指针指向前驱结点 node.setLeftType(1); // 修改当前节点的左指针类型，指向前驱结点 } // 处理后继节点 if (pre != null &amp;&amp; pre.getRight() == null) { pre.setRight(node); pre.setRightType(1); } // 每处理一个节点，就让当前节点成为下一个节点的前驱结点 pre = node; // 3、最后线索化右子树 threadedNode(node.getRight()); } // 前序遍历 public void preOrder() { if (this.root != null) { this.root.preOrder(); } else { System.out.println(\"The Binary Tree is null !!!\"); } } // 中序遍历 public void infixOrder() { if (this.root != null) { this.root.infixOrder(); } else { System.out.println(\"The Binary Tree is null !!!\"); } } // 后序遍历 public void postOrder() { if (this.root != null) { this.root.postOrder(); } else { System.out.println(\"The Binary Tree is null !!!\"); } } // 前序遍历查找 public Node preOrderSearch(int no) { if (root != null) { return root.preOrderSearch(no); } else { return null; } } // 前序遍历查找 public Node infixOrderSearch(int no) { if (root != null) { return root.infixOrderSearch(no); } else { return null; } } // 前序遍历查找 public Node postOrderSearch(int no) { if (root != null) { return root.postOrderSearch(no); } else { return null; } } // 删除结点 public void delNode(int no) { if (root != null) { if (root.getNo() == no) { root = null; } else { root.delNode(no); } } else { System.out.println(\"空树，不能删除！！！\"); } }}// 编写结点类class Node { private int no; private String name; private Node left; private Node right; /** * 定义说明： * 1、leftType == 0 表示指向的是左子树，leftType == 1 表示指向的是前驱结点 * 2、rightType == 0 表示指向的是右子树，rightType == 1 表示指向的是后继结点 */ private int leftType; private int rightType; public int getLeftType() { return leftType; } public void setLeftType(int leftType) { this.leftType = leftType; } public int getRightType() { return rightType; } public void setRightType(int rightType) { this.rightType = rightType; } public Node(int no, String name) { this.no = no; this.name = name; } public int getNo() { return no; } @Override public String toString() { return \"Node{\" + \"no=\" + no + \", name='\" + name + '\\'' + '}'; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Node getLeft() { return left; } public void setLeft(Node left) { this.left = left; } public Node getRight() { return right; } public void setRight(Node right) { this.right = right; } // 编写前序遍历方法 public void preOrder() { // 输出父结点 System.out.println(this); // 递归向左子树前序遍历 if (this.left != null) { this.left.preOrder(); } // 递归向右子树前序遍历 if (this.right != null) { this.right.preOrder(); } } // 编写中序遍历方法 public void infixOrder() { // 递归向左子树前序遍历 if (this.left != null) { this.left.infixOrder(); } // 输出父结点 System.out.println(this); // 递归向右子树前序遍历 if (this.right != null) { this.right.infixOrder(); } } // 编写后序遍历方法 public void postOrder() { // 递归向左子树前序遍历 if (this.left != null) { this.left.postOrder(); } // 递归向右子树前序遍历 if (this.right != null) { this.right.postOrder(); } // 输出父结点 System.out.println(this); } // 前序遍历查找 public Node preOrderSearch(int no) { System.out.println(\"前序遍历次数~~~\"); if (this.no == no) { return this; } // 判断当前结点的左子结点是否为空，如果不为空，则递归前序遍历。找到结点则返回 Node resNode = null; if (this.left != null) { resNode = this.left.preOrderSearch(no); } // 如果找到，就返回 resNode if (resNode != null) { return resNode; } // 如果没有找到，则向右递归 if (this.right != null) { resNode = this.right.preOrderSearch(no); } return resNode; } // 中序遍历查找 public Node infixOrderSearch(int no) { // 判断当前结点的左子结点是否为空，如果不为空，则递归前序遍历。找到结点则返回 Node resNode = null; if (this.left != null) { resNode = this.left.infixOrderSearch(no); } // 如果找到，就返回 resNode if (resNode != null) { return resNode; } System.out.println(\"中序遍历次数~~~\"); if (this.no == no) { return this; } // 如果没有找到，则向右递归 if (this.right != null) { resNode = this.right.infixOrderSearch(no); } return resNode; } // 后序遍历查找 public Node postOrderSearch(int no) { // 判断当前结点的左子结点是否为空，如果不为空，则递归前序遍历。找到结点则返回 Node resNode = null; if (this.left != null) { resNode = this.left.postOrderSearch(no); } // 如果找到，就返回 resNode if (resNode != null) { return resNode; } // 如果没有找到，则向右递归 if (this.right != null) { resNode = this.right.postOrderSearch(no); } // 如果左右子树都没有找到，就比较当前结点 System.out.println(\"后序遍历次数~~~\"); if (this.no == no) { return this; } return resNode; } // 删除结点 public void delNode(int no) { if (this.left != null &amp;&amp; this.left.no == no) { this.left = null; return; } if (this.right != null &amp;&amp; this.right.no == no) { this.right = null; return; } if (this.left != null) { this.left.delNode(no); } if (this.right != null) { this.right.delNode(no); } }} 线索化二叉树构建好了，那么如何遍历呢。如下图： 线索化二叉树的遍历 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 把以下语句写在 ThreadedBinaryTreeTest 类的 main 方法里面 */ tbt.threadedList();/** * 把以下方法写在 ThreadedBinaryTree 类里面 */ // 遍历中序线索化二叉树public void threadedList() { // 定义一个变量，存储当前遍历的节点，从 root 开始 Node temp = root; while (temp != null) { // 1、一直循环，直到找到 leftType == 1 的结点，第一个找到的是 8 号结点 // 2、后面随着遍历而变化，因为当 leftType == 1 时，说明该节点是线索化的 while (temp.getLeftType() == 0) { temp = temp.getLeft(); } // 打印当前节点 System.out.println(temp); // 如果当前节点的右指针指向的是后继结点，就一直输出 while (temp.getRightType() == 1){ // 获取当前节点的后继节点 temp = temp.getRight(); System.out.println(temp); } // 替换这个遍历的节点 temp = temp.getRight(); }}/** * 输出结果： * Node{no=8, name='刘备'} * Node{no=3, name='廉颇'} * Node{no=10, name='妲己'} * Node{no=1, name='典韦'} * Node{no=14, name='亚瑟'} * Node{no=6, name='女娲'} */ 树的应用-堆堆的介绍堆(Heap) 是计算机科学中一类特殊的数据结构的统称。 堆 通常是一个可以被看做一棵 完全二叉树 的数组对象。【———— 百度百科】 堆的算法思想： 不必将值一个个地插入堆中，通过交换形成堆。假设一个小根堆的左、右子树都已是堆，并且根的元素名为 root ，其左右子节点为 left 和 right ，这种情况下，有两种可能： root &lt;= left 并且 root &lt;= right ，此时堆已完成； root &gt;= left 或者 root &gt;= right ，此时 root 应与两个子女中值较小的一个交换，结果得到一个堆，除非 root 仍然大于其新子女的一个或全部的两个。这种情况下，我们只需简单地继续这种将 root “拉下来”的过程，直至到达某一个层使它小于它的子女，或者它成了叶结点。 堆排序堆排序 是一种选择排序 ，是利用 堆 这种数据结构而设计的一种排序算法。具体介绍如下图： 堆排序 的代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @Author: guoshizhan * @Create: 2020/7/4 22:53 * @Description: 堆排序 */public class HeapSort { public static void main(String[] args) { // 要求堆数组进行升序排序 int[] arr = {4, 6, 8, 5, 9}; heapSort(arr); } // 编写一个堆排序方法 public static void heapSort(int[] arr) { int temp = 0; System.out.println(\"堆排序！\"); // 将无序序列构成堆 for (int i = arr.length / 2 - 1; i &gt;= 0; i--) { adjustHeap(arr, i, arr.length); } for (int j = arr.length - 1; j &gt; 0; j--) { temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); } System.out.println(Arrays.toString(arr)); // [4, 5, 6, 8, 9] } /** * 将一个数组（二叉树）调整成大顶堆 * * @param arr 代表待调整数组 * @param i 代表非叶子节点再数组中的索引 * @param length 表示堆多少个数组继续调整，length 是逐渐减少的 */ public static void adjustHeap(int[] arr, int i, int length) { int temp = arr[i]; // 取出当前元素的值，保存于 temp 中 // 开始调整。k 是 i 节点的左子节点 for (int k = 2 * i + 1; k &lt; length; k = k * 2 + 1) { if ((k + 1) &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) { // 说明左子节点小于右子节点 k++; } if (arr[k] &gt; temp) { // 如果子节点大于父节点 arr[i] = arr[k]; // 把较大的值赋给当前节点 i = k; // i 指向 k ，继续比较 } else { break; } } // 当 for 循环结束后，我们已经将以 i 为父节点的树的最大值放到了最顶（局部，还不一定是大顶堆） arr[i] = temp; }} 堆排序的性能测试 代码如下： 1234567891011121314151617181920public static void main(String[] args) { // 要求堆数组进行升序排序 int[] arr = new int[8000000]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = (int)(Math.random() * 100000 + 1); } long start = System.currentTimeMillis(); heapSort(arr); long end = System.currentTimeMillis(); System.out.println(\"排序 800 万个数据需要 \" + (end - start) / 1000 + \" 秒 \" + (end - start) % 1000 + \" 毫秒\");}/** * 测试结果（平均时间：2s~3s）： * 堆排序！ * 排序 800 万个数据需要 2 秒 441 毫秒 */ 赫夫曼树基本介绍赫夫曼树的基本介绍 如下图： 赫夫曼树的构建 赫夫曼树的构建 的代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * @Author: guoshizhan * @Create: 2020/7/5 9:26 * @Description: 哈夫曼树的构建 */public class HuffmanTree { public static void main(String[] args) { int[] arr = {13, 7, 8, 3, 29, 6, 1}; Node root = createHuffmanTree(arr); preOrder(root); } public static void preOrder(Node root) { if (root != null) { root.preOrder(); } else { System.out.println(\"该赫夫曼树是空树，无法遍历~~~\"); } } // 创建赫夫曼树的方法 public static Node createHuffmanTree(int[] arr) { List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); for (int value : arr) { nodes.add(new Node(value)); } while (nodes.size() &gt; 1) { Collections.sort(nodes); Node leftNode = nodes.get(0); // 取出权值最小的节点 Node rightNode = nodes.get(1); // 取出权值第二小的节点 Node parent = new Node(leftNode.value + rightNode.value); parent.left = leftNode; parent.right = rightNode; nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parent); } return nodes.get(0); }}// 创建 Node 节点类。为了能够持续排序，需要实现 Comparable 接口class Node implements Comparable&lt;Node&gt; { int value; // 节点权值 Node left; // 指向左子树或左子节点 Node right; // 指向右子树或右子节点 // 前序遍历 public void preOrder() { System.out.println(this); if (this.left != null) { this.left.preOrder(); } if (this.right != null) { this.right.preOrder(); } } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } public Node(int value) { this.value = value; } @Override public int compareTo(Node o) { // 表示从小到大排序 return this.value - o.value; }} 赫夫曼编码基本介绍和原理赫夫曼编码的基本介绍和原理 如下图： 赫夫曼应用-数据压缩 数据压缩第一步： 把字符串转化为赫夫曼树。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * @Author: guoshizhan * @Create: 2020/7/5 17:07 * @Description: 赫夫曼应用之数据压缩 */public class HuffmanCode { public static void main(String[] args) { String str = \"i like like like java do you like a java\"; byte[] bytes = str.getBytes(); System.out.println(bytes.length); List&lt;Node&gt; nodes = getNodes(bytes); Node root = createHuffmanTree(nodes); root.preOrder(); } public static List&lt;Node&gt; getNodes(byte[] bytes) { List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); Map&lt;Byte, Integer&gt; map = new HashMap&lt;&gt;(); // 遍历 bytes ，统计每一个 byte 出现的次数 for (byte val : bytes) { Integer count = map.get(val); if (count == null) { map.put(val, 1); } else { map.put(val, count + 1); } } // 把每一个键值对转换成 Node 对象，并加入到 nodes 集合 for (Map.Entry&lt;Byte, Integer&gt; entry : map.entrySet()) { nodes.add(new Node(entry.getKey(), entry.getValue())); } return nodes; } // 通过 list 创建对应的赫夫曼树 public static Node createHuffmanTree(List&lt;Node&gt; nodes) { while (nodes.size() &gt; 1) { Collections.sort(nodes); Node leftNode = nodes.get(0); // 取出权值最小的节点 Node rightNode = nodes.get(1); // 取出权值第二小的节点 Node parent = new Node(null, leftNode.weight + rightNode.weight); parent.left = leftNode; parent.right = rightNode; nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parent); } return nodes.get(0); }}class Node implements Comparable&lt;Node&gt; { Byte data; // 存放字符本身，比如 'a' =&gt; 97 int weight; // 存放权值，表示字符出现的个数 Node left; // 指向左子树或左子节点 Node right; // 指向右子树或右子节点 public Node(Byte data, int weight) { this.data = data; this.weight = weight; } @Override public String toString() { return \"Node{\" + \"data=\" + data + \", weight=\" + weight + '}'; } @Override public int compareTo(Node o) { return this.weight - o.weight; } // 前序遍历 public void preOrder() { System.out.println(this); if (this.left != null) { this.left.preOrder(); } if (this.right != null) { this.right.preOrder(); } }} 数据压缩第二步： 根据赫夫曼树生成赫夫曼编码。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 以下所有方法都写在 HuffmanCode 类中 */public static void main(String[] args) { String str = \"i like like like java do you like a java\"; byte[] bytes = str.getBytes(); System.out.println(bytes.length); List&lt;Node&gt; nodes = getNodes(bytes); Node root = createHuffmanTree(nodes); root.preOrder(); getCodes(root); System.out.println(huffmanCodes);}// 重载 getCodes 方法，方便使用public static Map&lt;Byte, String&gt; getCodes(Node root) { if (root == null) { return null; } // 处理 root 左子树 getCodes(root.left, \"0\", stringBuilder); // 处理 root 右子树 getCodes(root.right, \"1\", stringBuilder); return huffmanCodes;}// 生成赫夫曼树对应的赫夫曼编码，将赫夫曼编码放在 Map&lt;Byte, String&gt; 中static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;&gt;();// 在生成的赫夫曼编码表时，需要拼接路径，所以定义一个 StringBuilderstatic StringBuilder stringBuilder = new StringBuilder();/** * 得到赫夫曼编码，并存入 huffmanCodes 集合中 * @param node 传入的节点 * @param code 表示路径：左子节点是 0 ，右子节点是 1 * @param stringBuilder 用于拼接路径 */public static void getCodes(Node node, String code, StringBuilder stringBuilder) { StringBuilder stringBuilder1 = new StringBuilder(stringBuilder); stringBuilder1.append(code); // 将 code 加入到 stringBuilder1 if (node != null) { // 如果 node == null ，那么就不处理 if (node.data == null) { // 非叶子节点 // 向左递归 getCodes(node.left, \"0\", stringBuilder1); // 向右递归 getCodes(node.right, \"1\", stringBuilder1); } else { // 说明是一个叶子节点 huffmanCodes.put(node.data, stringBuilder1.toString()); } }} 数据压缩第三步： 根据赫夫曼编码压缩数据（无损压缩）。 完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227/** * @Author: guoshizhan * @Create: 2020/7/5 17:07 * @Description: 赫夫曼应用之数据压缩 */public class HuffmanCode { public static void main(String[] args) { String str = \"i like like like java do you like a java\"; byte[] bytes = str.getBytes(); System.out.println(\"压缩前的长度是：\" + bytes.length); /*List&lt;Node&gt; nodes = getNodes(bytes); Node root = createHuffmanTree(nodes); root.preOrder(); getCodes(root); System.out.println(huffmanCodes); byte[] zip = zip(bytes, huffmanCodes); System.out.println(Arrays.toString(zip));*/ byte[] huffmanBytes = huffmanZip(bytes); System.out.println(\"压缩后的结果是：\" + Arrays.toString(huffmanBytes)); System.out.println(\"压缩后的长度是：\" + huffmanBytes.length); System.out.println(\"求出的压缩率是：\" + (float) (bytes.length - huffmanBytes.length) / bytes.length * 100 + \"%\"); } public static byte[] huffmanZip(byte[] bytes) { List&lt;Node&gt; nodes = getNodes(bytes); // 根据 nodes 创建的赫夫曼树 Node root = createHuffmanTree(nodes); // 对应的赫夫曼编码 Map&lt;Byte, String&gt; huffmanCodes = getCodes(root); // 根据赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组 byte[] huffmanCodeBytes = zip(bytes, huffmanCodes); // 返回字节数组 return huffmanCodeBytes; } /** * 将字符串对应的 byte[] 数组，通过生成的赫夫曼编码表，返回一个压缩后的 byte[] * @param bytes 原始的字符串对应的 byte[] * @param huffmanCodes 生成的赫夫曼编码 map * @return 返回赫夫曼编码处理后的 byte[] */ public static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) { // 利用 huffmanCodes 将 bytes 转成赫夫曼编码对应的字符串 StringBuilder stringBuilder = new StringBuilder(); // 遍历 bytes 数组 for (byte aByte : bytes) { stringBuilder.append(huffmanCodes.get(aByte)); } /*// 1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100 System.out.println(stringBuilder.toString());*/ // 统计返回 byte[] huffmanCodeBytes 的长度 int len; if (stringBuilder.length() % 8 == 0) { len = stringBuilder.length() / 8; } else { len = stringBuilder.length() / 8 + 1; } // 创建存储压缩后的 byte 数组 huffmanCodeBytes byte[] huffmanCodeBytes = new byte[len]; int index = 0; for (int i = 0; i &lt; stringBuilder.length(); i += 8) { String strByte; if (i + 8 &gt; stringBuilder.length()) { strByte = stringBuilder.substring(i); } else { strByte = stringBuilder.substring(i, i + 8); } // 将 strByte 转成一个 byte ，放入到 huffmanCodeBytes 数组中 huffmanCodeBytes[index] = (byte) Integer.parseInt(strByte, 2); index++; } return huffmanCodeBytes; } // 重载 getCodes 方法，方便使用 public static Map&lt;Byte, String&gt; getCodes(Node root) { if (root == null) { return null; } // 处理 root 左子树 getCodes(root.left, \"0\", stringBuilder); // 处理 root 右子树 getCodes(root.right, \"1\", stringBuilder); return huffmanCodes; } // 生成赫夫曼树对应的赫夫曼编码，将赫夫曼编码放在 Map&lt;Byte, String&gt; 中 static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;&gt;(); // 在生成的赫夫曼编码表时，需要拼接路径，所以定义一个 StringBuilder static StringBuilder stringBuilder = new StringBuilder(); /** * 得到赫夫曼编码，并存入 huffmanCodes 集合中 * @param node 传入的节点 * @param code 表示路径：左子节点是 0 ，右子节点是 1 * @param stringBuilder 用于拼接路径 */ public static void getCodes(Node node, String code, StringBuilder stringBuilder) { StringBuilder stringBuilder1 = new StringBuilder(stringBuilder); stringBuilder1.append(code); // 将 code 加入到 stringBuilder1 if (node != null) { // 如果 node == null ，那么就不处理 if (node.data == null) { // 非叶子节点 // 向左递归 getCodes(node.left, \"0\", stringBuilder1); // 向右递归 getCodes(node.right, \"1\", stringBuilder1); } else { // 说明是一个叶子节点 huffmanCodes.put(node.data, stringBuilder1.toString()); } } } public static List&lt;Node&gt; getNodes(byte[] bytes) { List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); Map&lt;Byte, Integer&gt; map = new HashMap&lt;&gt;(); // 遍历 bytes ，统计每一个 byte 出现的次数 for (byte val : bytes) { Integer count = map.get(val); if (count == null) { map.put(val, 1); } else { map.put(val, count + 1); } } // 把每一个键值对转换成 Node 对象，并加入到 nodes 集合 for (Map.Entry&lt;Byte, Integer&gt; entry : map.entrySet()) { nodes.add(new Node(entry.getKey(), entry.getValue())); } return nodes; } // 通过 list 创建对应的赫夫曼树 public static Node createHuffmanTree(List&lt;Node&gt; nodes) { while (nodes.size() &gt; 1) { Collections.sort(nodes); Node leftNode = nodes.get(0); // 取出权值最小的节点 Node rightNode = nodes.get(1); // 取出权值第二小的节点 Node parent = new Node(null, leftNode.weight + rightNode.weight); parent.left = leftNode; parent.right = rightNode; nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parent); } return nodes.get(0); }}class Node implements Comparable&lt;Node&gt; { Byte data; // 存放字符本身，比如 'a' =&gt; 97 int weight; // 存放权值，表示字符出现的个数 Node left; // 指向左子树或左子节点 Node right; // 指向右子树或右子节点 public Node(Byte data, int weight) { this.data = data; this.weight = weight; } @Override public String toString() { return \"Node{\" + \"data=\" + data + \", weight=\" + weight + '}'; } @Override public int compareTo(Node o) { return this.weight - o.weight; } // 前序遍历 public void preOrder() { System.out.println(this); if (this.left != null) { this.left.preOrder(); } if (this.right != null) { this.right.preOrder(); } }} 赫夫曼应用-数据解压 数据的解压 的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * 将以下代码全部写入到 HuffmanCode 类中，main 方法将替换原先的 main 方法 */public static void main(String[] args) { String str = \"i like like like java do you like a java\"; byte[] bytes = str.getBytes(); System.out.println(\"压缩前的长度是：\" + bytes.length); /*List&lt;Node&gt; nodes = getNodes(bytes); Node root = createHuffmanTree(nodes); root.preOrder(); getCodes(root); System.out.println(huffmanCodes); byte[] zip = zip(bytes, huffmanCodes); System.out.println(Arrays.toString(zip));*/ byte[] huffmanBytes = huffmanZip(bytes); System.out.println(\"压缩后的结果是：\" + Arrays.toString(huffmanBytes)); System.out.println(\"压缩后的长度是：\" + huffmanBytes.length); System.out.println(\"求出的压缩率是：\" + (float) (bytes.length - huffmanBytes.length) / bytes.length * 100 + \"%\"); byte[] sourceStr = decode(huffmanCodes, huffmanBytes); System.out.println(new String(sourceStr));}/** * 数据的解压： * 1、将压缩后的字节数组转化成二进制字符串 * 2、将二进制字符串转化成对应的赫夫曼编码 * 3、将赫夫曼编码转化成最开始的数据，即 i like like …… * 4、huffmanCodes 表示赫夫曼编码表 map ，huffmanBytes 表示赫夫曼编码后得到的压缩数组 * 5、返回值就是初始字符串所对应的数组 */public static byte[] decode(Map&lt;Byte, String&gt; huffmanCodes, byte[] huffmanBytes) { StringBuilder stringBuilder = new StringBuilder(); // 将 byte 数组转成二进制的字符串 for (int i = 0; i &lt; huffmanBytes.length; i++) { byte huffmanByte = huffmanBytes[i]; // 判断是不是最后一个字节 boolean flag = (i == huffmanBytes.length - 1); stringBuilder.append(byteToBitString(!flag, huffmanByte)); } System.out.println(stringBuilder.toString()); // 把字符串按照指定的赫夫曼编码进行节码 Map&lt;String, Byte&gt; map = new HashMap&lt;&gt;(); for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) { map.put(entry.getValue(), entry.getKey()); } System.out.println(map); List&lt;Byte&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; stringBuilder.length();) { int count = 1; boolean flag = true; Byte b = null; while (flag) { String key = stringBuilder.substring(i, i + count); b = map.get(key); if (b == null) { // 没有匹配到 count++; } else { // 匹配到了 flag = false; } } list.add(b); i += count; } byte[] bytes = new byte[list.size()]; for (int i = 0; i &lt; bytes.length; i++) { bytes[i] = list.get(i); } return bytes;}// 将一个 byte 转成一个二进制的字符串public static String byteToBitString(boolean flag, byte b) { // 使用变量保存 b ，将 b 转成 int 类型 int temp = b; // 如果是整数，存在补高位。这里和 原码、反码和补码有关 if (flag) { temp |= 256; } String str = Integer.toBinaryString(temp); if (flag) { return str.substring(str.length() - 8); } else { return str; }} 赫夫曼应用-文件压缩课件图片下载 课件图片下载 文件压缩 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 将以下代码全部写入到 HuffmanCode 类中，main 方法将替换原先的 main 方法 */public static void main(String[] args) { String str = \"i like like like java do you like a java\"; byte[] bytes = str.getBytes(); System.out.println(\"压缩前的长度是：\" + bytes.length); /*List&lt;Node&gt; nodes = getNodes(bytes); Node root = createHuffmanTree(nodes); root.preOrder(); getCodes(root); System.out.println(huffmanCodes); byte[] zip = zip(bytes, huffmanCodes); System.out.println(Arrays.toString(zip));*/ /*byte[] huffmanBytes = huffmanZip(bytes); System.out.println(\"压缩后的结果是：\" + Arrays.toString(huffmanBytes)); System.out.println(\"压缩后的长度是：\" + huffmanBytes.length); System.out.println(\"求出的压缩率是：\" + (float) (bytes.length - huffmanBytes.length) / bytes.length * 100 + \"%\"); byte[] sourceStr = decode(huffmanCodes, huffmanBytes); System.out.println(new String(sourceStr));*/ String src = \"F:\\\\src.jpg\"; String desc = \"F:\\\\dest.zip\"; zipFile(src, desc);}/** * 将一个文件进行压缩 * * @param srcFile 需要压缩的文件的全路径 * @param destFile 压缩后，压缩文件的保存目录 */public static void zipFile(String srcFile, String destFile) { // 创建文输出流 OutputStream os = null; ObjectOutputStream oos = null; // 创建文件输入流 FileInputStream fis = null; try { fis = new FileInputStream(srcFile); // 创建一个和源文件大小一样的 byte[] 数组 byte[] bytes = new byte[fis.available()]; // 读取文件 fis.read(bytes); // 对文件压缩 byte[] huffmanBytes = huffmanZip(bytes); // 创建文件输出流，存放压缩文件 os = new FileOutputStream(destFile); // 创建一个和文件输出流关联的 ObjectOutputStream oos = new ObjectOutputStream(os); // 把赫夫曼编码后的字节数组写入压缩文件 oos.writeObject(huffmanBytes); // 这里我们以对象流的方式写入赫夫曼编码，是为了以后我们恢复源文件时使用。注意：一定要把赫夫曼编码写入压缩文件 oos.writeObject(huffmanCodes); } catch (Exception e) { System.out.println(e.getMessage()); } finally { try { oos.close(); os.close(); fis.close(); } catch (Exception e) { System.out.println(e.getMessage()); } }} 赫夫曼应用-文件解压 文件解压 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 将以下代码全部写入到 HuffmanCode 类中，main 方法将替换原先的 main 方法 */public static void main(String[] args) { String str = \"i like like like java do you like a java\"; byte[] bytes = str.getBytes(); System.out.println(\"压缩前的长度是：\" + bytes.length); /*List&lt;Node&gt; nodes = getNodes(bytes); Node root = createHuffmanTree(nodes); root.preOrder(); getCodes(root); System.out.println(huffmanCodes); byte[] zip = zip(bytes, huffmanCodes); System.out.println(Arrays.toString(zip));*/ /*byte[] huffmanBytes = huffmanZip(bytes); System.out.println(\"压缩后的结果是：\" + Arrays.toString(huffmanBytes)); System.out.println(\"压缩后的长度是：\" + huffmanBytes.length); System.out.println(\"求出的压缩率是：\" + (float) (bytes.length - huffmanBytes.length) / bytes.length * 100 + \"%\"); byte[] sourceStr = decode(huffmanCodes, huffmanBytes); System.out.println(new String(sourceStr));*/ String src = \"F:\\\\src.jpg\"; String desc = \"F:\\\\dest.zip\"; //zipFile(src, desc); unZipFile(desc, src);}/** * 将一个文件进行解压操作 * * @param zipFile 准备解压的文件 * @param destFile 将文件解压到哪个路径 */public static void unZipFile(String zipFile, String destFile) { // 定义文件输入流 InputStream is = null; // 定义一个输入流对象 ObjectInputStream ois = null; // 定义文件的输入流 OutputStream os = null; try { // 创建文件输入流 is = new FileInputStream(zipFile); // 创建一个和 is 关联的对象输入流 ois = new ObjectInputStream(is); // 读取 byte 数组 huffmanBytes byte[] huffmanBytes = (byte[]) ois.readObject(); // 读取赫夫曼编码表 Map&lt;Byte, String&gt; huffmanCodes = (Map&lt;Byte, String&gt;) ois.readObject(); // 解码操作 byte[] bytes = decode(huffmanCodes, huffmanBytes); // 将 bytes 数组写入到目标文件 os = new FileOutputStream(destFile); // 写数据到 destFile 文件 os.write(bytes); } catch (Exception e) { System.out.println(e.getMessage()); } finally { try { os.close(); ois.close(); is.close(); } catch (Exception e) { System.out.println(e.getMessage()); } }} 赫夫曼编码注意事项 赫夫曼编码部分的所有完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414import java.io.*;import java.util.*;/** * @Author: guoshizhan * @Create: 2020/7/5 17:07 * @Description: 赫夫曼应用之数据压缩 */public class HuffmanCode { // 生成赫夫曼树对应的赫夫曼编码，将赫夫曼编码放在 Map&lt;Byte, String&gt; 中 static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;&gt;(); // 在生成的赫夫曼编码表时，需要拼接路径，所以定义一个 StringBuilder static StringBuilder stringBuilder = new StringBuilder(); public static void main(String[] args) { String str = \"i like like like java do you like a java\"; byte[] bytes = str.getBytes(); System.out.println(\"压缩前的长度是：\" + bytes.length); /*List&lt;Node&gt; nodes = getNodes(bytes); Node root = createHuffmanTree(nodes); root.preOrder(); getCodes(root); System.out.println(huffmanCodes); byte[] zip = zip(bytes, huffmanCodes); System.out.println(Arrays.toString(zip));*/ /*byte[] huffmanBytes = huffmanZip(bytes); System.out.println(\"压缩后的结果是：\" + Arrays.toString(huffmanBytes)); System.out.println(\"压缩后的长度是：\" + huffmanBytes.length); System.out.println(\"求出的压缩率是：\" + (float) (bytes.length - huffmanBytes.length) / bytes.length * 100 + \"%\"); byte[] sourceStr = decode(huffmanCodes, huffmanBytes); System.out.println(new String(sourceStr));*/ String src = \"F:\\\\src2.jpg\"; String desc = \"F:\\\\dest.zip\"; //zipFile(src, desc); unZipFile(desc, src); } /** * 将一个文件进行解压操作 * * @param zipFile 准备解压的文件 * @param destFile 将文件解压到哪个路径 */ public static void unZipFile(String zipFile, String destFile) { // 定义文件输入流 InputStream is = null; // 定义一个输入流对象 ObjectInputStream ois = null; // 定义文件的输入流 OutputStream os = null; try { // 创建文件输入流 is = new FileInputStream(zipFile); // 创建一个和 is 关联的对象输入流 ois = new ObjectInputStream(is); // 读取 byte 数组 huffmanBytes byte[] huffmanBytes = (byte[]) ois.readObject(); // 读取赫夫曼编码表 Map&lt;Byte, String&gt; huffmanCodes = (Map&lt;Byte, String&gt;) ois.readObject(); // 解码操作 byte[] bytes = decode(huffmanCodes, huffmanBytes); // 将 bytes 数组写入到目标文件 os = new FileOutputStream(destFile); // 写数据到 destFile 文件 os.write(bytes); } catch (Exception e) { System.out.println(e.getMessage()); } finally { try { os.close(); ois.close(); is.close(); } catch (Exception e) { System.out.println(e.getMessage()); } } } /** * 将一个文件进行压缩 * * @param srcFile 需要压缩的文件的全路径 * @param destFile 压缩后，压缩文件的保存目录 */ public static void zipFile(String srcFile, String destFile) { // 创建文输出流 OutputStream os = null; ObjectOutputStream oos = null; // 创建文件输入流 FileInputStream fis = null; try { fis = new FileInputStream(srcFile); // 创建一个和源文件大小一样的 byte[] 数组 byte[] bytes = new byte[fis.available()]; // 读取文件 fis.read(bytes); // 对文件压缩 byte[] huffmanBytes = huffmanZip(bytes); // 创建文件输出流，存放压缩文件 os = new FileOutputStream(destFile); // 创建一个和文件输出流关联的 ObjectOutputStream oos = new ObjectOutputStream(os); // 把赫夫曼编码后的字节数组写入压缩文件 oos.writeObject(huffmanBytes); // 这里我们以对象流的方式写入赫夫曼编码，是为了以后我们恢复源文件时使用。注意：一定要把赫夫曼编码写入压缩文件 oos.writeObject(huffmanCodes); } catch (Exception e) { System.out.println(e.getMessage()); } finally { try { oos.close(); os.close(); fis.close(); } catch (Exception e) { System.out.println(e.getMessage()); } } } /** * 数据的解压： * 1、将压缩后的字节数组转化成二进制字符串 * 2、将二进制字符串转化成对应的赫夫曼编码 * 3、将赫夫曼编码转化成最开始的数据，即 i like like …… * 4、huffmanCodes 表示赫夫曼编码表 map ，huffmanBytes 表示赫夫曼编码后得到的压缩数组 * 5、返回值就是初始字符串所对应的数组 */ public static byte[] decode(Map&lt;Byte, String&gt; huffmanCodes, byte[] huffmanBytes) { StringBuilder stringBuilder = new StringBuilder(); // 将 byte 数组转成二进制的字符串 for (int i = 0; i &lt; huffmanBytes.length; i++) { byte huffmanByte = huffmanBytes[i]; // 判断是不是最后一个字节 boolean flag = (i == huffmanBytes.length - 1); stringBuilder.append(byteToBitString(!flag, huffmanByte)); } System.out.println(stringBuilder.toString()); // 把字符串按照指定的赫夫曼编码进行节码 Map&lt;String, Byte&gt; map = new HashMap&lt;&gt;(); for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) { map.put(entry.getValue(), entry.getKey()); } System.out.println(map); List&lt;Byte&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; stringBuilder.length(); ) { int count = 1; boolean flag = true; Byte b = null; while (flag) { String key = stringBuilder.substring(i, i + count); b = map.get(key); if (b == null) { // 没有匹配到 count++; } else { // 匹配到了 flag = false; } } list.add(b); i += count; } byte[] bytes = new byte[list.size()]; for (int i = 0; i &lt; bytes.length; i++) { bytes[i] = list.get(i); } return bytes; } // 将一个 byte 转成一个二进制的字符串 public static String byteToBitString(boolean flag, byte b) { // 使用变量保存 b ，将 b 转成 int 类型 int temp = b; // 如果是整数，存在补高位。这里和 原码、反码和补码有关 if (flag) { temp |= 256; } String str = Integer.toBinaryString(temp); if (flag) { return str.substring(str.length() - 8); } else { return str; } } public static byte[] huffmanZip(byte[] bytes) { List&lt;Node&gt; nodes = getNodes(bytes); // 根据 nodes 创建的赫夫曼树 Node root = createHuffmanTree(nodes); // 对应的赫夫曼编码 Map&lt;Byte, String&gt; huffmanCodes = getCodes(root); // 根据赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组 byte[] huffmanCodeBytes = zip(bytes, huffmanCodes); // 返回字节数组 return huffmanCodeBytes; } /** * 将字符串对应的 byte[] 数组，通过生成的赫夫曼编码表，返回一个压缩后的 byte[] * * @param bytes 原始的字符串对应的 byte[] * @param huffmanCodes 生成的赫夫曼编码 map * @return 返回赫夫曼编码处理后的 byte[] */ public static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) { // 利用 huffmanCodes 将 bytes 转成赫夫曼编码对应的字符串 StringBuilder stringBuilder = new StringBuilder(); // 遍历 bytes 数组 for (byte aByte : bytes) { stringBuilder.append(huffmanCodes.get(aByte)); } // 1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100 System.out.println(stringBuilder.toString()); // 统计返回 byte[] huffmanCodeBytes 的长度 int len; if (stringBuilder.length() % 8 == 0) { len = stringBuilder.length() / 8; } else { len = stringBuilder.length() / 8 + 1; } // 创建存储压缩后的 byte 数组 huffmanCodeBytes byte[] huffmanCodeBytes = new byte[len]; int index = 0; for (int i = 0; i &lt; stringBuilder.length(); i += 8) { String strByte; if (i + 8 &gt; stringBuilder.length()) { strByte = stringBuilder.substring(i); } else { strByte = stringBuilder.substring(i, i + 8); } // 将 strByte 转成一个 byte ，放入到 huffmanCodeBytes 数组中 huffmanCodeBytes[index] = (byte) Integer.parseInt(strByte, 2); index++; } return huffmanCodeBytes; } // 重载 getCodes 方法，方便使用 public static Map&lt;Byte, String&gt; getCodes(Node root) { if (root == null) { return null; } // 处理 root 左子树 getCodes(root.left, \"0\", stringBuilder); // 处理 root 右子树 getCodes(root.right, \"1\", stringBuilder); return huffmanCodes; } /** * 得到赫夫曼编码，并存入 huffmanCodes 集合中 * * @param node 传入的节点 * @param code 表示路径：左子节点是 0 ，右子节点是 1 * @param stringBuilder 用于拼接路径 */ public static void getCodes(Node node, String code, StringBuilder stringBuilder) { StringBuilder stringBuilder1 = new StringBuilder(stringBuilder); stringBuilder1.append(code); // 将 code 加入到 stringBuilder1 if (node != null) { // 如果 node == null ，那么就不处理 if (node.data == null) { // 非叶子节点 // 向左递归 getCodes(node.left, \"0\", stringBuilder1); // 向右递归 getCodes(node.right, \"1\", stringBuilder1); } else { // 说明是一个叶子节点 huffmanCodes.put(node.data, stringBuilder1.toString()); } } } public static List&lt;Node&gt; getNodes(byte[] bytes) { List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); Map&lt;Byte, Integer&gt; map = new HashMap&lt;&gt;(); // 遍历 bytes ，统计每一个 byte 出现的次数 for (byte val : bytes) { Integer count = map.get(val); if (count == null) { map.put(val, 1); } else { map.put(val, count + 1); } } // 把每一个键值对转换成 Node 对象，并加入到 nodes 集合 for (Map.Entry&lt;Byte, Integer&gt; entry : map.entrySet()) { nodes.add(new Node(entry.getKey(), entry.getValue())); } return nodes; } // 通过 list 创建对应的赫夫曼树 public static Node createHuffmanTree(List&lt;Node&gt; nodes) { while (nodes.size() &gt; 1) { Collections.sort(nodes); Node leftNode = nodes.get(0); // 取出权值最小的节点 Node rightNode = nodes.get(1); // 取出权值第二小的节点 Node parent = new Node(null, leftNode.weight + rightNode.weight); parent.left = leftNode; parent.right = rightNode; nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parent); } return nodes.get(0); }}class Node implements Comparable&lt;Node&gt; { Byte data; // 存放字符本身，比如 'a' =&gt; 97 int weight; // 存放权值，表示字符出现的个数 Node left; // 指向左子树或左子节点 Node right; // 指向右子树或右子节点 public Node(Byte data, int weight) { this.data = data; this.weight = weight; } @Override public String toString() { return \"Node{\" + \"data=\" + data + \", weight=\" + weight + '}'; } @Override public int compareTo(Node o) { return this.weight - o.weight; } // 前序遍历 public void preOrder() { System.out.println(this); if (this.left != null) { this.left.preOrder(); } if (this.right != null) { this.right.preOrder(); } }} 二叉排序树（BST）基本介绍二叉排序树 整合了 数组 和 链表 的优点 ，从而对数据的 CRUD 操作更为高效。详情如下： 创建和遍历 二叉排序树的创建和遍历 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * @Author: guoshizhan * @Create: 2020/7/6 16:17 * @Description: 二叉排序树（BST）的创建和遍历 */public class BinarySortTreeTest { public static void main(String[] args) { int[] arr = {7, 3, 10, 12, 5, 1, 9}; BinarySortTree binarySortTree = new BinarySortTree(); for (int i = 0; i &lt; arr.length; i++) { binarySortTree.add(new Node(arr[i])); } binarySortTree.infixOrder(); }}// 创建二叉排序树类 BinarySortTreeclass BinarySortTree { // 定义根节点 private Node root; // 添加节点的方法 public void add(Node node) { if (root == null) { root = node; } else { root.add(node); } } // 中序遍历的方法 public void infixOrder() { if (root != null) { root.infixOrder(); } else { System.out.println(\"The Binary Sort Tree is empty, so it can not be traversal!!!\"); } }}// 创建 Node 节点类class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } // 添加节点：使用递归的方式添加节点。注意：需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } // 判断传入节点的值和当前子树的根节点的值的大小关系 if (node.value &lt; this.value) { // 如果当前节点的左子节点为 null if (this.left == null) { this.left = node; } else { // 递归向左子树添加 this.left.add(node); } } else { // 添加的节点大于当前节点的值 // 如果当前节点的左子节点为 null if (this.right == null) { this.right = node; } else { // 递归向左子树添加 this.right.add(node); } } } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } // 中序遍历 public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } }} 删除节点二叉排序树 的 删除节点的情况和思路分析 如下图： 第一种情况： 删除叶子节点 。相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210/** * @Author: guoshizhan * @Create: 2020/7/6 16:17 * @Description: 二叉排序树（BST）的创建和遍历 */public class BinarySortTreeTest { public static void main(String[] args) { int[] arr = {7, 3, 10, 12, 5, 1, 9, 2}; BinarySortTree binarySortTree = new BinarySortTree(); for (int i = 0; i &lt; arr.length; i++) { binarySortTree.add(new Node(arr[i])); } binarySortTree.infixOrder(); binarySortTree.delNode(12); System.out.println(\"======================\"); binarySortTree.infixOrder(); }}// 创建二叉排序树类 BinarySortTreeclass BinarySortTree { // 定义根节点 private Node root; // 查找要删除的节点 public Node search(int value) { if (root == null) { return null; } else { return root.search(value); } } // 查找父节点 public Node searchParent(int value) { if (root == null) { return null; } else { return root.searchParent(value); } } // 删除节点，这个方法才是核心 public void delNode(int value) { if (root == null) { return; } else { // 先找到要删除的节点 targetNode Node targetNode = search(value); // 如果没有找到 if (targetNode == null) { return; } // 如果这颗二叉树只有一个节点 if (root.left == null &amp;&amp; root.right == null) { root = null; return; } // 去找 targetNode 的父节点 Node parent = searchParent(value); // 如果要删除的节点是叶子节点 if (targetNode.left == null &amp;&amp; targetNode.right == null) { // 判断 targetNode 是父节点的左子节点还是右子节点 if (parent.left != null &amp;&amp; parent.left.value == value) { // 是左子节点 parent.left = null; } else if (parent.right != null &amp;&amp; parent.right.value == value) { // 是右子节点 parent.right = null; } } } } // 添加节点的方法 public void add(Node node) { if (root == null) { root = node; } else { root.add(node); } } // 中序遍历的方法 public void infixOrder() { if (root != null) { root.infixOrder(); } else { System.out.println(\"The Binary Sort Tree is empty, so it can not be traversal!!!\"); } }}// 创建 Node 节点类class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } /** * 查找要删除的节点 * @param value 需要删除的节点的值 * @return 如果找到，则返回该节点，否则返回 null */ public Node search(int value) { if (value == this.value) { return this; } else if (value &lt; this.value) { // 向左子树递归查找 // 如果左子节点为空 if (this.left == null) { return null; } return this.left.search(value); } else { // 向右子树递归查找 if (this.right == null) { return null; } return this.right.search(value); } } /** * 查找要删除节点的父节点 * @param value 要查找节点的值 * @return 找到就返回父节点，否则返回 null */ public Node searchParent(int value) { // 如果当前节点就是要删除的节点的父节点，就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) { return this; } else { // 如果查找的值小于当前节点的值，并且当前节点的左子节点不为空 if (value &lt; this.value &amp;&amp; this.left != null) { return this.left.searchParent(value); // 向左子树递归查找 } else if (value &gt;= this.value &amp;&amp; this.right != null) { return this.right.searchParent(value); // 向右子树递归查找 } else { return null; // 没有找到父节点 } } } // 添加节点：使用递归的方式添加节点。注意：需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } // 判断传入节点的值和当前子树的根节点的值的大小关系 if (node.value &lt; this.value) { // 如果当前节点的左子节点为 null if (this.left == null) { this.left = node; } else { // 递归向左子树添加 this.left.add(node); } } else { // 添加的节点大于当前节点的值 // 如果当前节点的左子节点为 null if (this.right == null) { this.right = node; } else { // 递归向左子树添加 this.right.add(node); } } } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } // 中序遍历 public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } }} 第二种情况： 删除只有一颗子树的节点 。相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241/** * @Author: guoshizhan * @Create: 2020/7/6 16:17 * @Description: 二叉排序树（BST）的创建和遍历 */public class BinarySortTreeTest { public static void main(String[] args) { int[] arr = {7, 3, 10, 12, 5, 1, 9, 2}; BinarySortTree binarySortTree = new BinarySortTree(); for (int i = 0; i &lt; arr.length; i++) { binarySortTree.add(new Node(arr[i])); } binarySortTree.infixOrder(); binarySortTree.delNode(1); System.out.println(\"======================\"); binarySortTree.infixOrder(); }}// 创建二叉排序树类 BinarySortTreeclass BinarySortTree { // 定义根节点 private Node root; // 查找要删除的节点 public Node search(int value) { if (root == null) { return null; } else { return root.search(value); } } // 查找父节点 public Node searchParent(int value) { if (root == null) { return null; } else { return root.searchParent(value); } } // 删除节点，这个方法才是核心 public void delNode(int value) { if (root == null) { return; } else { // 先找到要删除的节点 targetNode Node targetNode = search(value); // 如果没有找到 if (targetNode == null) { return; } // 如果这颗二叉树只有一个节点 if (root.left == null &amp;&amp; root.right == null) { root = null; return; } // 去找 targetNode 的父节点 Node parent = searchParent(value); // 如果要删除的节点是叶子节点 if (targetNode.left == null &amp;&amp; targetNode.right == null) { // 判断 targetNode 是父节点的左子节点还是右子节点 if (parent.left != null &amp;&amp; parent.left.value == value) { // 是左子节点 parent.left = null; } else if (parent.right != null &amp;&amp; parent.right.value == value) { // 是右子节点 parent.right = null; } } else if (targetNode.left != null &amp;&amp; targetNode.right != null) { // 删除有两颗子树的节点 /** * 此处是第三种情况，暂时不写内容 */ } else { // 删除只有一颗子树的节点 // 如果要删除的节点有左子节点 if (targetNode.left != null) { // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == value) { parent.left = targetNode.left; } else { // targetNode 是 parent 的右子节点 parent.right = targetNode.left; } } else { // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == value) { parent.left = targetNode.right; } else { // 如果 targetNode 是 parent 的右子节点 parent.right = targetNode.right; } } } } } // 添加节点的方法 public void add(Node node) { if (root == null) { root = node; } else { root.add(node); } } // 中序遍历的方法 public void infixOrder() { if (root != null) { root.infixOrder(); } else { System.out.println(\"The Binary Sort Tree is empty, so it can not be traversal!!!\"); } }}// 创建 Node 节点类class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } /** * 查找要删除的节点 * * @param value 需要删除的节点的值 * @return 如果找到，则返回该节点，否则返回 null */ public Node search(int value) { if (value == this.value) { return this; } else if (value &lt; this.value) { // 向左子树递归查找 // 如果左子节点为空 if (this.left == null) { return null; } return this.left.search(value); } else { // 向右子树递归查找 if (this.right == null) { return null; } return this.right.search(value); } } /** * 查找要删除节点的父节点 * * @param value 要查找节点的值 * @return 找到就返回父节点，否则返回 null */ public Node searchParent(int value) { // 如果当前节点就是要删除的节点的父节点，就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) { return this; } else { // 如果查找的值小于当前节点的值，并且当前节点的左子节点不为空 if (value &lt; this.value &amp;&amp; this.left != null) { return this.left.searchParent(value); // 向左子树递归查找 } else if (value &gt;= this.value &amp;&amp; this.right != null) { return this.right.searchParent(value); // 向右子树递归查找 } else { return null; // 没有找到父节点 } } } // 添加节点：使用递归的方式添加节点。注意：需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } // 判断传入节点的值和当前子树的根节点的值的大小关系 if (node.value &lt; this.value) { // 如果当前节点的左子节点为 null if (this.left == null) { this.left = node; } else { // 递归向左子树添加 this.left.add(node); } } else { // 添加的节点大于当前节点的值 // 如果当前节点的左子节点为 null if (this.right == null) { this.right = node; } else { // 递归向左子树添加 this.right.add(node); } } } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } // 中序遍历 public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } }} 第三种情况： 删除有两颗子树的节点 。相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262/** * @Author: guoshizhan * @Create: 2020/7/6 16:17 * @Description: 二叉排序树（BST）的创建和遍历 */public class BinarySortTreeTest { public static void main(String[] args) { int[] arr = {7, 3, 10, 12, 5, 1, 9, 2}; BinarySortTree binarySortTree = new BinarySortTree(); for (int i = 0; i &lt; arr.length; i++) { binarySortTree.add(new Node(arr[i])); } binarySortTree.infixOrder(); binarySortTree.delNode(7); System.out.println(\"======================\"); binarySortTree.infixOrder(); }}// 创建二叉排序树类 BinarySortTreeclass BinarySortTree { // 定义根节点 private Node root; // 查找要删除的节点 public Node search(int value) { if (root == null) { return null; } else { return root.search(value); } } // 查找父节点 public Node searchParent(int value) { if (root == null) { return null; } else { return root.searchParent(value); } } // 把传入的节点 node 当做二叉排序树的根节点，然后返回以 node 为根节点的二叉排序树的最小值 public int delRightTreeMin(Node node) { Node temp = node; // 循环查找左子节点，就会找到最小值 while (temp.left != null) { temp = temp.left; } // 删除最小节点 delNode(temp.value); return temp.value; } // 删除节点，这个方法才是核心 public void delNode(int value) { if (root == null) { return; } else { // 先找到要删除的节点 targetNode Node targetNode = search(value); // 如果没有找到 if (targetNode == null) { return; } // 如果这颗二叉树只有一个节点 if (root.left == null &amp;&amp; root.right == null) { root = null; return; } // 去找 targetNode 的父节点 Node parent = searchParent(value); // 如果要删除的节点是叶子节点 if (targetNode.left == null &amp;&amp; targetNode.right == null) { // 判断 targetNode 是父节点的左子节点还是右子节点 if (parent.left != null &amp;&amp; parent.left.value == value) { // 是左子节点 parent.left = null; } else if (parent.right != null &amp;&amp; parent.right.value == value) { // 是右子节点 parent.right = null; } } else if (targetNode.left != null &amp;&amp; targetNode.right != null) { // 删除有两颗子树的节点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal; } else { // 删除只有一颗子树的节点 // 如果要删除的节点有左子节点 if (targetNode.left != null) { if (parent != null) { // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == value) { parent.left = targetNode.left; } else { // targetNode 是 parent 的右子节点 parent.right = targetNode.left; } } else { root = targetNode.left; } } else { if (parent != null) { // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == value) { parent.left = targetNode.right; } else { // 如果 targetNode 是 parent 的右子节点 parent.right = targetNode.right; } } else { root = targetNode.right; } } } } } // 添加节点的方法 public void add(Node node) { if (root == null) { root = node; } else { root.add(node); } } // 中序遍历的方法 public void infixOrder() { if (root != null) { root.infixOrder(); } else { System.out.println(\"The Binary Sort Tree is empty, so it can not be traversal!!!\"); } }}// 创建 Node 节点类class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } /** * 查找要删除的节点 * @param value 需要删除的节点的值 * @return 如果找到，则返回该节点，否则返回 null */ public Node search(int value) { if (value == this.value) { return this; } else if (value &lt; this.value) { // 向左子树递归查找 // 如果左子节点为空 if (this.left == null) { return null; } return this.left.search(value); } else { // 向右子树递归查找 if (this.right == null) { return null; } return this.right.search(value); } } /** * 查找要删除节点的父节点 * @param value 要查找节点的值 * @return 找到就返回父节点，否则返回 null */ public Node searchParent(int value) { // 如果当前节点就是要删除的节点的父节点，就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) { return this; } else { // 如果查找的值小于当前节点的值，并且当前节点的左子节点不为空 if (value &lt; this.value &amp;&amp; this.left != null) { return this.left.searchParent(value); // 向左子树递归查找 } else if (value &gt;= this.value &amp;&amp; this.right != null) { return this.right.searchParent(value); // 向右子树递归查找 } else { return null; // 没有找到父节点 } } } // 添加节点：使用递归的方式添加节点。注意：需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } // 判断传入节点的值和当前子树的根节点的值的大小关系 if (node.value &lt; this.value) { // 如果当前节点的左子节点为 null if (this.left == null) { this.left = node; } else { // 递归向左子树添加 this.left.add(node); } } else { // 添加的节点大于当前节点的值 // 如果当前节点的左子节点为 null if (this.right == null) { this.right = node; } else { // 递归向左子树添加 this.right.add(node); } } } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } // 中序遍历 public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } }} 平衡二叉树（AVL）基本介绍二叉排序树 有的时候是有些问题的，这时就需要用到 平衡二叉树（AVL） 了。基本介绍如下： 创建和遍历以下是 创建平衡二叉树过程中需要用到的三种解决方案 ，如下图： 获得树的高度、左子树的高度和右子树的高度。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290/** * @Author: guoshizhan * @Create: 2020/7/7 12:58 * @Description: 平衡二叉树（AVL） */public class AVLTreeTest { public static void main(String[] args) { int[] arr = {4, 3, 6, 5, 7, 8}; // 创建 AVLTree 对象 AVLTree avlTree = new AVLTree(); // 添加节点 for (int i = 0; i &lt; arr.length; i++) { avlTree.add(new Node(arr[i])); } avlTree.infixOrder(); Node root = avlTree.getRoot(); System.out.println(\"树的高度 = \" + root.height()); System.out.println(\"树的左子树高度 = \" + root.leftHeight()); System.out.println(\"树的右子树高度 = \" + root.rightHeight()); }}// 创建 AVL 树class AVLTree { // 定义根节点 private Node root; // 获得根节点 public Node getRoot() { return this.root; } // 查找要删除的节点 public Node search(int value) { if (root == null) { return null; } else { return root.search(value); } } // 查找父节点 public Node searchParent(int value) { if (root == null) { return null; } else { return root.searchParent(value); } } // 把传入的节点 node 当做二叉排序树的根节点，然后返回以 node 为根节点的二叉排序树的最小值 public int delRightTreeMin(Node node) { Node temp = node; // 循环查找左子节点，就会找到最小值 while (temp.left != null) { temp = temp.left; } // 删除最小节点 delNode(temp.value); return temp.value; } // 删除节点，这个方法才是核心 public void delNode(int value) { if (root == null) { return; } else { // 先找到要删除的节点 targetNode Node targetNode = search(value); // 如果没有找到 if (targetNode == null) { return; } // 如果这颗二叉树只有一个节点 if (root.left == null &amp;&amp; root.right == null) { root = null; return; } // 去找 targetNode 的父节点 Node parent = searchParent(value); // 如果要删除的节点是叶子节点 if (targetNode.left == null &amp;&amp; targetNode.right == null) { // 判断 targetNode 是父节点的左子节点还是右子节点 if (parent.left != null &amp;&amp; parent.left.value == value) { // 是左子节点 parent.left = null; } else if (parent.right != null &amp;&amp; parent.right.value == value) { // 是右子节点 parent.right = null; } } else if (targetNode.left != null &amp;&amp; targetNode.right != null) { // 删除有两颗子树的节点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal; } else { // 删除只有一颗子树的节点 // 如果要删除的节点有左子节点 if (targetNode.left != null) { if (parent != null) { // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == value) { parent.left = targetNode.left; } else { // targetNode 是 parent 的右子节点 parent.right = targetNode.left; } } else { root = targetNode.left; } } else { if (parent != null) { // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == value) { parent.left = targetNode.right; } else { // 如果 targetNode 是 parent 的右子节点 parent.right = targetNode.right; } } else { root = targetNode.right; } } } } } // 添加节点的方法 public void add(Node node) { if (root == null) { root = node; } else { root.add(node); } } // 中序遍历的方法 public void infixOrder() { if (root != null) { root.infixOrder(); } else { System.out.println(\"The Binary Sort Tree is empty, so it can not be traversal!!!\"); } }}// 创建 Node 节点类class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } // 返回左子树的高度 public int leftHeight() { if (left == null) { return 0; } return left.height(); } // 返回右子树的高度 public int rightHeight() { if (right == null) { return 0; } return right.height(); } // 返回当前节点的高度，以该节点为根节点的树的高度 public int height() { return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1; } /** * 查找要删除的节点 * @param value 需要删除的节点的值 * @return 如果找到，则返回该节点，否则返回 null */ public Node search(int value) { if (value == this.value) { return this; } else if (value &lt; this.value) { // 向左子树递归查找 // 如果左子节点为空 if (this.left == null) { return null; } return this.left.search(value); } else { // 向右子树递归查找 if (this.right == null) { return null; } return this.right.search(value); } } /** * 查找要删除节点的父节点 * @param value 要查找节点的值 * @return 找到就返回父节点，否则返回 null */ public Node searchParent(int value) { // 如果当前节点就是要删除的节点的父节点，就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) { return this; } else { // 如果查找的值小于当前节点的值，并且当前节点的左子节点不为空 if (value &lt; this.value &amp;&amp; this.left != null) { return this.left.searchParent(value); // 向左子树递归查找 } else if (value &gt;= this.value &amp;&amp; this.right != null) { return this.right.searchParent(value); // 向右子树递归查找 } else { return null; // 没有找到父节点 } } } // 添加节点：使用递归的方式添加节点。注意：需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } // 判断传入节点的值和当前子树的根节点的值的大小关系 if (node.value &lt; this.value) { // 如果当前节点的左子节点为 null if (this.left == null) { this.left = node; } else { // 递归向左子树添加 this.left.add(node); } } else { // 添加的节点大于当前节点的值 // 如果当前节点的左子节点为 null if (this.right == null) { this.right = node; } else { // 递归向左子树添加 this.right.add(node); } } } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } // 中序遍历 public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } }} 左旋转对二叉排序树进行左旋转，即变成了平衡二叉树。 由上面代码发现，左右两颗子树的高度差的绝对值超过了 1 ，且右子树高于左子树， 所有需要进行 左旋转 。左旋转思路分析 如下图： 左旋转 的代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320/** * @Author: guoshizhan * @Create: 2020/7/7 12:58 * @Description: 平衡二叉树（AVL） */public class AVLTreeTest { public static void main(String[] args) { int[] arr = {4, 3, 6, 5, 7, 8}; // 创建 AVLTree 对象 AVLTree avlTree = new AVLTree(); // 添加节点 for (int i = 0; i &lt; arr.length; i++) { avlTree.add(new Node(arr[i])); } avlTree.infixOrder(); Node root = avlTree.getRoot(); System.out.println(\"树的高度 = \" + root.height()); System.out.println(\"树的左子树高度 = \" + root.leftHeight()); System.out.println(\"树的右子树高度 = \" + root.rightHeight()); }}// 创建 AVL 树class AVLTree { // 定义根节点 private Node root; // 获得根节点 public Node getRoot() { return this.root; } // 查找要删除的节点 public Node search(int value) { if (root == null) { return null; } else { return root.search(value); } } // 查找父节点 public Node searchParent(int value) { if (root == null) { return null; } else { return root.searchParent(value); } } // 把传入的节点 node 当做二叉排序树的根节点，然后返回以 node 为根节点的二叉排序树的最小值 public int delRightTreeMin(Node node) { Node temp = node; // 循环查找左子节点，就会找到最小值 while (temp.left != null) { temp = temp.left; } // 删除最小节点 delNode(temp.value); return temp.value; } // 删除节点，这个方法才是核心 public void delNode(int value) { if (root == null) { return; } else { // 先找到要删除的节点 targetNode Node targetNode = search(value); // 如果没有找到 if (targetNode == null) { return; } // 如果这颗二叉树只有一个节点 if (root.left == null &amp;&amp; root.right == null) { root = null; return; } // 去找 targetNode 的父节点 Node parent = searchParent(value); // 如果要删除的节点是叶子节点 if (targetNode.left == null &amp;&amp; targetNode.right == null) { // 判断 targetNode 是父节点的左子节点还是右子节点 if (parent.left != null &amp;&amp; parent.left.value == value) { // 是左子节点 parent.left = null; } else if (parent.right != null &amp;&amp; parent.right.value == value) { // 是右子节点 parent.right = null; } } else if (targetNode.left != null &amp;&amp; targetNode.right != null) { // 删除有两颗子树的节点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal; } else { // 删除只有一颗子树的节点 // 如果要删除的节点有左子节点 if (targetNode.left != null) { if (parent != null) { // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == value) { parent.left = targetNode.left; } else { // targetNode 是 parent 的右子节点 parent.right = targetNode.left; } } else { root = targetNode.left; } } else { if (parent != null) { // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == value) { parent.left = targetNode.right; } else { // 如果 targetNode 是 parent 的右子节点 parent.right = targetNode.right; } } else { root = targetNode.right; } } } } } // 添加节点的方法 public void add(Node node) { if (root == null) { root = node; } else { root.add(node); } } // 中序遍历的方法 public void infixOrder() { if (root != null) { root.infixOrder(); } else { System.out.println(\"The Binary Sort Tree is empty, so it can not be traversal!!!\"); } }}// 创建 Node 节点类class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } // 左旋转方法 public void leftRotate() { // 以当前根节点的值创建新的节点 Node newNdoe = new Node(value); // 把新的节点的左子树设置成为当前节点的左子树 newNdoe.left = left; // 把新的节点的右子树设置成当前节点的右子树的左子树 newNdoe.right = right.left; // 把当前节点的值替换成右子节点的值 value = right.value; // 把当前节点的右子树设置成当前节点右子树的右子树 right = right.right; // 把当前节点的左子树（左子节点）设置成新的节点 left = newNdoe; } // 返回左子树的高度 public int leftHeight() { if (left == null) { return 0; } return left.height(); } // 返回右子树的高度 public int rightHeight() { if (right == null) { return 0; } return right.height(); } // 返回当前节点的高度，以该节点为根节点的树的高度 public int height() { return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1; } /** * 查找要删除的节点 * * @param value 需要删除的节点的值 * @return 如果找到，则返回该节点，否则返回 null */ public Node search(int value) { if (value == this.value) { return this; } else if (value &lt; this.value) { // 向左子树递归查找 // 如果左子节点为空 if (this.left == null) { return null; } return this.left.search(value); } else { // 向右子树递归查找 if (this.right == null) { return null; } return this.right.search(value); } } /** * 查找要删除节点的父节点 * * @param value 要查找节点的值 * @return 找到就返回父节点，否则返回 null */ public Node searchParent(int value) { // 如果当前节点就是要删除的节点的父节点，就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) { return this; } else { // 如果查找的值小于当前节点的值，并且当前节点的左子节点不为空 if (value &lt; this.value &amp;&amp; this.left != null) { return this.left.searchParent(value); // 向左子树递归查找 } else if (value &gt;= this.value &amp;&amp; this.right != null) { return this.right.searchParent(value); // 向右子树递归查找 } else { return null; // 没有找到父节点 } } } // 添加节点：使用递归的方式添加节点。注意：需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } // 判断传入节点的值和当前子树的根节点的值的大小关系 if (node.value &lt; this.value) { // 如果当前节点的左子节点为 null if (this.left == null) { this.left = node; } else { // 递归向左子树添加 this.left.add(node); } } else { // 添加的节点大于当前节点的值 // 如果当前节点的左子节点为 null if (this.right == null) { this.right = node; } else { // 递归向右子树添加 this.right.add(node); } } // 如果 （右子树的高度 - 左子树的高度）&gt; 1 ，那么就进行左旋转 if (rightHeight() - leftHeight() &gt; 1) { leftRotate(); } } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } // 中序遍历 public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } }} 右旋转对二叉排序树进行右旋转，即变成了平衡二叉树。 由上面代码发现，左右两颗子树的高度差的绝对值超过了 1 ，且左子树高于右子树， 所有需要进行 右旋转 。右旋转思路分析 如下图： 右旋转 的代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339/** * @Author: guoshizhan * @Create: 2020/7/7 12:58 * @Description: 平衡二叉树（AVL） */public class AVLTreeTest { public static void main(String[] args) { //int[] arr = {4, 3, 6, 5, 7, 8}; // 左旋转使用的数组 int[] arr = {10, 12, 8, 9, 7, 6}; // 右旋转使用的数组 // 创建 AVLTree 对象 AVLTree avlTree = new AVLTree(); // 添加节点 for (int i = 0; i &lt; arr.length; i++) { avlTree.add(new Node(arr[i])); } avlTree.infixOrder(); Node root = avlTree.getRoot(); System.out.println(\"树的高度 = \" + root.height()); System.out.println(\"树的左子树高度 = \" + root.leftHeight()); System.out.println(\"树的右子树高度 = \" + root.rightHeight()); System.out.println(\"当前根节点 = \" + avlTree.getRoot()); }}// 创建 AVL 树class AVLTree { // 定义根节点 private Node root; // 获得根节点 public Node getRoot() { return this.root; } // 查找要删除的节点 public Node search(int value) { if (root == null) { return null; } else { return root.search(value); } } // 查找父节点 public Node searchParent(int value) { if (root == null) { return null; } else { return root.searchParent(value); } } // 把传入的节点 node 当做二叉排序树的根节点，然后返回以 node 为根节点的二叉排序树的最小值 public int delRightTreeMin(Node node) { Node temp = node; // 循环查找左子节点，就会找到最小值 while (temp.left != null) { temp = temp.left; } // 删除最小节点 delNode(temp.value); return temp.value; } // 删除节点，这个方法才是核心 public void delNode(int value) { if (root == null) { return; } else { // 先找到要删除的节点 targetNode Node targetNode = search(value); // 如果没有找到 if (targetNode == null) { return; } // 如果这颗二叉树只有一个节点 if (root.left == null &amp;&amp; root.right == null) { root = null; return; } // 去找 targetNode 的父节点 Node parent = searchParent(value); // 如果要删除的节点是叶子节点 if (targetNode.left == null &amp;&amp; targetNode.right == null) { // 判断 targetNode 是父节点的左子节点还是右子节点 if (parent.left != null &amp;&amp; parent.left.value == value) { // 是左子节点 parent.left = null; } else if (parent.right != null &amp;&amp; parent.right.value == value) { // 是右子节点 parent.right = null; } } else if (targetNode.left != null &amp;&amp; targetNode.right != null) { // 删除有两颗子树的节点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal; } else { // 删除只有一颗子树的节点 // 如果要删除的节点有左子节点 if (targetNode.left != null) { if (parent != null) { // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == value) { parent.left = targetNode.left; } else { // targetNode 是 parent 的右子节点 parent.right = targetNode.left; } } else { root = targetNode.left; } } else { if (parent != null) { // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == value) { parent.left = targetNode.right; } else { // 如果 targetNode 是 parent 的右子节点 parent.right = targetNode.right; } } else { root = targetNode.right; } } } } } // 添加节点的方法 public void add(Node node) { if (root == null) { root = node; } else { root.add(node); } } // 中序遍历的方法 public void infixOrder() { if (root != null) { root.infixOrder(); } else { System.out.println(\"The Binary Sort Tree is empty, so it can not be traversal!!!\"); } }}// 创建 Node 节点类class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } // 右旋转方法 public void rightRotate() { Node newNdoe = new Node(value); newNdoe.right = right; newNdoe.left = left.right; value = left.value; left = left.left; right = newNdoe; } // 左旋转方法 public void leftRotate() { // 以当前根节点的值创建新的节点 Node newNdoe = new Node(value); // 把新的节点的左子树设置成为当前节点的左子树 newNdoe.left = left; // 把新的节点的右子树设置成当前节点的右子树的左子树 newNdoe.right = right.left; // 把当前节点的值替换成右子节点的值 value = right.value; // 把当前节点的右子树设置成当前节点右子树的右子树 right = right.right; // 把当前节点的左子树（左子节点）设置成新的节点 left = newNdoe; } // 返回左子树的高度 public int leftHeight() { if (left == null) { return 0; } return left.height(); } // 返回右子树的高度 public int rightHeight() { if (right == null) { return 0; } return right.height(); } // 返回当前节点的高度，以该节点为根节点的树的高度 public int height() { return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1; } /** * 查找要删除的节点 * * @param value 需要删除的节点的值 * @return 如果找到，则返回该节点，否则返回 null */ public Node search(int value) { if (value == this.value) { return this; } else if (value &lt; this.value) { // 向左子树递归查找 // 如果左子节点为空 if (this.left == null) { return null; } return this.left.search(value); } else { // 向右子树递归查找 if (this.right == null) { return null; } return this.right.search(value); } } /** * 查找要删除节点的父节点 * * @param value 要查找节点的值 * @return 找到就返回父节点，否则返回 null */ public Node searchParent(int value) { // 如果当前节点就是要删除的节点的父节点，就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) { return this; } else { // 如果查找的值小于当前节点的值，并且当前节点的左子节点不为空 if (value &lt; this.value &amp;&amp; this.left != null) { return this.left.searchParent(value); // 向左子树递归查找 } else if (value &gt;= this.value &amp;&amp; this.right != null) { return this.right.searchParent(value); // 向右子树递归查找 } else { return null; // 没有找到父节点 } } } // 添加节点：使用递归的方式添加节点。注意：需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } // 判断传入节点的值和当前子树的根节点的值的大小关系 if (node.value &lt; this.value) { // 如果当前节点的左子节点为 null if (this.left == null) { this.left = node; } else { // 递归向左子树添加 this.left.add(node); } } else { // 添加的节点大于当前节点的值 // 如果当前节点的左子节点为 null if (this.right == null) { this.right = node; } else { // 递归向右子树添加 this.right.add(node); } } // 如果 （右子树的高度 - 左子树的高度）&gt; 1 ，那么就进行左旋转 if (rightHeight() - leftHeight() &gt; 1) { leftRotate(); } // 如果 （左子树的高度 - 右子树的高度）&gt; 1 ，那么就进行右旋转 if (leftHeight() - rightHeight() &gt; 1) { rightRotate(); } } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } // 中序遍历 public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } }} 双旋转双旋转 主要是 为了解决左旋转和右旋转无法解决的问题。相关问题以及双旋转的思路分析 如下图： 双旋转 的代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358/** * @Author: guoshizhan * @Create: 2020/7/7 12:58 * @Description: 平衡二叉树（AVL） */public class AVLTreeTest { public static void main(String[] args) { //int[] arr = {4, 3, 6, 5, 7, 8}; // 左旋转使用的数组 //int[] arr = {10, 12, 8, 9, 7, 6}; // 右旋转使用的数组 int[] arr = {10, 11, 7, 6, 8, 9}; // 双旋转使用的数组 // 创建 AVLTree 对象 AVLTree avlTree = new AVLTree(); // 添加节点 for (int i = 0; i &lt; arr.length; i++) { avlTree.add(new Node(arr[i])); } avlTree.infixOrder(); Node root = avlTree.getRoot(); System.out.println(\"树的高度 = \" + root.height()); System.out.println(\"树的左子树高度 = \" + root.leftHeight()); System.out.println(\"树的右子树高度 = \" + root.rightHeight()); System.out.println(\"当前根节点 = \" + avlTree.getRoot()); System.out.println(\"当前根节点的右子树的 …… \" + avlTree.getRoot().right.right.left); }}// 创建 AVL 树class AVLTree { // 定义根节点 private Node root; // 获得根节点 public Node getRoot() { return this.root; } // 查找要删除的节点 public Node search(int value) { if (root == null) { return null; } else { return root.search(value); } } // 查找父节点 public Node searchParent(int value) { if (root == null) { return null; } else { return root.searchParent(value); } } // 把传入的节点 node 当做二叉排序树的根节点，然后返回以 node 为根节点的二叉排序树的最小值 public int delRightTreeMin(Node node) { Node temp = node; // 循环查找左子节点，就会找到最小值 while (temp.left != null) { temp = temp.left; } // 删除最小节点 delNode(temp.value); return temp.value; } // 删除节点，这个方法才是核心 public void delNode(int value) { if (root == null) { return; } else { // 先找到要删除的节点 targetNode Node targetNode = search(value); // 如果没有找到 if (targetNode == null) { return; } // 如果这颗二叉树只有一个节点 if (root.left == null &amp;&amp; root.right == null) { root = null; return; } // 去找 targetNode 的父节点 Node parent = searchParent(value); // 如果要删除的节点是叶子节点 if (targetNode.left == null &amp;&amp; targetNode.right == null) { // 判断 targetNode 是父节点的左子节点还是右子节点 if (parent.left != null &amp;&amp; parent.left.value == value) { // 是左子节点 parent.left = null; } else if (parent.right != null &amp;&amp; parent.right.value == value) { // 是右子节点 parent.right = null; } } else if (targetNode.left != null &amp;&amp; targetNode.right != null) { // 删除有两颗子树的节点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal; } else { // 删除只有一颗子树的节点 // 如果要删除的节点有左子节点 if (targetNode.left != null) { if (parent != null) { // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == value) { parent.left = targetNode.left; } else { // targetNode 是 parent 的右子节点 parent.right = targetNode.left; } } else { root = targetNode.left; } } else { if (parent != null) { // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == value) { parent.left = targetNode.right; } else { // 如果 targetNode 是 parent 的右子节点 parent.right = targetNode.right; } } else { root = targetNode.right; } } } } } // 添加节点的方法 public void add(Node node) { if (root == null) { root = node; } else { root.add(node); } } // 中序遍历的方法 public void infixOrder() { if (root != null) { root.infixOrder(); } else { System.out.println(\"The Binary Sort Tree is empty, so it can not be traversal!!!\"); } }}// 创建 Node 节点类class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } // 右旋转方法 public void rightRotate() { Node newNdoe = new Node(value); newNdoe.right = right; newNdoe.left = left.right; value = left.value; left = left.left; right = newNdoe; } // 左旋转方法 public void leftRotate() { // 以当前根节点的值创建新的节点 Node newNdoe = new Node(value); // 把新的节点的左子树设置成为当前节点的左子树 newNdoe.left = left; // 把新的节点的右子树设置成当前节点的右子树的左子树 newNdoe.right = right.left; // 把当前节点的值替换成右子节点的值 value = right.value; // 把当前节点的右子树设置成当前节点右子树的右子树 right = right.right; // 把当前节点的左子树（左子节点）设置成新的节点 left = newNdoe; } // 返回左子树的高度 public int leftHeight() { if (left == null) { return 0; } return left.height(); } // 返回右子树的高度 public int rightHeight() { if (right == null) { return 0; } return right.height(); } // 返回当前节点的高度，以该节点为根节点的树的高度 public int height() { return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1; } /** * 查找要删除的节点 * * @param value 需要删除的节点的值 * @return 如果找到，则返回该节点，否则返回 null */ public Node search(int value) { if (value == this.value) { return this; } else if (value &lt; this.value) { // 向左子树递归查找 // 如果左子节点为空 if (this.left == null) { return null; } return this.left.search(value); } else { // 向右子树递归查找 if (this.right == null) { return null; } return this.right.search(value); } } /** * 查找要删除节点的父节点 * * @param value 要查找节点的值 * @return 找到就返回父节点，否则返回 null */ public Node searchParent(int value) { // 如果当前节点就是要删除的节点的父节点，就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) { return this; } else { // 如果查找的值小于当前节点的值，并且当前节点的左子节点不为空 if (value &lt; this.value &amp;&amp; this.left != null) { return this.left.searchParent(value); // 向左子树递归查找 } else if (value &gt;= this.value &amp;&amp; this.right != null) { return this.right.searchParent(value); // 向右子树递归查找 } else { return null; // 没有找到父节点 } } } // 添加节点：使用递归的方式添加节点。注意：需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } // 判断传入节点的值和当前子树的根节点的值的大小关系 if (node.value &lt; this.value) { // 如果当前节点的左子节点为 null if (this.left == null) { this.left = node; } else { // 递归向左子树添加 this.left.add(node); } } else { // 添加的节点大于当前节点的值 // 如果当前节点的左子节点为 null if (this.right == null) { this.right = node; } else { // 递归向右子树添加 this.right.add(node); } } // 如果 （右子树的高度 - 左子树的高度）&gt; 1 ，那么就进行左旋转 if (rightHeight() - leftHeight() &gt; 1) { // 如果它的右子树的左子树高度大于它的右子树的高度 if (right != null &amp;&amp; right.leftHeight() &gt; right.rightHeight()) { // 先对当前节点的右节点（右子树）进行右旋转 right.rightRotate(); // 再对当前节点进行左旋转 leftRotate(); } else { leftRotate(); } return; // 必须要，非常关键，否则代码将往下走 } // 如果 （左子树的高度 - 右子树的高度）&gt; 1 ，那么就进行右旋转 if (leftHeight() - rightHeight() &gt; 1) { // 如果它的左子树的右子树高度大于它的左子树的高度 if (left != null &amp;&amp; left.rightHeight() &gt; left.leftHeight()) { // 先对当前节点的左节点（左子树）进行左旋转 left.leftRotate(); // 再对当前节点进行右旋转 rightRotate(); } else { rightRotate(); } } } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } // 中序遍历 public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } }} 多路查找树 TIPS： 此部分的内容比较少用，且难度大。 所以这里只是简单的做一些概念了解，需要深入的同学请自行查阅资料！！！ 二叉树和 B 树 2-3 树和 2-3-4 树 B 树、B+ 树和 B* 树 图的知识 为什么会有图这种数据结构？ 原因：当我们需要表示多对多关系时，就要用到图这种数据结构。 图的举例说明图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为 边 。 结点也可以称为 顶点 。如图： 图的常用概念在学习图的过程中，理解常用概念是非常必要的，如下图： 图的表示方式 图的表示方式有两种： 1、二维数组表示（邻接矩阵） 2、链表表示（邻接表） 邻接矩阵邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是的 row 和 col 表示的是 1….n 个点。图与邻接矩阵的关系以及解释如下： 邻接表邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失。邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组 + 链表组成，如下图： 图的入门案例要求: 代码实现下面的图结构： 代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * @Author: guoshizhan * @Create: 2020/4/9 23:50 * @Description: 图的入门案例 */public class Main { public static void main(String[] args) { // 1-初始化图 int nodeNum = 5; // 结点个数 String[] str = {\"A\", \"B\", \"C\", \"D\", \"E\"}; // 5个结点 // 2-创建图对象 Graph graph = new Graph(nodeNum); // 3-把上面定义的 5 个顶点添加到图中 for(String vertex : str){ graph.insertVertex(vertex); } // 4-添加边 A-B A-C B-C B-D B-E graph.insertEdge(0, 1, 1); // 表示 A-B 这条边 graph.insertEdge(0, 2, 1); // 表示 A-C 这条边 graph.insertEdge(1, 2, 1); // 表示 B-C 这条边 graph.insertEdge(1, 3, 1); // 表示 B-D 这条边 graph.insertEdge(1, 4, 1); // 表示 B-E 这条边 // 5-把创建的图的邻接矩阵显示出来 graph.showGraph(); }}// 创建一个图的类class Graph { private ArrayList&lt;String&gt; vertexList; // 存储顶点集合 private int[][] edges; // 存储图对应的邻结矩阵 private int numOfEdges; // 表示边的数目 private boolean[] isVisited; // 记录某个结点是否被访问 // 01-编写构造器，n 代表图的结点个数 public Graph(int n) { // 初始化矩阵和 vertexList edges = new int[n][n]; vertexList = new ArrayList&lt;String&gt;(); numOfEdges = 0; } // 02-插入结点 public void insertVertex(String vertex) { vertexList.add(vertex); } // 03-添加边（无向图）。v1 表示某个顶点下标，v2 表示另一个顶点下标，weight 表示这两个顶点是否相连，是的话 weight = 1，否则等于 0 public void insertEdge(int v1, int v2, int weight) { edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; } // 04-返回结点个数 public int getNumOfVertex() { return vertexList.size(); } // 05-显示图所对应的矩阵 public void showGraph() { for (int[] link : edges) { System.out.println(Arrays.toString(link)); } } // 06-得到边的数目 public int getNumOfEdges() { return numOfEdges; } // 07-返回结点i(下标)对应的数据。例如：0-&gt;\"A\" 1-&gt;\"B\" 2-&gt;\"C\" public String getValueByIndex(int i) { return vertexList.get(i); } // 08-返回 v1和v2 的权值 public int getWeight(int v1, int v2) { return edges[v1][v2]; } // 09-得到第一个邻接结点的下标 w public int getFirstNeighbor(int index) { for (int i = 0; i &lt; vertexList.size(); i++) { if (edges[index][i] &gt; 0) { return i; } } return -1; } // 10-根据前一个邻接结点的下标来获取下一个邻接结点 public int getNextNeighbor(int v1, int v2) { for (int i = v2 + 1; i &lt; vertexList.size(); i++) { if (edges[v1][v2] &gt; 0) { return i; } } return -1; }} 图的遍历 图的遍历： 所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有以下两种访问策略: 1、深度优先遍历 2、广度优先遍历 深度优先遍历(DFS)深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。显然，深度优先搜索是一个递归的过程。 深度优先遍历算法步骤： 1、访问初始结点v，并标记结点 v 为已访问。 2、查找结点 v 的第一个邻接结点 w 。 3、若 w 存在，则执行 4 ，如果 w 不存在，则回到第 1 步，将从 v 的下一个结点继续。 4、若 w 未被访问，对 w 进行深度优先遍历递归（即把w当做另一个 v ，然后进行步骤 123）。 5、查找结点 v 的 w 邻接结点的下一个邻接结点，转到步骤3。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** * @Author: guoshizhan * @Create: 2020/4/9 23:50 * @Description: 深度优先遍历测试 * @Ohter： 如果出现中文乱码，那就把编码改为 GBK */public class Graph { //int[] arr = {20,30,10,80,70,60,50,40,90}; private ArrayList&lt;String&gt; vertexList; // 存储顶点集合 private int[][] edges; // 存储图对应的邻结矩阵 private int numOfEdges; // 表示边的数目 private boolean[] isVisited; // 记录某个结点是否被访问 public static void main(String[] args) { // 1-初始化图 String[] str = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"}; // 8 个结点 // 2-创建图对象 Graph graph = new Graph(8); // 3-把 8 个顶点添加到图中 for (String vertex : str) { graph.insertVertex(vertex); } // 4-添加边 graph.insertEdge(0, 1); graph.insertEdge(0, 2); graph.insertEdge(1, 3); graph.insertEdge(1, 4); graph.insertEdge(3, 7); graph.insertEdge(4, 7); graph.insertEdge(2, 5); graph.insertEdge(2, 6); graph.insertEdge(5, 6); // 5-把创建的图的邻接矩阵显示出来 graph.showGraph(); // 6-深度优先遍历DFS测试 System.out.println(\"\\n深度优先遍历顺序如下：\"); graph.dfs(); } // 01-编写构造器，n 代表图的结点个数 public Graph(int n) { // 初始化矩阵和 vertexList edges = new int[n][n]; vertexList = new ArrayList&lt;String&gt;(); numOfEdges = 0; } // 02-插入结点 public void insertVertex(String vertex) { vertexList.add(vertex); } // 03-添加边（无向图）。v1 表示某个顶点下标，v2 表示另一个顶点下标 public void insertEdge(int v1, int v2) { edges[v1][v2] = 1; edges[v2][v1] = 1; numOfEdges++; } // 04-返回结点个数 public int getNumOfVertex() { return vertexList.size(); } // 05-显示图所对应的矩阵 public void showGraph() { for (int[] link : edges) { System.out.println(Arrays.toString(link)); } } // 06-得到边的数目 public int getNumOfEdges() { return numOfEdges; } // 07-返回结点i(下标)对应的数据。例如：0-&gt;\"A\" 1-&gt;\"B\" 2-&gt;\"C\" public String getValueByIndex(int i) { return vertexList.get(i); } // 08-返回 v1和v2 的权值 public int getWeight(int v1, int v2) { return edges[v1][v2]; } // 09-得到第一个邻接结点的下标 w public int getFirstNeighbor(int index) { for (int i = 0; i &lt; vertexList.size(); i++) { if (edges[index][i] &gt; 0) { return i; } } return -1; } // 10-根据前一个邻接结点的下标来获取下一个邻接结点 public int getNextNeighbor(int v1, int v2) { for (int i = v2 + 1; i &lt; vertexList.size(); i++) { if (edges[v1][i] &gt; 0) { return i; } } return -1; } // 11-深度优先遍历算法，i 第一次就是 0 private void dfs(boolean[] isVisited, int i) { // 访问 i 结点并输出 System.out.print(getValueByIndex(i) + \"--&gt;\"); // 将结点设置为已访问 isVisited[i] = true; // 查找结点 i 的第一个邻接结点 w int w = getFirstNeighbor(i); // while 循环里面的条件代码 i 有邻接结点 w while (w != -1) { if (!isVisited[w]) { dfs(isVisited, w); } // 如果 w 结点已访问，那么再去找 i 的其他邻接结点 w = getNextNeighbor(i, w); } } // 12-深度优先遍历算法开始 public void dfs() { isVisited = new boolean[vertexList.size()]; // 遍历所有结点，进行 dfs 回溯 for (int i = 0; i &lt; getNumOfVertex(); i++) { if (!isVisited[i]) { dfs(isVisited, i); } } }} 广度优先遍历(BFS)图的广度优先搜索(Broad First Search) ，类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点 具体实现步骤： 1、访问初始结点v并标记结点v为已访问。 2、结点v入队列 3、当队列非空时，继续执行，否则算法结束。 4、出队列，取得队头结点u。 6、查找结点u的第一个邻接结点w。 6、若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤： &nbsp;&nbsp;6.1 若结点w尚未被访问，则访问结点w并标记为已访问。 &nbsp;&nbsp;6.2 结点w入队列 &nbsp;&nbsp;6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。 广度优先遍历代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199/** * @Author: guoshizhan * @Create: 2020/4/9 23:50 * @Description: 广度优先遍历测试 * @Ohter： 如果出现中文乱码，那就把编码改为 GBK */public class Main { public static void main(String[] args) { // 1-初始化图 int nodeNum = 5; // 结点个数 String[] str = {\"A\", \"B\", \"C\", \"D\", \"E\"}; // 5个结点 // 2-创建图对象 Graph graph = new Graph(nodeNum); // 3-把上面定义的 5 个顶点添加到图中 for (String vertex : str) { graph.insertVertex(vertex); } // 4-添加边 A-B A-C B-C B-D B-E graph.insertEdge(0, 1, 1); // 表示 A-B 这条边 graph.insertEdge(0, 2, 1); // 表示 A-C 这条边 graph.insertEdge(1, 2, 1); // 表示 B-C 这条边 graph.insertEdge(1, 3, 1); // 表示 B-D 这条边 graph.insertEdge(1, 4, 1); // 表示 B-E 这条边 // 5-把创建的图的邻接矩阵显示出来 graph.showGraph(); // 6-深度优先遍历DFS测试 System.out.println(\"\\n深度优先遍历顺序如下：\"); graph.dfs(); // 7-广度优先遍历BFS测试 System.out.println(\"\\n广度优先遍历顺序如下：\"); graph.bfs(); }}// 创建一个图的类class Graph { private ArrayList&lt;String&gt; vertexList; // 存储顶点集合 private int[][] edges; // 存储图对应的邻结矩阵 private int numOfEdges; // 表示边的数目 private boolean[] isVisited; // 记录某个结点是否被访问 // 01-编写构造器，n 代表图的结点个数 public Graph(int n) { // 初始化矩阵和 vertexList edges = new int[n][n]; vertexList = new ArrayList&lt;String&gt;(); numOfEdges = 0; } // 02-插入结点 public void insertVertex(String vertex) { vertexList.add(vertex); } // 03-添加边（无向图）。v1 表示某个顶点下标，v2 表示另一个顶点下标，weight 表示这两个顶点是否相连，是的话 weight = 1，否则等于 0 public void insertEdge(int v1, int v2, int weight) { edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; } // 04-返回结点个数 public int getNumOfVertex() { return vertexList.size(); } // 05-显示图所对应的矩阵 public void showGraph() { for (int[] link : edges) { System.out.println(Arrays.toString(link)); } } // 06-得到边的数目 public int getNumOfEdges() { return numOfEdges; } // 07-返回结点i(下标)对应的数据。例如：0-&gt;\"A\" 1-&gt;\"B\" 2-&gt;\"C\" public String getValueByIndex(int i) { return vertexList.get(i); } // 08-返回 v1和v2 的权值 public int getWeight(int v1, int v2) { return edges[v1][v2]; } // 09-得到第一个邻接结点的下标 w public int getFirstNeighbor(int index) { for (int i = 0; i &lt; vertexList.size(); i++) { if (edges[index][i] &gt; 0) { return i; } } return -1; } // 10-根据前一个邻接结点的下标来获取下一个邻接结点 public int getNextNeighbor(int v1, int v2) { for (int i = v2 + 1; i &lt; vertexList.size(); i++) { if (edges[v1][v2] &gt; 0) { return i; } } return -1; } // 11-深度优先遍历算法，i 第一次就是 0 private void dfs(boolean[] isVisited, int i) { // 访问 i 结点并输出 if (i == vertexList.size() - 1) { System.out.println(getValueByIndex(i)); } else { System.out.print(getValueByIndex(i) + \"--&gt;\"); } // 将结点设置为已访问 isVisited[i] = true; // 查找结点 i 的第一个邻接结点 w int w = getFirstNeighbor(i); // while 循环里面的条件代码 i 有邻接结点 w while (w != -1) { if (!isVisited[w]) { dfs(isVisited, w); } // 如果 w 结点已访问，那么再去找 i 的其他邻接结点 w = getNextNeighbor(i, w); } } // 12-深度优先遍历算法开始 public void dfs() { isVisited = new boolean[vertexList.size()]; // 遍历所有结点，进行 dfs 回溯 for (int i = 0; i &lt; getNumOfVertex(); i++) { if (!isVisited[i]) { dfs(isVisited, i); } } } // 13-广度优先遍历算法 private void bfs(boolean[] isVisited, int i) { int u; // 表示队列的头节点对应下标 int w; // 邻接结点 // 创建集合队列，记录结点访问顺序 LinkedList queue = new LinkedList(); // 访问结点，输出结点信息 if (i == vertexList.size() - 1) { System.out.println(getValueByIndex(i)); } else { System.out.print(getValueByIndex(i) + \"--&gt;\"); } // 标记此结点以访问 isVisited[i] = true; // 将结点加入队列 queue.addLast(i); while (!queue.isEmpty()) { // 取出队列头节点下标 u = (Integer) queue.removeFirst(); // 得到第一个邻接结点的下标 w w = getFirstNeighbor(u); while (w != -1) { // 是否访问过 if (!isVisited[w]) { if (w == vertexList.size() - 1) { System.out.println(getValueByIndex(w)); } else { System.out.print(getValueByIndex(w) + \"--&gt;\"); } // 标记此结点以访问 isVisited[w] = true; // 入队 queue.addLast(w); } // 以 u 为前驱点，找 w 的下一个邻接点 w = getNextNeighbor(u, w); } } } // 14-广度优先遍历算法开始 public void bfs() { isVisited = new boolean[vertexList.size()]; for (int i = 0; i &lt; getNumOfVertex(); i++) { if (!isVisited[i]) { bfs(isVisited, i); } } }} 两种遍历方式对比上面的例子中，两种遍历方式的结果都是一样的，无法对比出来。现在以下图例子进行举例，结果截然不同。如下： 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203/** * @Author: guoshizhan * @Create: 2020/4/9 23:50 * @Description: 深度优先遍历测试 * @Ohter： 如果出现中文乱码，那就把编码改为 GBK */public class Main { public static void main(String[] args) { // 1-初始化图 int nodeNum = 8; // 结点个数 String[] str = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"};; // 8 个结点 // 2-创建图对象 Graph graph = new Graph(nodeNum); // 3-把上面定义的 5 个顶点添加到图中 for (String vertex : str) { graph.insertVertex(vertex); } // 4-添加边 graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); graph.insertEdge(3, 7, 1); graph.insertEdge(4, 7, 1); graph.insertEdge(2, 5, 1); graph.insertEdge(2, 6, 1); graph.insertEdge(5, 6, 1); // 5-把创建的图的邻接矩阵显示出来 graph.showGraph(); // 6-深度优先遍历DFS测试 System.out.println(\"\\n深度优先遍历顺序如下：\"); graph.dfs(); // 7-广度优先遍历BFS测试 System.out.println(\"\\n广度优先遍历顺序如下：\"); graph.bfs(); }}// 创建一个图的类class Graph { private ArrayList&lt;String&gt; vertexList; // 存储顶点集合 private int[][] edges; // 存储图对应的邻结矩阵 private int numOfEdges; // 表示边的数目 private boolean[] isVisited; // 记录某个结点是否被访问 // 01-编写构造器，n 代表图的结点个数 public Graph(int n) { // 初始化矩阵和 vertexList edges = new int[n][n]; vertexList = new ArrayList&lt;String&gt;(); numOfEdges = 0; } // 02-插入结点 public void insertVertex(String vertex) { vertexList.add(vertex); } // 03-添加边（无向图）。v1 表示某个顶点下标，v2 表示另一个顶点下标，weight 表示这两个顶点是否相连，是的话 weight = 1，否则等于 0 public void insertEdge(int v1, int v2, int weight) { edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; } // 04-返回结点个数 public int getNumOfVertex() { return vertexList.size(); } // 05-显示图所对应的矩阵 public void showGraph() { for (int[] link : edges) { System.out.println(Arrays.toString(link)); } } // 06-得到边的数目 public int getNumOfEdges() { return numOfEdges; } // 07-返回结点i(下标)对应的数据。例如：0-&gt;\"A\" 1-&gt;\"B\" 2-&gt;\"C\" public String getValueByIndex(int i) { return vertexList.get(i); } // 08-返回 v1和v2 的权值 public int getWeight(int v1, int v2) { return edges[v1][v2]; } // 09-得到第一个邻接结点的下标 w public int getFirstNeighbor(int index) { for (int i = 0; i &lt; vertexList.size(); i++) { if (edges[index][i] &gt; 0) { return i; } } return -1; } // 10-根据前一个邻接结点的下标来获取下一个邻接结点 public int getNextNeighbor(int v1, int v2) { for (int i = v2 + 1; i &lt; vertexList.size(); i++) { if (edges[v1][v2] &gt; 0) { return i; } } return -1; } // 11-深度优先遍历算法，i 第一次就是 0 private void dfs(boolean[] isVisited, int i) { // 访问 i 结点并输出 if (i == vertexList.size() - 1) { System.out.println(getValueByIndex(i)); } else { System.out.print(getValueByIndex(i) + \"--&gt;\"); } // 将结点设置为已访问 isVisited[i] = true; // 查找结点 i 的第一个邻接结点 w int w = getFirstNeighbor(i); // while 循环里面的条件代码 i 有邻接结点 w while (w != -1) { if (!isVisited[w]) { dfs(isVisited, w); } // 如果 w 结点已访问，那么再去找 i 的其他邻接结点 w = getNextNeighbor(i, w); } } // 12-深度优先遍历算法开始 public void dfs() { isVisited = new boolean[vertexList.size()]; // 遍历所有结点，进行 dfs 回溯 for (int i = 0; i &lt; getNumOfVertex(); i++) { if (!isVisited[i]) { dfs(isVisited, i); } } } // 13-广度优先遍历算法 private void bfs(boolean[] isVisited, int i) { int u; // 表示队列的头节点对应下标 int w; // 邻接结点 // 创建集合队列，记录结点访问顺序 LinkedList queue = new LinkedList(); // 访问结点，输出结点信息 if (i == vertexList.size() - 1) { System.out.println(getValueByIndex(i)); } else { System.out.print(getValueByIndex(i) + \"--&gt;\"); } // 标记此结点以访问 isVisited[i] = true; // 将结点加入队列 queue.addLast(i); while (!queue.isEmpty()) { // 取出队列头节点下标 u = (Integer) queue.removeFirst(); // 得到第一个邻接结点的下标 w w = getFirstNeighbor(u); while (w != -1) { // 是否访问过 if (!isVisited[w]) { if (w == vertexList.size() - 1) { System.out.println(getValueByIndex(w)); } else { System.out.print(getValueByIndex(w) + \"--&gt;\"); } // 标记此结点以访问 isVisited[w] = true; // 入队 queue.addLast(w); } // 以 u 为前驱点，找 w 的下一个邻接点 w = getNextNeighbor(u, w); } } } // 14-广度优先遍历算法开始 public void bfs() { isVisited = new boolean[vertexList.size()]; for (int i = 0; i &lt; getNumOfVertex(); i++) { if (!isVisited[i]) { bfs(isVisited, i); } } }} 数据结构的知识点到这里就结束了。如果有错误请评论指出，方便改正。该篇文章也会持续更新，查漏补缺，希望能够对大家有帮助。 番外篇，哈哈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238数据结构：逻辑结构和物理结构（数据在计算机内部的物理存储方式）数据元素存储形式：顺序存储结构和链式存储结构（银行排队叫号系统）逻辑结构：集合结构、线性结构、树形结构（金字塔关系）、图形结构了解：六度空间理论了解算法：就是解决问题的方法。例如：求从1加到100的和。使用for循环和等差公式，对计算机来说都没有什么差别，但加到10000000就差别大了，这就是算法。算法5个特性：零个或多个输入、至少一个或多个输出、有穷性、确定性和可行性。算法设计要求：正确性、可读性、健壮性、时间效率高和存储量低。时间复杂度（渐近时间复杂度）：使用大O体现算法时间复杂度，成为大O计法。线性阶：非嵌套循环涉及线性阶，对应次数成直线增长。平方阶：两个嵌套循环涉及平方阶。对数阶：例如下面的程序：2的x次方=n，求解之后x=log（2）n，所以时间复杂度为O（logn）还有常数阶，立方阶，指数阶。nlogn阶。int i = 1, n = 100;while(i &lt; n){i = i * 2;}最坏情况：平均情况：平均运行时间就是期望运行时间。空间复杂度：写代码时，可以用空间换取时间。闰年算法的例子。 线性表：存和读的情况：时间复杂度为O(1)插入和删除情况：时间复杂度为O(n)单链表：结点：数据域和指针域合在一起叫做结点数据域：存放数据的地方指针域：存放下一个地址的地方第一个结点叫做头结点（头指针）头结点一般不存储任何东西，头指针指向头结点，最后一个结点指向NULL下一次看线性表第6集======================================认识时间复杂度，用big O表示二分搜索，时间复杂度O（log2N）外排（谁小谁移动）题目：给定一个M个数的数组a和N个数的数组B，数组a乱序，数组b顺序，求两个数组共有多少个相同的数的复杂度？第一种：嵌套for循环，复杂度为O（M*N）第二种：对数组b（数组b是顺序的）使用二分查找，时间复杂度O（M*log2N）第三种：使用外排，先对数组a进行排序，然后使用外排，就是将两个数组的索引指向0，指向数字谁小谁就往下移动一个位置，直到结束。选择排序：第一次排序把最小的放在第一位，第二次排序把第二小的数字放在第二位，以此类推，直至结束。这种排序和数据状况没有关系，即便是一个排好的数组，它的时间复杂度仍然不变。冒泡排序：在一个数组中，相邻位置的数进行比较。进行完第一轮排序，最大的数字会在最后一个位置。那么下一轮排序就不用比较最后一个数字了。这种排序和数据状况没有关系，即便是一个排好的数组，它的时间复杂度仍然不变。插入排序：就像打扑克牌一样，一副排好序的牌，然后你摸了一张牌，就要给这张牌找位置，这就是插入排序。插入排序和数据状况有关，例如：数组元素1，2，3，4，5，那么插入排序复杂度为O（N），如果是5，4，3，2，1，那么复杂度为O（N2）.一般情况下，都是按照最坏情况作为一个算法的复杂度。最好情况：平均情况：最坏情况：以上三种情况在插入排序可见，自己百度以下平均情况。对数器【很重要的】：方法在排序代码里有。先要有随机数组产生器，然后需要绝对正确的方法，接着进行大样本的测试。堆的结构准备模板，排序、二叉树、数组也要准备对数器模板。冒泡和选择公司已经不使用了，只具有参考和教学意义。递归算法：1：38：26 递归如何求时间复杂度？1：51：49 时间复杂度求解公式1：54：30归并排序：master公式复杂度为O（N*log2N）计算机网络看视频从第一章开始看，同时参观CSDN别人的博客。===============================韩顺平老师数据结构：===============================KMP算法：汉诺塔问题：使用分治算法八皇后问题：使用回溯算法骑士周游问题：DFS+贪心算法场合不同，所使用的算法不一样五子棋程序约瑟夫问题【单向环形链表】稀疏数组和队列队列的应用：队列是个有序列表，可以用数组或者链表实现。特点：先进先出队列加数据在尾部加入，且rear+1，取数据在头部取，且front+1。queue包里面代码：数组实现队列和链表实现队列。数组模拟成环形队列。栈的应用：如子弹的弹夹，最先压入的子弹最后打出。线性表：自己补充单链表知识：看完写博客双向链表：（环形链表）约瑟夫环：排序算法：内容在 PPT 上已看：50 51 冒泡排序：选择排序：插入排序：希尔排序：快速排序：归并排序：基数排序：桶排序：堆排序：计数排序：查找算法：顺序（线性）查找：二分查找/折半查找：插值查找： 非常的牛逼斐波那契查找（黄金分割查找）：哈希表：二叉树：- 各种二叉树术语- 三种遍历方式- 二叉树的查找- 二叉树的删除- 顺序存储二叉树- 线索化二叉树- 堆排序：先变成大顶堆，然后排序赫夫曼树：wpl最小的就是赫夫曼树，赫夫曼树也是二叉树赫夫曼编码：不要前缀编码，就是不要出现二义性赫夫曼压缩赫夫曼解压二叉排序树：- 创建- 遍历- 删除平衡二叉树：- 左旋转- 右旋转- 双旋转多叉树：B树- 2-3树- 234树B+树B*树多路查找树图：图的基本术语图的邻接矩阵图的邻接表图的遍历方式：- 深度优先遍历（DFS）- 广度优先遍历（BFS）想要理解清楚 DFS 和 BFS 的区别，就要以图的邻接矩阵为例子，更好理解一点。程序员常用的 10 中算法：- 二分查找算法（非递归）- 分治算法（汉诺塔问题）【使用了递归算法】- 动态规划算法（背包问题）- KMP 算法（字符串匹配问题）- 暴力匹配算法- 贪心算法- 普利姆算法（prim算法）（修路问题）（最小生成树问题）- 克鲁斯卡尔算法（公交站问题）- 迪杰斯特拉算法（最短路径问题）- 弗洛伊德算法- 马踏棋盘算法（骑士周游问题）卖油翁和老黄牛的故事：在通往成功的路上，我们必须坚持，不要中途放弃，自毁前程，而要勇往直前，坚持不懈，最终会抵达理想的彼岸。既然选择了远方，便只顾风雨兼程。","link":"/Structure.html"}],"tags":[{"name":"AJAX","slug":"AJAX","link":"/tags/AJAX/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Jenkins","slug":"Jenkins","link":"/tags/Jenkins/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"IDEA教程","slug":"IDEA教程","link":"/tags/IDEA%E6%95%99%E7%A8%8B/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"mybatis","slug":"mybatis","link":"/tags/mybatis/"},{"name":"SSM","slug":"SSM","link":"/tags/SSM/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"icarus主题","slug":"icarus主题","link":"/tags/icarus%E4%B8%BB%E9%A2%98/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"故事","slug":"故事","link":"/tags/%E6%95%85%E4%BA%8B/"},{"name":"常用 API","slug":"常用-API","link":"/tags/%E5%B8%B8%E7%94%A8-API/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"hello world","slug":"hello-world","link":"/tags/hello-world/"},{"name":"Oracle数据库","slug":"Oracle数据库","link":"/tags/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PL/SQL","slug":"PL-SQL","link":"/tags/PL-SQL/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"CMD命令","slug":"CMD命令","link":"/tags/CMD%E5%91%BD%E4%BB%A4/"},{"name":"windows教程","slug":"windows教程","link":"/tags/windows%E6%95%99%E7%A8%8B/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"常用算法","link":"/tags/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"IO 流","slug":"IO-流","link":"/tags/IO-%E6%B5%81/"},{"name":"Java集合","slug":"Java集合","link":"/tags/Java%E9%9B%86%E5%90%88/"},{"name":"网络编程","slug":"网络编程","link":"/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"反射注解","slug":"反射注解","link":"/tags/%E5%8F%8D%E5%B0%84%E6%B3%A8%E8%A7%A3/"},{"name":"函数式编程","slug":"函数式编程","link":"/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"Layui 博客","slug":"Layui-博客","link":"/tags/Layui-%E5%8D%9A%E5%AE%A2/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"前端知识","slug":"前端知识","link":"/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java学习","slug":"Java学习","link":"/categories/Java%E5%AD%A6%E4%B9%A0/"},{"name":"教程工具","slug":"教程工具","link":"/categories/%E6%95%99%E7%A8%8B%E5%B7%A5%E5%85%B7/"},{"name":"数据结构和算法","slug":"数据结构和算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"C-python-Linux","slug":"C-python-Linux","link":"/categories/C-python-Linux/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"大学-生活-其他","slug":"大学-生活-其他","link":"/categories/%E5%A4%A7%E5%AD%A6-%E7%94%9F%E6%B4%BB-%E5%85%B6%E4%BB%96/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}