<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 4.2.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>Java 基础（下篇） - 何年の再遇见</title>


    <meta name="description" content="Collection 集合集合概述在 Java 基础（中篇） 已经学习过并使用过集合 ArrayList&lt;E&gt; ,那么集合到底是什么呢?集合是  java  中提供的一种容器，可以用来存储多个数据。那么集合和数组既然都是容器，它们之间有什么区别呢？">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 基础（下篇）">
<meta property="og:url" content="https://guoshizhan.github.io/JavaSE-03.html">
<meta property="og:site_name" content="何年の再遇见">
<meta property="og:description" content="Collection 集合集合概述在 Java 基础（中篇） 已经学习过并使用过集合 ArrayList&lt;E&gt; ,那么集合到底是什么呢?集合是  java  中提供的一种容器，可以用来存储多个数据。那么集合和数组既然都是容器，它们之间有什么区别呢？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://guoshizhan.github.io/gallery/Java-Study/JavaSE-000.jpg">
<meta property="article:published_time" content="2020-03-18T09:57:32.000Z">
<meta property="article:modified_time" content="2020-05-16T08:42:37.197Z">
<meta property="article:author" content="Java Developer">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java基础">
<meta property="article:tag" content="Java集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://guoshizhan.github.io/gallery/Java-Study/JavaSE-000.jpg">







<link rel="icon" href="/images/favicon.ico">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/GSZ's-Blog.png" alt="Java 基础（下篇）" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">首页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/categories">分类</a>
                
                <a class="navbar-item"
                href="/tags">标签</a>
                
                <a class="navbar-item"
                href="/friends">友链</a>
                
                <a class="navbar-item"
                href="/albums">相册</a>
                
                <a class="navbar-item"
                href="/media">影音</a>
                
                <a class="navbar-item"
                href="/inspiration">随笔</a>
                
                <a class="navbar-item"
                href="/secret">私密</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" rel="noopener" title="MyGitHub" href="https://github.com/guoshizhan">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-9-desktop is-9-widescreen has-order-2 column-main">
<div class="card">
    
    <div class="card-image">
        <span  class="image is-7by1">
            <img class="thumbnail" src="/../gallery/Java-Study/JavaSE-000.jpg" alt="Java 基础（下篇）">
        </span>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                
                <time class="level-item has-text-grey" datetime="2020-03-18T09:57:32.000Z">2020-03-18</time>
                
                    <span class="display-none-class"></span>
                    <img class="not-gallery-item" src="/images/chat.svg">&nbsp;<a href="/JavaSE-03.html#comment-container"><span></span></a>&nbsp;&nbsp;&nbsp;&nbsp;</img>
                
                
                <div class="level-item">
                <i class="fas fa-folder-open has-text-grey"></i>&nbsp;
                <a class="has-link-grey -link" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    2 小时 读完 (大约 21410 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                Java 基础（下篇）
            
        </h1>
        <div class="content">
            <hr>
<h1 id="Collection-集合"><a href="#Collection-集合" class="headerlink" title="Collection 集合"></a>Collection 集合</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p>在 <a href="https://guoshizhan.club/JavaSE-02.html#ArrayList-%E7%B1%BB">Java 基础（中篇）</a> 已经学习过并使用过集合 <code>ArrayList&lt;E&gt;</code> ,那么集合到底是什么呢?集合是  java  中提供的一种容器，可以用来存储多个数据。那么集合和数组既然都是容器，它们之间有什么区别呢？</p>
<a id="more"></a>

<div class="green">
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i>
        <span>数组和集合的区别：</span>
    </div>
    <div class="block">
    1、数组的长度是固定的。集合的长度是可变的。
    2、数组中存储的是同一类型的元素，可以存储基本数据类型值，也可以存储对象。集合存储的都是对象，而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。
    </div>
</div>

<p>来看下图，了解集合：</p>
<p><img src="../gallery/Java-Study/JavaSE-03/001.bmp" alt=""></p>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p>JavaSE 提供了满足各种需求的 API，在使用这些 API 前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合 <code>java.util.Collection</code> 和双列集合 <code>java.util.Map</code> 。</p>
<div class="blue">
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i>
        <span>Collection 集合：</span>
    </div>
    <div class="block">
    1、Collection 集合：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是 List 和 Set 。
    2、List 集合：List 的特点是 <b>元素有序、元素可重复</b>。List 的主要实现类有 ArrayList 和 LinkedList。
    3、Set 集合：Set 的特点是 <b>元素无序，而且不可重复</b>。Set 的主要实现类有 HashSet  和 TreeSet。
    </div>
</div>

<p>从上面的描述可以看出 JDK 中提供了丰富的集合类库，为了便于进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p>
<p><img src="../gallery/Java-Study/JavaSE-03/002.png" alt=""></p>
<p>其中，橙色框代表接口类型，而蓝色框代表具体的实现类。集合本身是一个工具，它存放在 java.util 包中。在 <strong>Collection</strong> 接口中定义着单列集合框架中最最共性的内容。</p>
<h2 id="Collection-常用功能"><a href="#Collection-常用功能" class="headerlink" title="Collection 常用功能"></a>Collection 常用功能</h2><p>Collection 是所有单列集合的父接口，因此在 Collection 中定义了单列集合( List 和 Set ) <strong>通用</strong> 的一些方法，这些方法可用于操作所有的单列集合。这些通用方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p>代码实例演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.Collection 接口,所有单列集合的最顶层的接口,里边定义了所有单列集合共性的方法,任意的单列集合都可以使用 Collection 接口中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 01-创建集合对象,可以使用多态,只要实现了 Collection 接口的实现类都可以，如 ArrayList、hashSet、LinkedList 等等</span></span><br><span class="line">    Collection&lt;String&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//    Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();</span></span><br><span class="line">    System.out.println(collection);    <span class="comment">// 结果：，说明重写了 toString 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 02-添加操作，把给定的对象添加到当前集合中,返回值是一个 boolean 值,一般都返回 true ,所以可以不用接收</span></span><br><span class="line">    <span class="keyword">boolean</span> bool01 = collection.add(<span class="string">"张三"</span>);</span><br><span class="line">    System.out.println(bool01);</span><br><span class="line">    System.out.println(collection);</span><br><span class="line">    collection.add(<span class="string">"李四"</span>);</span><br><span class="line">    collection.add(<span class="string">"李四"</span>);</span><br><span class="line">    collection.add(<span class="string">"王五"</span>);</span><br><span class="line">    collection.add(<span class="string">"赵六"</span>);</span><br><span class="line">    System.out.println(collection);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 03-删除操作，把给定的对象在当前集合中删除。返回值是一个 boolean 值,集合中存在元素,删除元素,返回 true，集合中不存在元素,删除失败,返回 false</span></span><br><span class="line">    <span class="keyword">boolean</span> bool02 = collection.remove(<span class="string">"Jack"</span>);</span><br><span class="line">    System.out.println(bool02);    <span class="comment">// 元素不存在，返回 false</span></span><br><span class="line">    <span class="keyword">boolean</span> bool03 = collection.remove(<span class="string">"李四"</span>);</span><br><span class="line">    System.out.println(bool03);    <span class="comment">// 元素存在，返回 true</span></span><br><span class="line">    System.out.println(collection);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 04-是否包含，判断当前集合中是否包含给定的对象。包含返回 true，不包含返回 false</span></span><br><span class="line">    <span class="keyword">boolean</span> bool04 = collection.contains(<span class="string">"Jack"</span>);</span><br><span class="line">    System.out.println(bool04);    <span class="comment">// 不包含，返回 false</span></span><br><span class="line">    <span class="keyword">boolean</span> bool05 = collection.contains(<span class="string">"张三"</span>);</span><br><span class="line">    System.out.println(bool05);    <span class="comment">// 包含，返回 true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 05-是否为空，集合为空返回 true,集合不为空返回 false</span></span><br><span class="line">    <span class="keyword">boolean</span> isEmpty = collection.isEmpty();</span><br><span class="line">    System.out.println(isEmpty);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 06-集合大小，返回集合中元素的个数。</span></span><br><span class="line">    <span class="keyword">int</span> size = collection.size();</span><br><span class="line">    System.out.println(size);</span><br><span class="line">    System.out.println(collection);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 07-集合转数组，把集合中的元素，存储到数组中。</span></span><br><span class="line">    Object[] objects = collection.toArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">        System.out.println(objects[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 08-清空集合操作，清空集合中所有的元素。但是不删除集合,集合还存在</span></span><br><span class="line">    collection.clear();</span><br><span class="line">    System.out.println(collection);</span><br><span class="line">    System.out.println(collection.isEmpty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器知识"><a href="#迭代器知识" class="headerlink" title="迭代器知识"></a>迭代器知识</h2><h3 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h3><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK 专门提供了一个接口 <code>java.util.Iterator</code>。Iterator 接口也是 Java 集合中的一员，但它与 Collection、Map 接口有所不同，<strong>Collection</strong> 接口与 <strong>Map</strong> 接口主要用于存储元素，而 Iterator 主要用于迭代访问（即遍历）Collection 中的元素，因此 Iterator 对象也被称为迭代器。想要遍历 Collection 集合，那么就要获取该集合迭代器完成迭代操作。</p>
<div class="blue">
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i> 
        <span>迭代的概念：</span>
    </div>
    <div class="block">
    迭代是集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。
    </div>
</div>
Iterator 接口的常用方法如下：

<ul>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<h3 id="迭代器使用"><a href="#迭代器使用" class="headerlink" title="迭代器使用"></a>迭代器使用</h3><p>接下来我们通过代码学习如何使用 Iterator 迭代集合中元素，使用代码把上述介绍的方法过一遍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 01-创建集合对象</span></span><br><span class="line">    Collection&lt;String&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 02-往集合添加元素</span></span><br><span class="line">    collection.add(<span class="string">"Lisa"</span>);</span><br><span class="line">    collection.add(<span class="string">"Jack"</span>);</span><br><span class="line">    collection.add(<span class="string">"Tom"</span>);</span><br><span class="line">    collection.add(<span class="string">"Jerry"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 03-创建迭代器，注意：Iterator&lt;E&gt; 接口也是有泛型的,迭代器的泛型跟着集合走,集合是什么泛型,迭代器就是什么泛型</span></span><br><span class="line">    Iterator&lt;String&gt; iterator = collection.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 04-使用迭代器遍历集合</span></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 05-知识拓展：使用 for 遍历集合</span></span><br><span class="line">    System.out.println(<span class="string">"==========="</span>);</span><br><span class="line">    <span class="comment">// 这个 for 循环有点儿特殊</span></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;String&gt; it = collection.iterator(); it.hasNext();)&#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 06-如果集合中没有元素，那么会抛出异常 Exception in thread "main" java.util.NoSuchElementException</span></span><br><span class="line">    Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Iterator&lt;String&gt; iterator1 = coll.iterator();</span><br><span class="line">    System.out.println(iterator1.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器原理"><a href="#迭代器原理" class="headerlink" title="迭代器原理"></a>迭代器原理</h3><p>我们在上述案例已经完成了 Iterator 遍历集合的整个过程。当遍历集合时，首先通过调用集合的 <code>iterator()</code> 方法获得迭代器对象，然后使用 <code>hashNext()</code> 方法判断集合中是否存在下一个元素，如果存在，则调用 <code>next()</code> 方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。Iterator 迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了能更好地理解迭代器的工作原理，接下来通过一个图例来演示 Iterator 对象迭代元素的过程：</p>
<p><img src="../gallery/Java-Study/JavaSE-03/003.bmp" alt=""></p>
<p>在调用 Iterator 的 next 方法之前，迭代器的索引位于第一个元素之前，即上图的 -1 位置，不指向任何元素，当第一次调用迭代器的 next 方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用 next 方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到 hasNext 方法返回 false ，表示到达了集合的末尾，终止对元素的遍历。</p>
<h2 id="增强-for-循环"><a href="#增强-for-循环" class="headerlink" title="增强 for 循环"></a>增强 for 循环</h2><p>所有的解释都在注释里面了，请看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增强 for 循环（foreach） 特点：</span></span><br><span class="line"><span class="comment"> * 1、增强 for 循环:底层使用的也是迭代器,使用 for 循环的格式,简化了迭代器的书写</span></span><br><span class="line"><span class="comment"> * 2、此 fo r循环必须有被遍历的目标，目标只能是 Collection 或者是数组。</span></span><br><span class="line"><span class="comment"> * 3、是 JDK1.5 之后出现的新特性</span></span><br><span class="line"><span class="comment"> * 4、Collection&lt;E&gt;extends Iterable&lt;E&gt;:所有的单列集合都可以使用增强 for</span></span><br><span class="line"><span class="comment"> * 5、 public interface Iterable&lt;T&gt;实现这个接口允许对象成为 "foreach" 语句的目标。</span></span><br><span class="line"><span class="comment"> * 6、格式：</span></span><br><span class="line"><span class="comment"> *         for(集合/数组的数据类型 变量名: 集合名/数组名)&#123;</span></span><br><span class="line"><span class="comment"> *             sout(变量名);</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 01-创建集合</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 02-添加数据</span></span><br><span class="line">    list.add(<span class="string">"abc"</span>);</span><br><span class="line">    list.add(<span class="string">"def"</span>);</span><br><span class="line">    list.add(<span class="string">"ghi"</span>);</span><br><span class="line">    list.add(<span class="string">"jkl"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 03-增强 for 循环遍历集合</span></span><br><span class="line">    <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 04-知识拓展：增强 for 遍历数组</span></span><br><span class="line">    System.out.println(<span class="string">"====="</span>);</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型的概述"><a href="#泛型的概述" class="headerlink" title="泛型的概述"></a>泛型的概述</h2><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<blockquote>
<p>假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？答案是可以使用 Java 泛型。使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。</p>
</blockquote>
<p>看一张图，了解泛型：</p>
<p><img src="../gallery/Java-Study/JavaSE-03/004.bmp" alt=""></p>
<h2 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h2><div class="hacker">
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i> 
        <span>泛型的好处：</span>
    </div>
    <div class="block">
    1、将运行时期的 ClassCastException，转移到了编译时期变成了编译失败。
    2、避免了类型强转的麻烦。
    </div>
</div>

<p>通过如下代码体验一下泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 01-不使用泛型案例</span></span><br><span class="line">    <span class="comment">//listDemoFirst();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 02-使用泛型案例</span></span><br><span class="line">    listDemoSecond();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建集合对象，使用泛型：</span></span><br><span class="line"><span class="comment"> * 好处：1、避免了类型转换的麻烦,存储的是什么类型,取出的就是什么类型；2、把运行期异常(代码运行之后会抛出的异常),提升到了编译期(写代码的时候会报错)</span></span><br><span class="line"><span class="comment"> * 弊端：泛型是什么类型,只能存储什么类型的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listDemoSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 01-创建集合并添加数据</span></span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(<span class="string">"Tom"</span>);</span><br><span class="line">    arrayList.add(<span class="string">"Lisa"</span>);</span><br><span class="line">    arrayList.add(<span class="string">"Jack"</span>);</span><br><span class="line"><span class="comment">//    arrayList.add(1);    //直接编译不通过，报错信息：add(java.lang.String)in ArrayList cannot be applied to (int)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 02-迭代器遍历集合</span></span><br><span class="line">    Iterator&lt;String&gt; it = arrayList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">        String string = it.next();</span><br><span class="line">        System.out.println(string + <span class="string">" --&gt; "</span> + string.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建集合对象，不使用泛型：</span></span><br><span class="line"><span class="comment"> * 好处：集合不使用泛型，默认类型就是 Object 类型，可以存储任意类型的数据</span></span><br><span class="line"><span class="comment"> * 弊端：不安全，会引发异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listDemoFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 01-创建集合并添加数据</span></span><br><span class="line">    ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="string">"Jack"</span>);</span><br><span class="line">    list.add(<span class="number">37</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 02-迭代器遍历集合</span></span><br><span class="line">    Iterator iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">// 03-取出的元素是 Object 类型的</span></span><br><span class="line">        Object object = iterator.next();</span><br><span class="line">        System.out.println(object);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 04-想要使用 String 类特有的方法,length 获取字符串的长度;不能使用多态 Object obj = "abc";</span></span><br><span class="line">        <span class="comment">// 05-需要向下转型才能使用相关类方法，然而结果抛出 ClassCastException 类型转换异常,不能把 Integer 类型转换为 String 类型，这就是弊端</span></span><br><span class="line">        String str = (String)object;</span><br><span class="line">        System.out.println(str.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p>
</blockquote>
<h2 id="泛型的定义和使用"><a href="#泛型的定义和使用" class="headerlink" title="泛型的定义和使用"></a>泛型的定义和使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p>
<h3 id="有泛型的类"><a href="#有泛型的类" class="headerlink" title="有泛型的类"></a>有泛型的类</h3><p>例如，API 中的 ArrayList 集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 含有泛型的类的定义格式：修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个含有泛型的类,模拟 ArrayList 集合</span></span><br><span class="line"><span class="comment"> * 泛型是一个未知的数据类型,当我们不确定什么什么数据类型的时候,可以使用泛型</span></span><br><span class="line"><span class="comment"> * 泛型可以接收任意的数据类型,可以使用 Integer,String,Student...</span></span><br><span class="line"><span class="comment"> * 创建对象的时候确定泛型的数据类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(E name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用自定义的泛型类： 即什么时候确定泛型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 01-创建 MyArrayList 对象，不写泛型，默认为 Object 类型</span></span><br><span class="line">    MyArrayList myArrayList = <span class="keyword">new</span> MyArrayList();</span><br><span class="line">    myArrayList.setName(<span class="string">"Jack"</span>);</span><br><span class="line">    Object object = myArrayList.getName();</span><br><span class="line">    System.out.println(object);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//02-创建 MyArrayList 对象，泛型使用 Integer 类型</span></span><br><span class="line">    MyArrayList&lt;Integer&gt; integerMyArrayList = <span class="keyword">new</span> MyArrayList&lt;&gt;();</span><br><span class="line">    integerMyArrayList.setName(<span class="number">520</span>);</span><br><span class="line">    System.out.println(integerMyArrayList.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 03-创建 MyArrayList 对象，泛型使用 String 类型</span></span><br><span class="line">    MyArrayList&lt;String&gt; stringMyArrayList = <span class="keyword">new</span> MyArrayList&lt;&gt;();</span><br><span class="line">    stringMyArrayList.setName(<span class="string">"Tom"</span>);</span><br><span class="line">    System.out.println(stringMyArrayList.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有泛型的方法"><a href="#有泛型的方法" class="headerlink" title="有泛型的方法"></a>有泛型的方法</h3><p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有泛型的方法的定义格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体定义代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义含有泛型的方法：泛型定义在方法的修饰符和返回值类型之间</span></span><br><span class="line"><span class="comment"> * 格式: 修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型))&#123;</span></span><br><span class="line"><span class="comment"> *          方法体;</span></span><br><span class="line"><span class="comment"> *       &#125;</span></span><br><span class="line"><span class="comment"> * 含有泛型的方法,在调用方法的时候确定泛型的数据类型 ，传递什么类型的参数,泛型就是什么类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 01-定义一个含有泛型的方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;M&gt; <span class="function"><span class="keyword">void</span> <span class="title">method01</span><span class="params">(M m)</span></span>&#123;</span><br><span class="line">    System.out.println(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 02-定义一个含有泛型的静态方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function"><span class="keyword">void</span> <span class="title">method02</span><span class="params">(S s)</span></span>&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：<strong>调用方法时，确定泛型的类型</strong> ，相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 01-创建 GenericMethod 对象</span></span><br><span class="line">        GenericMethod genericMethod = <span class="keyword">new</span> GenericMethod();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 02-调用含有泛型的方法 method01，传递什么类型,泛型就是什么类型</span></span><br><span class="line">        genericMethod.method01(<span class="number">10</span>);</span><br><span class="line">        genericMethod.method01(<span class="string">"abc"</span>);</span><br><span class="line">        genericMethod.method01(<span class="number">3.14</span>);</span><br><span class="line">        genericMethod.method01(<span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 03-调用静态方法,通过类名.方法名(参数)可以直接使用</span></span><br><span class="line">        GenericMethod.method02(<span class="string">"静态方法"</span>);</span><br><span class="line">        GenericMethod.method02(<span class="number">1.732</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 01-定义一个含有泛型的方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;M&gt; <span class="function"><span class="keyword">void</span> <span class="title">method01</span><span class="params">(M m)</span></span>&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 02-定义一个含有泛型的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function"><span class="keyword">void</span> <span class="title">method02</span><span class="params">(S s)</span></span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有泛型的接口"><a href="#有泛型的接口" class="headerlink" title="有泛型的接口"></a>有泛型的接口</h3><p>定义格式及示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义格式：修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>含有泛型的接口的具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义含有泛型的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型接口的第一种实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 含有泛型的接口,第一种使用方式:定义接口的实现类,实现接口,指定接口的泛型</span></span><br><span class="line"><span class="comment"> * public interface Iterator&lt;E&gt; &#123;</span></span><br><span class="line"><span class="comment"> *     E next();</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * Scanner类实现了 Iterator 接口,并指定接口的泛型为 String , 所以重写的 next 方法泛型默认就是 String</span></span><br><span class="line"><span class="comment"> * public final class Scanner implements Iterator&lt;String&gt;&#123;</span></span><br><span class="line"><span class="comment"> *     public String next() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl1</span> <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型接口的第二种实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 含有泛型的接口第二种使用方式:接口使用什么泛型,实现类就使用什么泛型,类跟着接口走</span></span><br><span class="line"><span class="comment"> * 就相当于定义了一个含有泛型的类,创建对象的时候确定泛型的类型</span></span><br><span class="line"><span class="comment"> * public interface List&lt;E&gt;&#123;</span></span><br><span class="line"><span class="comment"> *     boolean add(E e);</span></span><br><span class="line"><span class="comment"> *     E get(int index);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * public class ArrayList&lt;E&gt; implements List&lt;E&gt;&#123;</span></span><br><span class="line"><span class="comment"> *     public boolean add(E e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     public E get(int index) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试含有泛型的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 01-创建 GenericInterfaceImpl1 对象</span></span><br><span class="line">        GenericInterfaceImpl1 gi1 = <span class="keyword">new</span> GenericInterfaceImpl1();</span><br><span class="line">        gi1.method(<span class="string">"字符串"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 02-创建 GenericInterfaceImpl2 对象</span></span><br><span class="line">        GenericInterfaceImpl2&lt;Integer&gt; gi2 = <span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        gi2.method(<span class="number">10</span>);</span><br><span class="line">        GenericInterfaceImpl2&lt;Double&gt; gi3 = <span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        gi3.method(<span class="number">8.8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符 &lt;?&gt; 表示。但是一旦使用泛型的通配符后，只能使用 Object 类中的共性方法，集合中元素自身方法无法使用。</p>
<h3 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h3><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用 ?, ? 表示未知通配符。</strong>此时只能接受数据,不能往该集合中存储数据。举个例子大家理解使用即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 代表可以接收任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>具体实际代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型的通配符: ? 代表任意的数据类型</span></span><br><span class="line"><span class="comment">     * 使用方式: 1、不能创建对象使用；2、只能作为方法的参数使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list01 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list01.add(<span class="number">1</span>);</span><br><span class="line">    list01.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; list02 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list02.add(<span class="string">"a"</span>);</span><br><span class="line">    list02.add(<span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">    printArray(list01);</span><br><span class="line">    printArray(list02);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个方法,能遍历所有类型的 ArrayList 集合</span></span><br><span class="line"><span class="comment"> * 这时候我们不知道 ArrayList 集合使用什么数据类型 ,可以泛型的通配符 ? 来接收数据类型</span></span><br><span class="line"><span class="comment"> * 注意: 泛型没有继承概念的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(ArrayList&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用迭代器遍历集合</span></span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:泛型不存在继承关系 <strong>Collection&lt;Object&gt; list = new ArrayList&lt;String&gt;();</strong> 这种是错误的。</p>
</blockquote>
<h3 id="通配符高级之受限泛型"><a href="#通配符高级之受限泛型" class="headerlink" title="通配符高级之受限泛型"></a>通配符高级之受限泛型</h3><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在 Java 的泛型中可以指定一个泛型的 <strong>上限</strong> 和 <strong>下限</strong> 。</p>
<div class="green">
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i> 
        <span>泛型的上限：</span>
    </div>
    <div class="block">
    1、格式： 类型名称 <b>&lt; ? extends xxx类 &gt;</b> 对象名称
    2、意义： 只能接收 xxx类型 及其子类
    </div>
</div>

<div class="green">
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i> 
        <span>泛型的下限：</span>
    </div>
    <div class="block">
    1、格式： 类型名称 <b>&lt; ? super xxx类 &gt;</b> 对象名称
    2、意义： 只能接收 xxx类型 及其父类型
    </div>
</div>

<p>比如：现已知 Object 类，String 类，Number 类，Integer 类，其中 Number 是 Integer 的父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    getElement1(list1);</span><br><span class="line">    getElement1(list2);    <span class="comment">// 报错</span></span><br><span class="line">    getElement1(list3);</span><br><span class="line">    getElement1(list4);    <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">    getElement2(list1);    <span class="comment">// 报错</span></span><br><span class="line">    getElement2(list2);    <span class="comment">// 报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是 Number 类型或者 Number 类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="斗地主案例-单列"><a href="#斗地主案例-单列" class="headerlink" title="斗地主案例(单列)"></a>斗地主案例(单列)</h2><h3 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h3><p>按照斗地主的规则，完成洗牌发牌的动作。<strong>具体规则：</strong>使用 54 张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人 17 张牌，最后三张留作底牌。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><div class="red">
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i> 
        <span>准备牌：</span>
    </div>
    <div class="block">
    牌可以设计为一个 ArrayList<String> ,每个字符串为一张牌。
    每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。
    牌由 Collections 类的 shuffle 方法进行随机排序。
    </div>
</div>

<div class="yellow">
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i> 
        <span>发牌：</span>
    </div>
    <div class="block">
    将每个人以及底牌设计为 ArrayList<String> , 将最后 3 张牌直接存放于底牌，剩余牌通过对 3 取模依次发牌。
    </div>
</div>

<div class="blue">
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i> 
        <span>看牌：</span>
    </div>
    <div class="block">
    直接打印每个集合。
    </div>
</div>

<p><img src="../gallery/Java-Study/JavaSE-03/005.bmp" alt=""></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DouDiZhu</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 斗地主综合案例：1、准备牌  2、洗牌  3、发牌  4、看牌</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 01-准备牌：定义一个存储 54 张牌的 ArrayList 集合,泛型使用 String</span></span><br><span class="line">        ArrayList&lt;String&gt; poker = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 02-定义两个数组,一个数组存储牌的花色,一个数组存储牌的序号</span></span><br><span class="line">        String[] colors = &#123;<span class="string">"♠"</span>,<span class="string">"♥"</span>,<span class="string">"♣"</span>,<span class="string">"♦"</span>&#125;;</span><br><span class="line">        String[] numbers = &#123;<span class="string">"2"</span>,<span class="string">"A"</span>,<span class="string">"K"</span>,<span class="string">"Q"</span>,<span class="string">"J"</span>,<span class="string">"10"</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"7"</span>,<span class="string">"6"</span>,<span class="string">"5"</span>,<span class="string">"4"</span>,<span class="string">"3"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 03-先把大王和小王存储到 poker 集合中</span></span><br><span class="line">        poker.add(<span class="string">"大王"</span>);</span><br><span class="line">        poker.add(<span class="string">"小王"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 05-循环嵌套遍历两个数组,组装 52 张牌</span></span><br><span class="line">        <span class="keyword">for</span>(String number : numbers)&#123;</span><br><span class="line">            <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">                <span class="comment">// 06-把组装好的牌存储到 poker 集合中</span></span><br><span class="line">                poker.add(color + number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 07-洗牌：使用集合的工具类 Collections 中的方法 static void shuffle(List&lt;?&gt; list) 使用默认随机源对指定列表进行置换。</span></span><br><span class="line">        Collections.shuffle(poker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 08-发牌：定义 4 个集合,存储玩家的牌和底牌</span></span><br><span class="line">        ArrayList&lt;String&gt; player01 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player02 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player03 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; diPai = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、遍历 poker 集合,获取每一张牌</span></span><br><span class="line"><span class="comment">         * 2、使用 poker 集合的索引 % 3 给 3 个玩家轮流发牌</span></span><br><span class="line"><span class="comment">         * 剩余 3 张牌给底牌。注意:先判断底牌(i&gt;=51),否则牌就发没了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poker.size() ; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取每一张牌</span></span><br><span class="line">            String p = poker.get(i);</span><br><span class="line">            <span class="comment">// 轮流发牌</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">51</span>)&#123;</span><br><span class="line">                <span class="comment">// 给底牌发牌</span></span><br><span class="line">                diPai.add(p);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 给 玩家1 发牌</span></span><br><span class="line">                player01.add(p);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 给 玩家2 发牌</span></span><br><span class="line">                player02.add(p);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 给 玩家3 发牌</span></span><br><span class="line">                player03.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 09-看牌</span></span><br><span class="line">        System.out.println(<span class="string">"刘德华:"</span> + player01);</span><br><span class="line">        System.out.println(<span class="string">"周润发:"</span> + player02);</span><br><span class="line">        System.out.println(<span class="string">"周星驰:"</span> + player03);</span><br><span class="line">        System.out.println(<span class="string">"底牌:"</span> + diPai);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-数据结构"><a href="#Java-数据结构" class="headerlink" title="Java 数据结构"></a>Java 数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><div class="blue">
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i> 
        <span>栈（stack）：</span>
    </div>
    <div class="block">
    1、概念：栈又称堆栈，它是运算受限的线性表，仅允许在一端进行插入和删除操作，不允许在其他任何位置进行添加、删除等操作。
    2、特点：先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。
    3、举例：子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先打出上面的子弹，然后才能打出下面的子弹。
    4、出入口：栈的入口、出口的都是栈的顶端位置。
    5、压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。
    6、弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。
    </div>
</div>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><div class="yellow">
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i> 
        <span>队列（queue）：</span>
    </div>
    <div class="block">
    1、概念：队列简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。
    2、特点：先进先出（即，先存进去的元素先取出来，后存进去的元素后取出）
    3、举例：例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。
    4、出入口：队列的入口、出口各占一侧。就像管道一样，一边进一边出。
    </div>
</div>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><div class="red">
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i> 
        <span>数组（Array）：</span>
    </div>
    <div class="block">
    1、概念：是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。
    2、特点：查找元素快（通过索引，可以快速访问指定位置的元素），增删元素慢。
    3、举例：就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。
    </div>
</div>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><div class="green">
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i> 
        <span>链表（linked list）：</span>
    </div>
    <div class="block">
    1、概念：链表由一系列结点 node（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。
    2、特点：查找元素慢（想查找某个元素，需要通过连接的节点，依次向后查找指定元素）。增删元素快，增加元素：只需要修改连接下个元素的地址即可。删除元素：只需要修改连接下个元素的地址即可。
    3、举例：多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。
    </div>
</div>

<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><div class="blue">
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i> 
        <span>二叉树（binary tree）：</span>
    </div>
    <div class="block">
    1、二叉树概念：二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。
    2、红黑树概念：红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。
    2、红黑树特点：速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍。
    </div>
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i> 
        <span>红黑树约束：</span>
    </div>
    <div class="block">
    1、节点可以是红色的或者黑色的
    2、根节点是黑色的
    3、叶子节点(特指空节点)是黑色的
    4、每个红色节点的子节点都是黑色的
    5、任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同
    </div>
</div>

<blockquote>
<p>这里写的数据结构只作为了解和参考，并没有什么实际用途。此处也没有写非常详细的东西，所以不要太在意错误或者其他无法理解的地方。如果要看数据结构，很详细的数据结构，请移步： <a href="https://guoshizhan.club/Structure.html">数据结构入门</a></p>
</blockquote>
<h1 id="List-集合"><a href="#List-集合" class="headerlink" title="List 集合"></a>List 集合</h1><p>我们掌握了 Collection 接口的使用后，再来看看 Collection 接口中的子类，他们都具备那些特性呢？接下来，我们一起学习 Collection 中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p>
<h2 id="List接口介绍"><a href="#List接口介绍" class="headerlink" title="List接口介绍"></a>List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为 List 集合。在 List 集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List 集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p>
<p>看完API，我们总结一下 List 接口特点：</p>
<ul>
<li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li>
</ul>
<blockquote>
<p>tips:我们已经学习过 List 接口的子类 java.util.ArrayList 类，该类中的方法都是来自 List 中定义。</p>
</blockquote>
<h2 id="List-中常用方法"><a href="#List-中常用方法" class="headerlink" title="List 中常用方法"></a>List 中常用方法</h2><p>List 作为 Collection 集合的子接口，不但继承了 Collection 接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p>
<ul>
<li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li>
<li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li>
<li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li>
<li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li>
</ul>
<p>List集合特有的方法都是跟索引相关，我们已经都学习过，那么我们再来复习一遍吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    java.util.List接口 extends Collection接口</span></span><br><span class="line"><span class="comment">    List接口的特点:</span></span><br><span class="line"><span class="comment">        1.有序的集合,存储元素和取出元素的顺序是一致的(存储123 取出123)</span></span><br><span class="line"><span class="comment">        2.有索引,包含了一些带索引的方法</span></span><br><span class="line"><span class="comment">        3.允许存储重复的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    List接口中带索引的方法(特有)</span></span><br><span class="line"><span class="comment">        - public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。</span></span><br><span class="line"><span class="comment">        - public E get(int index):返回集合中指定位置的元素。</span></span><br><span class="line"><span class="comment">        - public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。</span></span><br><span class="line"><span class="comment">        - public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</span></span><br><span class="line"><span class="comment">    注意:</span></span><br><span class="line"><span class="comment">        操作索引的时候,一定要防止索引越界异常</span></span><br><span class="line"><span class="comment">        IndexOutOfBoundsException:索引越界异常,集合会报</span></span><br><span class="line"><span class="comment">        ArrayIndexOutOfBoundsException:数组索引越界异常</span></span><br><span class="line"><span class="comment">        StringIndexOutOfBoundsException:字符串索引越界异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01List</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个List集合对象,多态</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//使用add方法往集合中添加元素</span></span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        list.add(<span class="string">"d"</span>);</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        <span class="comment">//打印集合</span></span><br><span class="line">        System.out.println(list);<span class="comment">//[a, b, c, d, a]  不是地址重写了toString</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。</span></span><br><span class="line">        <span class="comment">//在c和d之间添加一个itheima</span></span><br><span class="line">        list.add(<span class="number">3</span>,<span class="string">"itheima"</span>);<span class="comment">//[a, b, c, itheima, d, a]</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。</span></span><br><span class="line">        <span class="comment">//移除元素</span></span><br><span class="line">        String removeE = list.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"被移除的元素:"</span>+removeE);<span class="comment">//被移除的元素:c</span></span><br><span class="line">        System.out.println(list);<span class="comment">//[a, b, itheima, d, a]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</span></span><br><span class="line">        <span class="comment">//把最后一个a,替换为A</span></span><br><span class="line">        String setE = list.set(<span class="number">4</span>, <span class="string">"A"</span>);</span><br><span class="line">        System.out.println(<span class="string">"被替换的元素:"</span>+setE);<span class="comment">//被替换的元素:a</span></span><br><span class="line">        System.out.println(list);<span class="comment">//[a, b, itheima, d, A]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//List集合遍历有3种方式</span></span><br><span class="line">        <span class="comment">//使用普通的for循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//public E get(int index):返回集合中指定位置的元素。</span></span><br><span class="line">            String s = list.get(i);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">        <span class="comment">//使用迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String s = it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">        <span class="comment">//使用增强for</span></span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String r = list.get(<span class="number">5</span>);<span class="comment">//IndexOutOfBoundsException: Index 5 out-of-bounds for length 5</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList-集合"><a href="#ArrayList-集合" class="headerlink" title="ArrayList 集合"></a>ArrayList 集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。许多程序员开发时非常随意地使用 ArrayList 完成任何需求，并不严谨，这种用法是不提倡的。</p>
<blockquote>
<p>想要了解更多的信息，请参阅 API 或者查看他人博客。也可看先前文章：<a href="https://guoshizhan.club/JavaSE-02.html">https://guoshizhan.club/JavaSE-02.html</a></p>
</blockquote>
<h2 id="LinkedList-集合"><a href="#LinkedList-集合" class="headerlink" title="LinkedList 集合"></a>LinkedList 集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p>
<blockquote>
<p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p>
</blockquote>
<p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p>
<ul>
<li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li>
<li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li>
<li><code>public E getFirst()</code>:返回此列表的第一个元素。</li>
<li><code>public E getLast()</code>:返回此列表的最后一个元素。</li>
<li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li>
<li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li>
<li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li>
<li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li>
<li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li>
</ul>
<p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    java.util.LinkedList集合 implements List接口</span></span><br><span class="line"><span class="comment">    LinkedList集合的特点:</span></span><br><span class="line"><span class="comment">        1.底层是一个链表结构:查询慢,增删快</span></span><br><span class="line"><span class="comment">        2.里边包含了大量操作首尾元素的方法</span></span><br><span class="line"><span class="comment">        注意:使用LinkedList集合特有的方法,不能使用多态</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - public void addFirst(E e):将指定元素插入此列表的开头。</span></span><br><span class="line"><span class="comment">        - public void addLast(E e):将指定元素添加到此列表的结尾。</span></span><br><span class="line"><span class="comment">        - public void push(E e):将元素推入此列表所表示的堆栈。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - public E getFirst():返回此列表的第一个元素。</span></span><br><span class="line"><span class="comment">        - public E getLast():返回此列表的最后一个元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - public E removeFirst():移除并返回此列表的第一个元素。</span></span><br><span class="line"><span class="comment">        - public E removeLast():移除并返回此列表的最后一个元素。</span></span><br><span class="line"><span class="comment">        - public E pop():从此列表所表示的堆栈处弹出一个元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - public boolean isEmpty()：如果列表不包含元素，则返回true。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        - public E removeFirst():移除并返回此列表的第一个元素。</span></span><br><span class="line"><span class="comment">        - public E removeLast():移除并返回此列表的最后一个元素。</span></span><br><span class="line"><span class="comment">        - public E pop():从此列表所表示的堆栈处弹出一个元素。此方法相当于 removeFirst</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建LinkedList集合对象</span></span><br><span class="line">        LinkedList&lt;String&gt; linked = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//使用add方法往集合中添加元素</span></span><br><span class="line">        linked.add(<span class="string">"a"</span>);</span><br><span class="line">        linked.add(<span class="string">"b"</span>);</span><br><span class="line">        linked.add(<span class="string">"c"</span>);</span><br><span class="line">        System.out.println(linked);<span class="comment">//[a, b, c]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String first = linked.removeFirst();</span></span><br><span class="line">        String first = linked.pop();</span><br><span class="line">        System.out.println(<span class="string">"被移除的第一个元素:"</span>+first);</span><br><span class="line">        String last = linked.removeLast();</span><br><span class="line">        System.out.println(<span class="string">"被移除的最后一个元素:"</span>+last);</span><br><span class="line">        System.out.println(linked);<span class="comment">//[b]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        - public E getFirst():返回此列表的第一个元素。</span></span><br><span class="line"><span class="comment">        - public E getLast():返回此列表的最后一个元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建LinkedList集合对象</span></span><br><span class="line">        LinkedList&lt;String&gt; linked = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//使用add方法往集合中添加元素</span></span><br><span class="line">        linked.add(<span class="string">"a"</span>);</span><br><span class="line">        linked.add(<span class="string">"b"</span>);</span><br><span class="line">        linked.add(<span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//linked.clear();//清空集合中的元素 在获取集合中的元素会抛出NoSuchElementException</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public boolean isEmpty()：如果列表不包含元素，则返回true。</span></span><br><span class="line">        <span class="keyword">if</span>(!linked.isEmpty())&#123;</span><br><span class="line">            String first = linked.getFirst();</span><br><span class="line">            System.out.println(first);<span class="comment">//a</span></span><br><span class="line">            String last = linked.getLast();</span><br><span class="line">            System.out.println(last);<span class="comment">//c</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        - public void addFirst(E e):将指定元素插入此列表的开头。</span></span><br><span class="line"><span class="comment">        - public void addLast(E e):将指定元素添加到此列表的结尾。</span></span><br><span class="line"><span class="comment">        - public void push(E e):将元素推入此列表所表示的堆栈。此方法等效于 addFirst(E)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建LinkedList集合对象</span></span><br><span class="line">        LinkedList&lt;String&gt; linked = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//使用add方法往集合中添加元素</span></span><br><span class="line">        linked.add(<span class="string">"a"</span>);</span><br><span class="line">        linked.add(<span class="string">"b"</span>);</span><br><span class="line">        linked.add(<span class="string">"c"</span>);</span><br><span class="line">        System.out.println(linked);<span class="comment">//[a, b, c]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public void addFirst(E e):将指定元素插入此列表的开头。</span></span><br><span class="line">        <span class="comment">//linked.addFirst("www");</span></span><br><span class="line">        linked.push(<span class="string">"www"</span>);</span><br><span class="line">        System.out.println(linked);<span class="comment">//[www, a, b, c]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public void addLast(E e):将指定元素添加到此列表的结尾。此方法等效于 add()</span></span><br><span class="line">        linked.addLast(<span class="string">"com"</span>);</span><br><span class="line">        System.out.println(linked);<span class="comment">//[www, a, b, c, com]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vector-集合"><a href="#Vector-集合" class="headerlink" title="Vector 集合"></a>Vector 集合</h2><p>这个集合比较老了，是从 JDK1.0 版本就有的。在此只是去知道它的存在，具体用法差不多，不懂就查 Java 编程手册。</p>
<h1 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map 集合"></a>Map 集合</h1><h2 id="Map-概述"><a href="#Map-概述" class="headerlink" title="Map 概述"></a>Map 概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP 地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java 提供了专门的集合类用来存放这种对象关系的对象，即 java.util.Map 接口。</p>
<h2 id="Map-常用子类"><a href="#Map-常用子类" class="headerlink" title="Map 常用子类"></a>Map 常用子类</h2><p>通过查看 Map 接口描述，看到 Map 有多个子类，这里我们主要讲解常用的 <strong>HashMap</strong> 集合、<strong>LinkedHashMap</strong> 集合。</p>
<ul>
<li>HashMap：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
<li>LinkedHashMap：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
</ul>
<blockquote>
<p>tips：Map 接口中的集合都有两个泛型变量,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量的数据类型可以相同，也可以不同。</p>
</blockquote>
<h2 id="Map-的常用方法"><a href="#Map-的常用方法" class="headerlink" title="Map 的常用方法"></a>Map 的常用方法</h2><p>Map 的代码演示如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    java.util.Map&lt;k,v&gt;集合</span></span><br><span class="line"><span class="comment">    Map集合的特点:</span></span><br><span class="line"><span class="comment">        1.Map集合是一个双列集合,一个元素包含两个值(一个key,一个value)</span></span><br><span class="line"><span class="comment">        2.Map集合中的元素,key和value的数据类型可以相同,也可以不同</span></span><br><span class="line"><span class="comment">        3.Map集合中的元素,key是不允许重复的,value是可以重复的</span></span><br><span class="line"><span class="comment">        4.Map集合中的元素,key和value是一一对应</span></span><br><span class="line"><span class="comment">    java.util.HashMap&lt;k,v&gt;集合 implements Map&lt;k,v&gt;接口</span></span><br><span class="line"><span class="comment">    HashMap集合的特点:</span></span><br><span class="line"><span class="comment">        1.HashMap集合底层是哈希表:查询的速度特别的快</span></span><br><span class="line"><span class="comment">            JDK1.8之前:数组+单向链表</span></span><br><span class="line"><span class="comment">            JDK1.8之后:数组+单向链表|红黑树(链表的长度超过8):提高查询的速度</span></span><br><span class="line"><span class="comment">        2.hashMap集合是一个无序的集合,存储元素和取出元素的顺序有可能不一致</span></span><br><span class="line"><span class="comment">   java.util.LinkedHashMap&lt;k,v&gt;集合 extends HashMap&lt;k,v&gt;集合</span></span><br><span class="line"><span class="comment">   LinkedHashMap的特点:</span></span><br><span class="line"><span class="comment">        1.LinkedHashMap集合底层是哈希表+链表(保证迭代的顺序)</span></span><br><span class="line"><span class="comment">        2.LinkedHashMap集合是一个有序的集合,存储元素和取出元素的顺序是一致的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Map</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show04();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        boolean containsKey(Object key) 判断集合中是否包含指定的键。</span></span><br><span class="line"><span class="comment">        包含返回true,不包含返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"赵丽颖"</span>,<span class="number">168</span>);</span><br><span class="line">        map.put(<span class="string">"杨颖"</span>,<span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"林志玲"</span>,<span class="number">178</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b1 = map.containsKey(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b1:"</span>+b1);<span class="comment">//b1:true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b2 = map.containsKey(<span class="string">"赵颖"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b2:"</span>+b2);<span class="comment">//b2:false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public V get(Object key) 根据指定的键，在Map集合中获取对应的值。</span></span><br><span class="line"><span class="comment">            返回值:</span></span><br><span class="line"><span class="comment">                key存在,返回对应的value值</span></span><br><span class="line"><span class="comment">                key不存在,返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"赵丽颖"</span>,<span class="number">168</span>);</span><br><span class="line">        map.put(<span class="string">"杨颖"</span>,<span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"林志玲"</span>,<span class="number">178</span>);</span><br><span class="line"></span><br><span class="line">        Integer v1 = map.get(<span class="string">"杨颖"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v1:"</span>+v1);<span class="comment">//v1:165</span></span><br><span class="line"></span><br><span class="line">        Integer v2 = map.get(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v2:"</span>+v2);<span class="comment">//v2:null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</span></span><br><span class="line"><span class="comment">            返回值:V</span></span><br><span class="line"><span class="comment">                key存在,v返回被删除的值</span></span><br><span class="line"><span class="comment">                key不存在,v返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"赵丽颖"</span>,<span class="number">168</span>);</span><br><span class="line">        map.put(<span class="string">"杨颖"</span>,<span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"林志玲"</span>,<span class="number">178</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;林志玲=178, 赵丽颖=168, 杨颖=165&#125;</span></span><br><span class="line"></span><br><span class="line">        Integer v1 = map.remove(<span class="string">"林志玲"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v1:"</span>+v1);<span class="comment">//v1:178</span></span><br><span class="line"></span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;赵丽颖=168, 杨颖=165&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//int v2 = map.remove("林志颖");//自动拆箱  NullPointerException</span></span><br><span class="line">        Integer v2 = map.remove(<span class="string">"林志颖"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v2:"</span>+v2);<span class="comment">//v2:null</span></span><br><span class="line"></span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;赵丽颖=168, 杨颖=165&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public V put(K key, V value):  把指定的键与指定的值添加到Map集合中。</span></span><br><span class="line"><span class="comment">            返回值:v</span></span><br><span class="line"><span class="comment">                存储键值对的时候,key不重复,返回值V是null</span></span><br><span class="line"><span class="comment">                存储键值对的时候,key重复,会使用新的value替换map中重复的value,返回被替换的value值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象,多态</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String v1 = map.put(<span class="string">"李晨"</span>, <span class="string">"范冰冰1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v1:"</span>+v1);<span class="comment">//v1:null</span></span><br><span class="line"></span><br><span class="line">        String v2 = map.put(<span class="string">"李晨"</span>, <span class="string">"范冰冰2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v2:"</span>+v2);<span class="comment">//v2:范冰冰1</span></span><br><span class="line"></span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;李晨=范冰冰2&#125;</span></span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">"冷锋"</span>,<span class="string">"龙小云"</span>);</span><br><span class="line">        map.put(<span class="string">"杨过"</span>,<span class="string">"小龙女"</span>);</span><br><span class="line">        map.put(<span class="string">"尹志平"</span>,<span class="string">"小龙女"</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;杨过=小龙女, 尹志平=小龙女, 李晨=范冰冰2, 冷锋=龙小云&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中；若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。</p>
</blockquote>
<h2 id="Map-遍历"><a href="#Map-遍历" class="headerlink" title="Map 遍历"></a>Map 遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Map集合的第一种遍历方式:通过键找值的方式</span></span><br><span class="line"><span class="comment">    Map集合中的方法:</span></span><br><span class="line"><span class="comment">         Set&lt;K&gt; keySet() 返回此映射中包含的键的 Set 视图。</span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中</span></span><br><span class="line"><span class="comment">        2.遍历set集合,获取Map集合中的每一个key</span></span><br><span class="line"><span class="comment">        3.通过Map集合中的方法get(key),通过key找到value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02KeySet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"赵丽颖"</span>,<span class="number">168</span>);</span><br><span class="line">        map.put(<span class="string">"杨颖"</span>,<span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"林志玲"</span>,<span class="number">178</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中</span></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.遍历set集合,获取Map集合中的每一个key</span></span><br><span class="line">        <span class="comment">//使用迭代器遍历Set集合</span></span><br><span class="line">        Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            String key = it.next();</span><br><span class="line">            <span class="comment">//3.通过Map集合中的方法get(key),通过key找到value</span></span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">"="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">        <span class="comment">//使用增强for遍历Set集合</span></span><br><span class="line">        <span class="keyword">for</span>(String key : set)&#123;</span><br><span class="line">            <span class="comment">//3.通过Map集合中的方法get(key),通过key找到value</span></span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">"="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">        <span class="comment">//使用增强for遍历Set集合</span></span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            <span class="comment">//3.通过Map集合中的方法get(key),通过key找到value</span></span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">"="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Entry键值对对象"><a href="#Entry键值对对象" class="headerlink" title="Entry键值对对象"></a>Entry键值对对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Map集合遍历的第二种方式:使用Entry对象遍历</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Map集合中的方法:</span></span><br><span class="line"><span class="comment">        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的 Set 视图。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中</span></span><br><span class="line"><span class="comment">        2.遍历Set集合,获取每一个Entry对象</span></span><br><span class="line"><span class="comment">        3.使用Entry对象中的方法getKey()和getValue()获取键与值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03EntrySet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"赵丽颖"</span>,<span class="number">168</span>);</span><br><span class="line">        map.put(<span class="string">"杨颖"</span>,<span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"林志玲"</span>,<span class="number">178</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.遍历Set集合,获取每一个Entry对象</span></span><br><span class="line">        <span class="comment">//使用迭代器遍历Set集合</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; entry = it.next();</span><br><span class="line">            <span class="comment">//3.使用Entry对象中的方法getKey()和getValue()获取键与值</span></span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(key+<span class="string">"="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:set)&#123;</span><br><span class="line">            <span class="comment">//3.使用Entry对象中的方法getKey()和getValue()获取键与值</span></span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(key+<span class="string">"="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap-存储自定义类型键值"><a href="#HashMap-存储自定义类型键值" class="headerlink" title="HashMap 存储自定义类型键值"></a>HashMap 存储自定义类型键值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    HashMap存储自定义类型键值</span></span><br><span class="line"><span class="comment">    Map集合保证key是唯一的:</span></span><br><span class="line"><span class="comment">        作为key的元素,必须重写hashCode方法和equals方法,以保证key唯一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01HashMapSavePerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show02();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        HashMap存储自定义类型键值</span></span><br><span class="line"><span class="comment">        key:Person类型</span></span><br><span class="line"><span class="comment">            Person类就必须重写hashCode方法和equals方法,以保证key唯一</span></span><br><span class="line"><span class="comment">        value:String类型</span></span><br><span class="line"><span class="comment">            可以重复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建HashMap集合</span></span><br><span class="line">        HashMap&lt;Person,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//往集合中添加元素</span></span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"女王"</span>,<span class="number">18</span>),<span class="string">"英国"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"秦始皇"</span>,<span class="number">18</span>),<span class="string">"秦国"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"普京"</span>,<span class="number">30</span>),<span class="string">"俄罗斯"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"女王"</span>,<span class="number">18</span>),<span class="string">"毛里求斯"</span>);</span><br><span class="line">        <span class="comment">//使用entrySet和增强for遍历Map集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Person, String&gt;&gt; set = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Person, String&gt; entry : set) &#123;</span><br><span class="line">            Person key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key+<span class="string">"--&gt;"</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        HashMap存储自定义类型键值</span></span><br><span class="line"><span class="comment">        key:String类型</span></span><br><span class="line"><span class="comment">            String类重写hashCode方法和equals方法,可以保证key唯一</span></span><br><span class="line"><span class="comment">        value:Person类型</span></span><br><span class="line"><span class="comment">            value可以重复(同名同年龄的人视为同一个)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建HashMap集合</span></span><br><span class="line">        HashMap&lt;String,Person&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//往集合中添加元素</span></span><br><span class="line">        map.put(<span class="string">"北京"</span>,<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">18</span>));</span><br><span class="line">        map.put(<span class="string">"上海"</span>,<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">19</span>));</span><br><span class="line">        map.put(<span class="string">"广州"</span>,<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));</span><br><span class="line">        map.put(<span class="string">"北京"</span>,<span class="keyword">new</span> Person(<span class="string">"赵六"</span>,<span class="number">18</span>));</span><br><span class="line">        <span class="comment">//使用keySet加增强for遍历Map集合</span></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">            Person value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">"--&gt;"</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    java.util.LinkedHashMap&lt;K,V&gt; entends HashMap&lt;K,V&gt;</span></span><br><span class="line"><span class="comment">    Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。</span></span><br><span class="line"><span class="comment">    底层原理:</span></span><br><span class="line"><span class="comment">        哈希表+链表(记录元素的顺序)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01LinkedHashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"a"</span>,<span class="string">"a"</span>);</span><br><span class="line">        map.put(<span class="string">"c"</span>,<span class="string">"c"</span>);</span><br><span class="line">        map.put(<span class="string">"b"</span>,<span class="string">"b"</span>);</span><br><span class="line">        map.put(<span class="string">"a"</span>,<span class="string">"d"</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">// key不允许重复,无序 &#123;a=d, b=b, c=c&#125;</span></span><br><span class="line"></span><br><span class="line">        LinkedHashMap&lt;String,String&gt; linked = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        linked.put(<span class="string">"a"</span>,<span class="string">"a"</span>);</span><br><span class="line">        linked.put(<span class="string">"c"</span>,<span class="string">"c"</span>);</span><br><span class="line">        linked.put(<span class="string">"b"</span>,<span class="string">"b"</span>);</span><br><span class="line">        linked.put(<span class="string">"a"</span>,<span class="string">"d"</span>);</span><br><span class="line">        System.out.println(linked);<span class="comment">// key不允许重复,有序 &#123;a=d, c=c, b=b&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    java.util.Hashtable&lt;K,V&gt;集合 implements Map&lt;K,V&gt;接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Hashtable:底层也是一个哈希表,是一个线程安全的集合,是单线程集合,速度慢</span></span><br><span class="line"><span class="comment">    HashMap:底层是一个哈希表,是一个线程不安全的集合,是多线程的集合,速度快</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    HashMap集合(之前学的所有的集合):可以存储null值,null键</span></span><br><span class="line"><span class="comment">    Hashtable集合,不能存储null值,null键</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Hashtable和Vector集合一样,在jdk1.2版本之后被更先进的集合(HashMap,ArrayList)取代了</span></span><br><span class="line"><span class="comment">    Hashtable的子类Properties依然活跃在历史舞台</span></span><br><span class="line"><span class="comment">    Properties集合是一个唯一和IO流相结合的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Hashtable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">null</span>,<span class="string">"a"</span>);</span><br><span class="line">        map.put(<span class="string">"b"</span>,<span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;null=null, b=null&#125;</span></span><br><span class="line"></span><br><span class="line">        Hashtable&lt;String,String&gt; table = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">        <span class="comment">//table.put(null,"a");//NullPointerException</span></span><br><span class="line">        <span class="comment">//table.put("b",null);//NullPointerException</span></span><br><span class="line">        table.put(<span class="keyword">null</span>,<span class="keyword">null</span>);<span class="comment">//NullPointerException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Map集合练习"><a href="#Map集合练习" class="headerlink" title="Map集合练习"></a>Map集合练习</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习:</span></span><br><span class="line"><span class="comment">        计算一个字符串中每个字符出现次数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    分析:</span></span><br><span class="line"><span class="comment">        1.使用Scanner获取用户输入的字符串</span></span><br><span class="line"><span class="comment">        2.创建Map集合,key是字符串中的字符,value是字符的个数</span></span><br><span class="line"><span class="comment">        3.遍历字符串,获取每一个字符</span></span><br><span class="line"><span class="comment">        4.使用获取到的字符,去Map集合判断key是否存在</span></span><br><span class="line"><span class="comment">            key存在:</span></span><br><span class="line"><span class="comment">                通过字符(key),获取value(字符个数)</span></span><br><span class="line"><span class="comment">                value++</span></span><br><span class="line"><span class="comment">                put(key,value)把新的value存储到Map集合中</span></span><br><span class="line"><span class="comment">            key不存在:</span></span><br><span class="line"><span class="comment">                put(key,1)</span></span><br><span class="line"><span class="comment">        5.遍历Map集合,输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03MapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.使用Scanner获取用户输入的字符串</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入一个字符串:"</span>);</span><br><span class="line">        String str = sc.next();</span><br><span class="line">        <span class="comment">//2.创建Map集合,key是字符串中的字符,value是字符的个数</span></span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//3.遍历字符串,获取每一个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c :str.toCharArray())&#123;</span><br><span class="line">            <span class="comment">//4.使用获取到的字符,去Map集合判断key是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">                <span class="comment">//key存在</span></span><br><span class="line">                Integer value = map.get(c);</span><br><span class="line">                value++;</span><br><span class="line">                map.put(c,value);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//key不存在</span></span><br><span class="line">                map.put(c,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.遍历Map集合,输出结果</span></span><br><span class="line">        <span class="keyword">for</span>(Character key :map.keySet())&#123;</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">"="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK9-新特性"><a href="#JDK9-新特性" class="headerlink" title="JDK9 新特性"></a>JDK9 新特性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    JDK9的新特性:</span></span><br><span class="line"><span class="comment">        List接口,Set接口,Map接口:里边增加了一个静态的方法of,可以给集合一次性添加多个元素</span></span><br><span class="line"><span class="comment">        static &lt;E&gt; List&lt;E&gt; of​(E... elements)</span></span><br><span class="line"><span class="comment">        使用前提:</span></span><br><span class="line"><span class="comment">            当集合中存储的元素的个数已经确定了,不在改变时使用</span></span><br><span class="line"><span class="comment">     注意:</span></span><br><span class="line"><span class="comment">        1.of方法只适用于List接口,Set接口,Map接口,不适用于接接口的实现类</span></span><br><span class="line"><span class="comment">        2.of方法的返回值是一个不能改变的集合,集合不能再使用add,put方法添加元素,会抛出异常</span></span><br><span class="line"><span class="comment">        3.Set接口和Map接口在调用of方法的时候,不能有重复的元素,否则会抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01JDK9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[a, b, a, c, d]</span></span><br><span class="line">        <span class="comment">//list.add("w");//UnsupportedOperationException:不支持操作异常</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set&lt;String&gt; set = Set.of("a", "b", "a", "c", "d");//IllegalArgumentException:非法参数异常,有重复的元素</span></span><br><span class="line">        Set&lt;String&gt; set = Set.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        <span class="comment">//set.add("w");//UnsupportedOperationException:不支持操作异常</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Map&lt;String, Integer&gt; map = Map.of("张三", 18, "李四", 19, "王五", 20,"张三",19);////IllegalArgumentException:非法参数异常,有重复的元素</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = Map.of(<span class="string">"张三"</span>, <span class="number">18</span>, <span class="string">"李四"</span>, <span class="number">19</span>, <span class="string">"王五"</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;王五=20, 李四=19, 张三=18&#125;</span></span><br><span class="line">        <span class="comment">//map.put("赵四",30);//UnsupportedOperationException:不支持操作异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Debug-调试"><a href="#Debug-调试" class="headerlink" title="Debug 调试"></a>Debug 调试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Debug调试程序:</span></span><br><span class="line"><span class="comment">        可以让代码逐行执行,查看代码执行的过程,调试程序中出现的bug</span></span><br><span class="line"><span class="comment">    使用方式:</span></span><br><span class="line"><span class="comment">        在行号的右边,鼠标左键单击,添加断点(每个方法的第一行,哪里有bug添加到哪里)</span></span><br><span class="line"><span class="comment">        右键,选择Debug执行程序</span></span><br><span class="line"><span class="comment">        程序就会停留在添加的第一个断点处</span></span><br><span class="line"><span class="comment">    执行程序:</span></span><br><span class="line"><span class="comment">        f8:逐行执行程序</span></span><br><span class="line"><span class="comment">        f7:进入到方法中</span></span><br><span class="line"><span class="comment">        shift+f8:跳出方法</span></span><br><span class="line"><span class="comment">        f9:跳到下一个断点,如果没有下一个断点,那么就结束程序</span></span><br><span class="line"><span class="comment">        ctrl+f2:退出debug模式,停止程序</span></span><br><span class="line"><span class="comment">        Console:切换到控制台</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Debug</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*int a = 10;</span></span><br><span class="line"><span class="comment">        int b = 20;</span></span><br><span class="line"><span class="comment">        int sum = a + b;</span></span><br><span class="line"><span class="comment">        System.out.println(sum);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*for (int i = 0; i &lt;3 ; i++) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(i);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        print();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="斗地主案例-双列"><a href="#斗地主案例-双列" class="headerlink" title="斗地主案例(双列)"></a>斗地主案例(双列)</h1><h2 id="案例介绍-1"><a href="#案例介绍-1" class="headerlink" title="案例介绍"></a>案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。具体规则如下：</p>
<ul>
<li>组装 54 张扑克牌将</li>
<li>54 张牌顺序打乱</li>
<li>三个玩家参与游戏，三人交替摸牌，每人 17 张牌，最后三张留作底牌。</li>
<li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li>
</ul>
<blockquote>
<p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p>
</blockquote>
<h2 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h2><ul>
<li><p>准备牌：<br>完成数字与纸牌的映射关系：使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p>
</li>
<li><p>洗牌：<br>通过数字完成洗牌发牌</p>
</li>
<li><p>发牌：<br>将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。存放的过程中要求数字大小与斗地主规则的大小对应。将代表不同纸牌的数字分配给不同的玩家与底牌。</p>
</li>
<li><p>看牌：<br>通过Map集合找到对应字符展示。通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/guoshizhan/blog-pictures/master/011.png" alt=""></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    斗地主综合案例:有序版本</span></span><br><span class="line"><span class="comment">    1.准备牌</span></span><br><span class="line"><span class="comment">    2.洗牌</span></span><br><span class="line"><span class="comment">    3.发牌</span></span><br><span class="line"><span class="comment">    4.排序</span></span><br><span class="line"><span class="comment">    5.看牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DouDiZhu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.准备牌</span></span><br><span class="line">        <span class="comment">//创建一个Map集合,存储牌的索引和组装好的牌</span></span><br><span class="line">        HashMap&lt;Integer,String&gt; poker = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建一个List集合,存储牌的索引</span></span><br><span class="line">        ArrayList&lt;Integer&gt; pokerIndex = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//定义两个集合,存储花色和牌的序号</span></span><br><span class="line">        List&lt;String&gt; colors = List.of(<span class="string">"♠"</span>, <span class="string">"♥"</span>, <span class="string">"♣"</span>, <span class="string">"♦"</span>);</span><br><span class="line">        List&lt;String&gt; numbers = List.of(<span class="string">"2"</span>, <span class="string">"A"</span>, <span class="string">"K"</span>, <span class="string">"Q"</span>, <span class="string">"J"</span>, <span class="string">"10"</span>, <span class="string">"9"</span>, <span class="string">"8"</span>, <span class="string">"7"</span>, <span class="string">"6"</span>, <span class="string">"5"</span>, <span class="string">"4"</span>, <span class="string">"3"</span>);</span><br><span class="line">        <span class="comment">//把大王和小王存储到集合中</span></span><br><span class="line">        <span class="comment">//定义一个牌的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        poker.put(index,<span class="string">"大王"</span>);</span><br><span class="line">        pokerIndex.add(index);</span><br><span class="line">        index++;</span><br><span class="line">        poker.put(index,<span class="string">"小王"</span>);</span><br><span class="line">        pokerIndex.add(index);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="comment">//循环嵌套遍历两个集合,组装52张牌,存储到集合中</span></span><br><span class="line">        <span class="keyword">for</span> (String number : numbers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">                poker.put(index,color+number);</span><br><span class="line">                pokerIndex.add(index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(poker);</span></span><br><span class="line">        <span class="comment">//System.out.println(pokerIndex);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            2.洗牌</span></span><br><span class="line"><span class="comment">            使用Collections中的方法shuffle(List)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Collections.shuffle(pokerIndex);</span><br><span class="line">        <span class="comment">//System.out.println(pokerIndex);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            3.发牌</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//定义4个集合,存储玩家牌的索引,和底牌的索引</span></span><br><span class="line">        ArrayList&lt;Integer&gt; player01 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; player02 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; player03 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; diPai = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历存储牌索引的List集合,获取每一个牌的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;pokerIndex.size() ; i++) &#123;</span><br><span class="line">            Integer in = pokerIndex.get(i);</span><br><span class="line">            <span class="comment">//先判断底牌</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">51</span>)&#123;</span><br><span class="line">                <span class="comment">//给底牌发牌</span></span><br><span class="line">                diPai.add(in);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//给玩家1发牌</span></span><br><span class="line">                player01.add(in);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//给玩家2发牌</span></span><br><span class="line">                player02.add(in);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//给玩家3发牌</span></span><br><span class="line">                player03.add(in);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            4.排序</span></span><br><span class="line"><span class="comment">            使用Collections中的方法sort(List)</span></span><br><span class="line"><span class="comment">            默认是升序排序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Collections.sort(player01);</span><br><span class="line">        Collections.sort(player02);</span><br><span class="line">        Collections.sort(player03);</span><br><span class="line">        Collections.sort(diPai);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            5.看牌</span></span><br><span class="line"><span class="comment">            调用看牌的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        lookPoker(<span class="string">"刘德华"</span>,poker,player01);</span><br><span class="line">        lookPoker(<span class="string">"周润发"</span>,poker,player02);</span><br><span class="line">        lookPoker(<span class="string">"周星驰"</span>,poker,player03);</span><br><span class="line">        lookPoker(<span class="string">"底牌"</span>,poker,diPai);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个看牌的方法,提高代码的复用性</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            String name:玩家名称</span></span><br><span class="line"><span class="comment">            HashMap&lt;Integer,String&gt; poker:存储牌的poker集合</span></span><br><span class="line"><span class="comment">            ArrayList&lt;Integer&gt; list:存储玩家和底牌的List集合</span></span><br><span class="line"><span class="comment">        查表法:</span></span><br><span class="line"><span class="comment">             遍历玩家或者底牌集合,获取牌的索引</span></span><br><span class="line"><span class="comment">             使用牌的索引,去Map集合中,找到对应的牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookPoker</span><span class="params">(String name,HashMap&lt;Integer,String&gt; poker,ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//输出玩家名称,不换行</span></span><br><span class="line">        System.out.print(name+<span class="string">":"</span>);</span><br><span class="line">        <span class="comment">//遍历玩家或者底牌集合,获取牌的索引</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : list) &#123;</span><br><span class="line">            <span class="comment">//使用牌的索引,去Map集合中,找到对应的牌</span></span><br><span class="line">            String value = poker.get(key);</span><br><span class="line">            System.out.print(value+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//打印完每一个玩家的牌,换行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h2><p><strong>异常</strong> ：就是不正常的意思，指的是程序在执行过程中，出现的非正常的情况，最终会导致 JVM 的非正常停止。在 Java 等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java 处理异常的方式是中断处理。</p>
<blockquote>
<p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行。</p>
</blockquote>
<h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是 <code>java.lang.Throwable</code> ，其下有两个子类：<code>java.lang.Error</code> 与 <code>java.lang.Exception</code> ，平常所说的异常指 <code>java.lang.Exception</code> 。如下图：</p>
<p><img src="../gallery/Java-Study/JavaSE-03/006.png" alt=""></p>
<h3 id="Throwable-常用方法"><a href="#Throwable-常用方法" class="headerlink" title="Throwable 常用方法"></a>Throwable 常用方法</h3><p>以下三个方法都是为了获取异常信息：</p>
<blockquote>
<p><code>public void printStackTrace()</code> : 打印异常的详细信息。包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用 printStackTrace。<br><code>public String getMessage()</code>:获取发生异常的原因。提示给用户的时候,就提示错误原因。<br><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p>
</blockquote>
<h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><blockquote>
<p><strong>编译时期异常</strong> : checked 异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)<br><strong>运行时期异常</strong> : runtime 异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</p>
</blockquote>
<p><img src="../gallery/Java-Study/JavaSE-03/007.png" alt=""></p>
<h2 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h2><p>Java异常处理的五个关键字：<code>try、catch、finally、throw、throws</code></p>
<h3 id="抛出异常-throw"><a href="#抛出异常-throw" class="headerlink" title="抛出异常 throw"></a>抛出异常 throw</h3><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。在 java 中，提供了一个 <strong>throw</strong> 关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p>
<ul>
<li><p>1、创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p>
</li>
<li><p>2、需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字 throw 就可以完成。throw 异常对象。<code>throw 用在方法内</code> ，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p>
</li>
</ul>
<p><strong>使用格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常类名(参数);</span><br></pre></td></tr></table></figure>

<p> 例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"要访问的arr数组不存在"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"该索引在数组中不存在，已超出范围"</span>);</span><br></pre></td></tr></table></figure>

<p>学习完抛出异常的格式后，我们通过下面程序演示下 throw 的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个数组 </span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">// 根据索引找对应的元素 </span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> element = getElement(arr, index);</span><br><span class="line">        System.out.println(element);</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 索引找到数组中对应的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123; </span><br><span class="line">           <span class="comment">// 判断索引是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">             <span class="comment">// 判断条件如果满足，当执行完 throw 抛出异常对象后，方法已经无法继续运算。这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"哥们，角标越界了~~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果产生了问题，我们就会 throw 将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p>
<p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用 throws 声明处理。</p>
</blockquote>
<h3 id="声明异常-throws"><a href="#声明异常-throws" class="headerlink" title="声明异常 throws"></a>声明异常 throws</h3><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过 throw 抛出了编译时异常，而没有捕获处理（下面讲解该方式），那么必须通过 throws 进行声明，让调用者去处理。关键字 <strong>throws</strong> 运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p>
<p><strong>声明异常格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) <span class="keyword">throws</span> 异常类名<span class="number">1</span>,异常类名<span class="number">2</span>…&#123;   &#125;</span><br></pre></td></tr></table></figure>

<p>声明异常的代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        read(<span class="string">"a.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        read(<span class="string">"a.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span><span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;    <span class="comment">// 如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 如果不是 a.txt ，认为该文件不存在，是一个异常 throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">"b.txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="捕获异常-try-catch"><a href="#捕获异常-try-catch" class="headerlink" title="捕获异常 try_catch"></a>捕获异常 try_catch</h3><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p>
<ul>
<li>1、该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li>
<li>2、如果要处理，那就在方法中使用 try-catch 的语句块来捕获异常。</li>
</ul>
<p><strong>try-catch</strong> 的方式就是捕获异常【Java 中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理】，语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  e)&#123;</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">// 记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong>try：</strong>在该代码块中，编写可能产生异常的代码。<br><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。<br><strong>注意 :</strong> try 和 catch 都不能单独使用,必须连用。</p>
</blockquote>
<p>演示如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;    <span class="comment">// 当产生异常时，必须有处理方式。要么捕获，要么声明。</span></span><br><span class="line">            read(<span class="string">"b.txt"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;    <span class="comment">// 括号中需要定义什么呢？</span></span><br><span class="line">            <span class="comment">// try 中抛出的是什么异常，在括号中就定义什么异常类型</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前的这个方法中有异常  有编译期异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h3><p><strong>finally</strong> ：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而 finally 就是解决这个问题的，在 finally 代码块中存放的代码都是一定会被执行的。</p>
<p>什么时候的代码必须最终执行？当我们在 try 语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p>
<p>finally 的语法 : try…catch….finally:自身需要处理异常,最终还得关闭资源。</p>
<p>finally 代码参考如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            read(<span class="string">"a.txt"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 抓取到的是编译期异常  抛出去的是运行期 </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"不管程序怎样，这里都将会被执行。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>注意事项：</code><br>1、 finally 不能单独使用。<br>2、 当只有在 try 或者 catch 中调用退出 JVM 的相关方法,此时 finally 才不会执行,否则 finally 永远会执行。</p>
</blockquote>
<h2 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h2><ul>
<li><p>多个异常使用捕获又该如何处理呢？</p>
<ol>
<li>多个异常分别处理。</li>
<li>多个异常一次捕获，多次处理。</li>
<li>多个异常一次捕获一次处理。</li>
</ol>
</li>
</ul>
<p>一般我们是使用一次捕获多次处理方式，格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     <span class="comment">// 编写可能会出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型A  e)&#123;    <span class="comment">// 当try中出现A类型异常,就用该catch来捕获.</span></span><br><span class="line">     <span class="comment">// 处理异常的代码</span></span><br><span class="line">     <span class="comment">// 记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型B  e)&#123;    <span class="comment">// 当try中出现B类型异常,就用该catch来捕获.</span></span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">// 记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>注意事项：</code></p>
<p>1、这种异常处理方式，要求多个 catch 中的异常不能相同，并且若 catch 中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的 catch 处理，父类异常在下面的 catch 处理。<br>2、运行时异常被抛出可以不处理。即不捕获也不声明抛出。<br>3、如果 finally 有 return 语句,永远返回 finally 中的结果,避免该情况。<br>4、如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。<br>5、父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。</p>
</blockquote>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><h3 id="自定义异常概述"><a href="#自定义异常概述" class="headerlink" title="自定义异常概述"></a>自定义异常概述</h3><p><strong>为什么需要自定义异常类:</strong></p>
<p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。</p>
<p>在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p>
<p><strong>什么是自定义异常类:</strong></p>
<p>在开发中根据自己业务的异常情况来定义异常类.</p>
<p>自定义一个业务逻辑异常: <strong>RegisterException</strong>。一个注册异常类。</p>
<p><strong>异常类如何定义:</strong></p>
<ol>
<li>自定义一个编译期异常: 自定义类并继承于 <code>java.lang.Exception</code> 。</li>
<li>自定义一个运行时期的异常类:自定义类 并继承于 <code>java.lang.RuntimeException</code> 。</li>
</ol>
<h3 id="自定义异常的练习"><a href="#自定义异常的练习" class="headerlink" title="自定义异常的练习"></a>自定义异常的练习</h3><p>要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p>
<p>首先定义一个登陆异常类 RegisterException：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务逻辑异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @param message 表示异常提示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟数据库中已存在账号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] names = &#123;<span class="string">"bill"</span>,<span class="string">"hill"</span>,<span class="string">"jill"</span>&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">              <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">            checkUsername(<span class="string">"nill"</span>);</span><br><span class="line">            System.out.println(<span class="string">"注册成功"</span>);<span class="comment">//如果没有异常就是注册成功</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(RegisterException e)&#123;</span><br><span class="line">            <span class="comment">// 处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前注册账号是否存在</span></span><br><span class="line">    <span class="comment">// 因为是编译期异常，又想调用者去处理 所以声明该异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(String uname)</span> <span class="keyword">throws</span> LoginException</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.equals(uname))&#123;    <span class="comment">// 如果名字在这里面 就抛出登陆异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RegisterException(<span class="string">"亲"</span> + name + <span class="string">"已经被注册了！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="了解概念"><a href="#了解概念" class="headerlink" title="了解概念"></a>了解概念</h2><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><blockquote>
<p><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。例如：一个手机同时玩王者和吃鸡，只能交替进行。<br><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。例如：边打游戏边听歌，同时进行。</p>
</blockquote>
<p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p>
<p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p>
<blockquote>
<p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p>
</blockquote>
<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><ul>
<li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>
</li>
<li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p>
<p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 </p>
</li>
</ul>
<p><strong>线程调度:</strong></p>
<ul>
<li><p>分时调度</p>
<p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
</li>
<li><p>抢占式调度</p>
<p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p>
<ul>
<li><p>设置线程的优先级</p>
</li>
<li><p>抢占式调度详解</p>
<p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p>
<p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p>
</li>
</ul>
</li>
</ul>
<p>多线程原理</p>
<p>常用方法</p>
<p>设置线程的名称</p>
<p>多线程休眠方法有点意思，每隔一秒执行，打印一分钟</p>
<p>Runnable接口创建线程对象</p>
<p>Runnable接口创建线程对象和thread创建对象的区别</p>
<p>线程安全</p>
<p>买票重复，出现-1</p>
<p>解决线程安全的三种方法</p>
<p>线程池<br>线程池介绍<br>涉及到一个概念，面向接口编程，就是返回对象是接口类型，不用管接口的实现类</p>
<p>concurrent  executors</p>
<h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><h2 id="函数式编程思想概述"><a href="#函数式编程思想概述" class="headerlink" title="函数式编程思想概述"></a>函数式编程思想概述</h2><p><img src="../gallery/Java-Study/JavaSE-03/008.jpg" alt=""></p>
<p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p>
<p>面向对象的思想:<br>做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p>
<p>函数式编程思想:<br>只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p>
<h2 id="冗余的-Runnable-代码"><a href="#冗余的-Runnable-代码" class="headerlink" title="冗余的 Runnable 代码"></a>冗余的 Runnable 代码</h2><h3 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 覆盖重写抽象方法</span></span><br><span class="line">                System.out.println(<span class="string">"多线程任务执行！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start(); <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p>
<ul>
<li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li>
<li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li>
<li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li>
</ul>
<h2 id="编程思想转换"><a href="#编程思想转换" class="headerlink" title="编程思想转换"></a>编程思想转换</h2><h3 id="做什么，而不是怎么做"><a href="#做什么，而不是怎么做" class="headerlink" title="做什么，而不是怎么做"></a>做什么，而不是怎么做</h3><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p>
<p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p>
<h3 id="生活举例"><a href="#生活举例" class="headerlink" title="生活举例"></a>生活举例</h3><p>当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。</p>
<p>而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p>
<h2 id="体验Lambda的更优写法"><a href="#体验Lambda的更优写法" class="headerlink" title="体验Lambda的更优写法"></a>体验Lambda的更优写法</h2><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02LambdaRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"多线程任务执行！"</span>)).start(); <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p>
<p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p>
<h2 id="回顾匿名内部类"><a href="#回顾匿名内部类" class="headerlink" title="回顾匿名内部类"></a>回顾匿名内部类</h2><p>Lambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">"多线程任务执行！"</span>)</span><br></pre></td></tr></table></figure>

<p>为了理解Lambda的语义，我们需要从传统的代码起步。</p>
<h3 id="使用实现类"><a href="#使用实现类" class="headerlink" title="使用实现类"></a>使用实现类</h3><p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start</code>方法。而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p>
<ul>
<li><code>public Thread(Runnable target)</code></li>
</ul>
<p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"多线程任务执行！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建该实现类的对象作为<code>Thread</code>类的构造参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03ThreadInitParam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable task = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h3><p>这个<code>RunnableImpl</code>类只是为了实现<code>Runnable</code>接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04ThreadNameless</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"多线程任务执行！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h3><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>仔细分析该代码中的语义，<code>Runnable</code>接口只有一个<code>run</code>方法的定义：</p>
<ul>
<li><code>public abstract void run();</code></li>
</ul>
<p>即制定了一种做事情的方案（其实就是一个函数）：</p>
<ul>
<li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li>
<li><strong>无返回值</strong>：该方案不产生任何结果。</li>
<li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li>
</ul>
<p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">"多线程任务执行！"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li>
<li>中间的一个箭头代表将前面的参数传递给后面的代码；</li>
<li>后面的输出语句即业务逻辑代码。</li>
</ul>
<h2 id="Lambda标准格式"><a href="#Lambda标准格式" class="headerlink" title="Lambda标准格式"></a>Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p>
<ul>
<li>一些参数</li>
<li>一个箭头</li>
<li>一段代码</li>
</ul>
<p>Lambda表达式的<strong>标准格式</strong>为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure>

<p>格式说明：</p>
<ul>
<li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li>
<li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li>
<li>大括号内的语法与传统方法体要求基本一致。</li>
</ul>
<h2 id="练习：使用Lambda标准格式（无参无返回）"><a href="#练习：使用Lambda标准格式（无参无返回）" class="headerlink" title="练习：使用Lambda标准格式（无参无返回）"></a>练习：使用Lambda标准格式（无参无返回）</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个厨子<code>Cook</code>接口，内含唯一的抽象方法<code>makeFood</code>，且无参数、无返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05InvokeCook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCook方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCook</span><span class="params">(Cook cook)</span> </span>&#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    invokeCook(() -&gt; &#123;</span><br><span class="line">          System.out.println(<span class="string">"吃饭啦！"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：小括号代表<code>Cook</code>接口<code>makeFood</code>抽象方法的参数为空，大括号代表<code>makeFood</code>的方法体。</p>
</blockquote>
<h2 id="Lambda的参数和返回值"><a href="#Lambda的参数和返回值" class="headerlink" title="Lambda的参数和返回值"></a>Lambda的参数和返回值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需求:</span><br><span class="line">    使用数组存储多个Person对象</span><br><span class="line">    对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序</span><br></pre></td></tr></table></figure>

<p>下面举例演示<code>java.util.Comparator&lt;T&gt;</code>接口的使用场景代码，其中的抽象方法定义为：</p>
<ul>
<li><code>public abstract int compare(T o1, T o2);</code></li>
</ul>
<p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略构造器、toString方法与Getter Setter </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传统写法-1"><a href="#传统写法-1" class="headerlink" title="传统写法"></a>传统写法</h3><p>如果使用传统的代码对<code>Person[]</code>数组进行排序，写法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06Comparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 本来年龄乱序的对象数组</span></span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"古力娜扎"</span>, <span class="number">19</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"迪丽热巴"</span>, <span class="number">18</span>),</span><br><span class="line">               <span class="keyword">new</span> Person(<span class="string">"马尔扎哈"</span>, <span class="number">20</span>) &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 匿名内部类</span></span><br><span class="line">        Comparator&lt;Person&gt; comp = <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(array, comp); <span class="comment">// 第二个参数为排序规则，即Comparator接口实例</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code>Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p>
<h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>下面我们来搞清楚上述代码真正要做什么事情。</p>
<ul>
<li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li>
<li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li>
<li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>实际上，<strong>只有参数和方法体才是关键</strong>。</li>
</ul>
<h3 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07ComparatorLambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">              <span class="keyword">new</span> Person(<span class="string">"古力娜扎"</span>, <span class="number">19</span>),</span><br><span class="line">              <span class="keyword">new</span> Person(<span class="string">"迪丽热巴"</span>, <span class="number">18</span>),</span><br><span class="line">              <span class="keyword">new</span> Person(<span class="string">"马尔扎哈"</span>, <span class="number">20</span>) &#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(array, (Person a, Person b) -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> a.getAge() - b.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习：使用Lambda标准格式（有参有返回）"><a href="#练习：使用Lambda标准格式（有参有返回）" class="headerlink" title="练习：使用Lambda标准格式（有参有返回）"></a>练习：使用Lambda标准格式（有参有返回）</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个计算器<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以将两个int数字相加得到和值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCalc</code>方法，完成120和130的相加计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08InvokeCalc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCalc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Calculator calculator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = calculator.calc(a, b);</span><br><span class="line">        System.out.println(<span class="string">"结果是："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：小括号代表 <code>Calculator</code> 接口 <code>calc</code> 抽象方法的参数，大括号代表<code>calc</code>的方法体。</p>
</blockquote>
<h2 id="Lambda-省略格式"><a href="#Lambda-省略格式" class="headerlink" title="Lambda 省略格式"></a>Lambda 省略格式</h2><h3 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h3><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (a, b) -&gt; a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p>
<ol>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li>
<li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li>
</ol>
<blockquote>
<p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p>
</blockquote>
<h2 id="练习：使用-Lambda-省略格式"><a href="#练习：使用-Lambda-省略格式" class="headerlink" title="练习：使用 Lambda 省略格式"></a>练习：使用 Lambda 省略格式</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>仍然使用前文含有唯一 <code>makeFood</code> 抽象方法的厨子 <code>Cook</code> 接口，在下面的代码中，请使用 Lambda 的<strong>省略格式</strong>调用 <code>invokeCook</code> 方法，打印输出“吃饭啦！”字样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09InvokeCook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【省略格式】调用invokeCook方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCook</span><span class="params">(Cook cook)</span> </span>&#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    invokeCook(() -&gt; System.out.println(<span class="string">"吃饭啦！"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lambda-的使用前提"><a href="#Lambda-的使用前提" class="headerlink" title="Lambda 的使用前提"></a>Lambda 的使用前提</h2><p>Lambda 的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>使用 Lambda 必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是 JDK 内置的 <code>Runnable</code> 、<code>Comparator</code> 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用 Lambda。</li>
<li>使用 Lambda 必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>
<blockquote>
<p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p>
</blockquote>
<h1 id="Java-中的-IO-流"><a href="#Java-中的-IO-流" class="headerlink" title="Java 中的 IO 流"></a>Java 中的 IO 流</h1><div class="blue">
    <div  class="block-title ">
        <i class="fa fa-bullseye" aria-hidden="true"></i>
        <span>IO 流知识</span>
    </div>
    <div class="block">
        由于本篇过长，IO 流独立成篇：<a href="https://guoshizhan.club/Java-IO.html">Java 中的 IO 流</a>
    </div>
</div>
        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item  guo-tags">
                    <i class="fas fa-tags has-text-grey"></i>&nbsp;&nbsp;
                    <a class="has-link-grey -link" href="/tags/Java/" rel="tag">Java</a>&nbsp;<i class=" has-text-grey">/</i>&nbsp;<a class="has-link-grey -link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a>&nbsp;<i class=" has-text-grey">/</i>&nbsp;<a class="has-link-grey -link" href="/tags/Java%E9%9B%86%E5%90%88/" rel="tag">Java集合</a>
                </div>
            </div>
        </div>
        
        
        
        <!-- 文章版权信息代码开始 -->

        
            <ul class="post-copyright">
            <li><b>本文标题：</b><b>Java 基础（下篇）</b></li>
            <li><b>本文作者：</b><b>Java Developer</b></li>
            <li><b>本文链接：</b><b><a href="https://guoshizhan.github.io/JavaSE-03.html">https://guoshizhan.github.io/JavaSE-03.html</a></b></li>
            <li><b>版权声明：</b><b>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</b>
            </li>
            </ul>
            <br/>
            <span class="is-size-6 has-text-grey has-mr-7">📚&nbsp;本站推荐文章</span>
<br>

    &nbsp;<!--1--> 👉 <a href="/blog-setup.html" class="is-size-6" target="_blank">从 0 开始搭建 Hexo 博客</a><br>

    &nbsp;<!--2--> 👉 <a href="/computerNetwork.html" class="is-size-6" target="_blank">计算机网络入门教程</a><br>

    &nbsp;<!--3--> 👉 <a href="/Structure.html" class="is-size-6" target="_blank">数据结构入门</a><br>

    &nbsp;<!--4--> 👉 <a href="/Algorithm.html" class="is-size-6" target="_blank">算法入门</a><br>

    &nbsp;<!--5--> 👉 <a href="/IDEA.html" class="is-size-6" target="_blank">IDEA 入门教程</a><br>

            <br>
        

        <!-- 文章版权信息代码结束-->
        

        
        <div class="social-share"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">
<script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3>
        <div class="buttons is-centered">
            
                
<a class="button is-info donate">
    <span class="icon is-small">
        <i class="fab fa-alipay"></i>
    </span>
    <span>支付宝</span>
    <div class="qrcode"><img src="/images/wechat.png" alt="支付宝"></div>
</a>

                
                
<a class="button is-success donate">
    <span class="icon is-small">
        <i class="fab fa-weixin"></i>
    </span>
    <span>微信</span>
    <div class="qrcode"><img src="/images/wechat.png" alt="微信"></div>
</a>

                
        </div>
    </div>
</div>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/oracle-logon.html">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">Oracle 出现 not logged on</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/JavaSE-02.html">
                <span class="level-item">Java 基础（中篇）</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="title is-5 has-text-weight-normal">可在评论区留言哦</h3>
        
<div id="comment-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.min.js"></script>
<script>
    var gitalk = new Gitalk({
        clientID: 'cff2590c3ebe89a56cf0',
        clientSecret: 'b6eea23c7fd06b8a540fea56bfa7546a3dfcf214',
        id: '831aa2016d608df7f73c5876207e929d',
        repo: 'gitalk-comments',
        owner: 'guoshizhan',
        admin: "guoshizhan",
        createIssueManually: false,
        distractionFreeMode: true
    })
    gitalk.render('comment-container')
</script>

    </div>
</div>
</div>
                




<div class="column is-4-tablet is-3-desktop is-3-widescreen  has-order-1 column-left is-sticky">
    
        <!--         这里的第一行和最后一行的功能是动态隐藏 profile ，菜单页显示，文章页不显示。-->

<div class="card widget">
    <div class="card-content guo-profile">
        <nav class="level">
            <div class="level-item has-text-centered guo-nav" style="flex-shrink: 1">
                <div class="guo-header">
                    <div class="guo-img">
                        
                        <figure class="image is-128x128 has-mb-6">
                            <img class="is-rounded  avatar-image" src="/images/avatar.gif" alt="何年の再遇见">
                        </figure>
                    </div>
                    
                    <div class="guo-text">
                        
                            <p class="is-size-4 is-block">
                                何年の再遇见
                            </p>
                            
                            
                            <p class="is-size-6 is-block">
                                愿你走出半生，归来仍是少年
                            </p>
                            
                            
                            <p class="is-size-6 is-flex is-flex-center">
                                <i class="fas fa-map-marker-alt has-mr-7"></i>
                                <span>井冈山大学</span>
                            </p>
                        
                    </div>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile guo-nav">
            <div class="level-item has-text-centered is-marginless wz">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            29
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless fl">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            8
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless bq">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            38
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        <!--
        
            <div >
                <a class="level-item button guo-github" href="https://github.com/guoshizhan" target="_blank" rel="noopener">我的 GitHub 地址</a>
            </div>
        
        -->
        
        
        <div style="max-height:100px;">
            <p id="hitokoto">一言句子获取中...</p>
            <script src="https://v1.hitokoto.cn/?encode=js&select=%23hitokoto" defer></script>
        </div>
    </div>
</div>
<!--         这里的最后一行和第一行的功能是动态隐藏 profile ，菜单页显示，文章页不显示。-->
    
        

    <div class="card widget toc-scroll" id="toc">
        <div class="card-content">
            <div class="menu">
                <h3 class="menu-label">
                    目录
                </h3>
                <ul class="menu-list"><li>
        <a class="is-flex" href="#Collection-集合">
        <span class="has-mr-6">1</span>
        <span>Collection 集合</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#集合概述">
        <span class="has-mr-6">1.1</span>
        <span>集合概述</span>
        </a></li><li>
        <a class="is-flex" href="#集合框架">
        <span class="has-mr-6">1.2</span>
        <span>集合框架</span>
        </a></li><li>
        <a class="is-flex" href="#Collection-常用功能">
        <span class="has-mr-6">1.3</span>
        <span>Collection 常用功能</span>
        </a></li><li>
        <a class="is-flex" href="#迭代器知识">
        <span class="has-mr-6">1.4</span>
        <span>迭代器知识</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#迭代器介绍">
        <span class="has-mr-6">1.4.1</span>
        <span>迭代器介绍</span>
        </a></li><li>
        <a class="is-flex" href="#迭代器使用">
        <span class="has-mr-6">1.4.2</span>
        <span>迭代器使用</span>
        </a></li><li>
        <a class="is-flex" href="#迭代器原理">
        <span class="has-mr-6">1.4.3</span>
        <span>迭代器原理</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#增强-for-循环">
        <span class="has-mr-6">1.5</span>
        <span>增强 for 循环</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#泛型">
        <span class="has-mr-6">2</span>
        <span>泛型</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#泛型的概述">
        <span class="has-mr-6">2.1</span>
        <span>泛型的概述</span>
        </a></li><li>
        <a class="is-flex" href="#泛型的好处">
        <span class="has-mr-6">2.2</span>
        <span>泛型的好处</span>
        </a></li><li>
        <a class="is-flex" href="#泛型的定义和使用">
        <span class="has-mr-6">2.3</span>
        <span>泛型的定义和使用</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#有泛型的类">
        <span class="has-mr-6">2.3.1</span>
        <span>有泛型的类</span>
        </a></li><li>
        <a class="is-flex" href="#有泛型的方法">
        <span class="has-mr-6">2.3.2</span>
        <span>有泛型的方法</span>
        </a></li><li>
        <a class="is-flex" href="#有泛型的接口">
        <span class="has-mr-6">2.3.3</span>
        <span>有泛型的接口</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#泛型通配符">
        <span class="has-mr-6">2.4</span>
        <span>泛型通配符</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#通配符基本使用">
        <span class="has-mr-6">2.4.1</span>
        <span>通配符基本使用</span>
        </a></li><li>
        <a class="is-flex" href="#通配符高级之受限泛型">
        <span class="has-mr-6">2.4.2</span>
        <span>通配符高级之受限泛型</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#斗地主案例-单列">
        <span class="has-mr-6">2.5</span>
        <span>斗地主案例(单列)</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#案例介绍">
        <span class="has-mr-6">2.5.1</span>
        <span>案例介绍</span>
        </a></li><li>
        <a class="is-flex" href="#案例分析">
        <span class="has-mr-6">2.5.2</span>
        <span>案例分析</span>
        </a></li><li>
        <a class="is-flex" href="#代码实现">
        <span class="has-mr-6">2.5.3</span>
        <span>代码实现</span>
        </a></li></ul></li></ul></li><li>
        <a class="is-flex" href="#Java-数据结构">
        <span class="has-mr-6">3</span>
        <span>Java 数据结构</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#栈">
        <span class="has-mr-6">3.1</span>
        <span>栈</span>
        </a></li><li>
        <a class="is-flex" href="#队列">
        <span class="has-mr-6">3.2</span>
        <span>队列</span>
        </a></li><li>
        <a class="is-flex" href="#数组">
        <span class="has-mr-6">3.3</span>
        <span>数组</span>
        </a></li><li>
        <a class="is-flex" href="#链表">
        <span class="has-mr-6">3.4</span>
        <span>链表</span>
        </a></li><li>
        <a class="is-flex" href="#红黑树">
        <span class="has-mr-6">3.5</span>
        <span>红黑树</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#List-集合">
        <span class="has-mr-6">4</span>
        <span>List 集合</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#List接口介绍">
        <span class="has-mr-6">4.1</span>
        <span>List接口介绍</span>
        </a></li><li>
        <a class="is-flex" href="#List-中常用方法">
        <span class="has-mr-6">4.2</span>
        <span>List 中常用方法</span>
        </a></li><li>
        <a class="is-flex" href="#ArrayList-集合">
        <span class="has-mr-6">4.3</span>
        <span>ArrayList 集合</span>
        </a></li><li>
        <a class="is-flex" href="#LinkedList-集合">
        <span class="has-mr-6">4.4</span>
        <span>LinkedList 集合</span>
        </a></li><li>
        <a class="is-flex" href="#Vector-集合">
        <span class="has-mr-6">4.5</span>
        <span>Vector 集合</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#Map-集合">
        <span class="has-mr-6">5</span>
        <span>Map 集合</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#Map-概述">
        <span class="has-mr-6">5.1</span>
        <span>Map 概述</span>
        </a></li><li>
        <a class="is-flex" href="#Map-常用子类">
        <span class="has-mr-6">5.2</span>
        <span>Map 常用子类</span>
        </a></li><li>
        <a class="is-flex" href="#Map-的常用方法">
        <span class="has-mr-6">5.3</span>
        <span>Map 的常用方法</span>
        </a></li><li>
        <a class="is-flex" href="#Map-遍历">
        <span class="has-mr-6">5.4</span>
        <span>Map 遍历</span>
        </a></li><li>
        <a class="is-flex" href="#Entry键值对对象">
        <span class="has-mr-6">5.5</span>
        <span>Entry键值对对象</span>
        </a></li><li>
        <a class="is-flex" href="#HashMap-存储自定义类型键值">
        <span class="has-mr-6">5.6</span>
        <span>HashMap 存储自定义类型键值</span>
        </a></li><li>
        <a class="is-flex" href="#LinkedHashMap">
        <span class="has-mr-6">5.7</span>
        <span>LinkedHashMap</span>
        </a></li><li>
        <a class="is-flex" href="#Map集合练习">
        <span class="has-mr-6">5.8</span>
        <span>Map集合练习</span>
        </a></li><li>
        <a class="is-flex" href="#JDK9-新特性">
        <span class="has-mr-6">5.9</span>
        <span>JDK9 新特性</span>
        </a></li><li>
        <a class="is-flex" href="#Debug-调试">
        <span class="has-mr-6">5.10</span>
        <span>Debug 调试</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#斗地主案例-双列">
        <span class="has-mr-6">6</span>
        <span>斗地主案例(双列)</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#案例介绍-1">
        <span class="has-mr-6">6.1</span>
        <span>案例介绍</span>
        </a></li><li>
        <a class="is-flex" href="#案例分析-1">
        <span class="has-mr-6">6.2</span>
        <span>案例分析</span>
        </a></li><li>
        <a class="is-flex" href="#代码实现-1">
        <span class="has-mr-6">6.3</span>
        <span>代码实现</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#异常处理">
        <span class="has-mr-6">7</span>
        <span>异常处理</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#异常概念">
        <span class="has-mr-6">7.1</span>
        <span>异常概念</span>
        </a></li><li>
        <a class="is-flex" href="#异常体系">
        <span class="has-mr-6">7.2</span>
        <span>异常体系</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#Throwable-常用方法">
        <span class="has-mr-6">7.2.1</span>
        <span>Throwable 常用方法</span>
        </a></li><li>
        <a class="is-flex" href="#异常分类">
        <span class="has-mr-6">7.2.2</span>
        <span>异常分类</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#异常处理-1">
        <span class="has-mr-6">7.3</span>
        <span>异常处理</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#抛出异常-throw">
        <span class="has-mr-6">7.3.1</span>
        <span>抛出异常 throw</span>
        </a></li><li>
        <a class="is-flex" href="#声明异常-throws">
        <span class="has-mr-6">7.3.2</span>
        <span>声明异常 throws</span>
        </a></li><li>
        <a class="is-flex" href="#捕获异常-try-catch">
        <span class="has-mr-6">7.3.3</span>
        <span>捕获异常 try_catch</span>
        </a></li><li>
        <a class="is-flex" href="#finally-代码块">
        <span class="has-mr-6">7.3.4</span>
        <span>finally 代码块</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#异常注意事项">
        <span class="has-mr-6">7.4</span>
        <span>异常注意事项</span>
        </a></li><li>
        <a class="is-flex" href="#自定义异常">
        <span class="has-mr-6">7.5</span>
        <span>自定义异常</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#自定义异常概述">
        <span class="has-mr-6">7.5.1</span>
        <span>自定义异常概述</span>
        </a></li><li>
        <a class="is-flex" href="#自定义异常的练习">
        <span class="has-mr-6">7.5.2</span>
        <span>自定义异常的练习</span>
        </a></li></ul></li></ul></li><li>
        <a class="is-flex" href="#多线程">
        <span class="has-mr-6">8</span>
        <span>多线程</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#了解概念">
        <span class="has-mr-6">8.1</span>
        <span>了解概念</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#并发和并行">
        <span class="has-mr-6">8.1.1</span>
        <span>并发和并行</span>
        </a></li><li>
        <a class="is-flex" href="#线程与进程">
        <span class="has-mr-6">8.1.2</span>
        <span>线程与进程</span>
        </a></li></ul></li></ul></li><li>
        <a class="is-flex" href="#Lambda-表达式">
        <span class="has-mr-6">9</span>
        <span>Lambda 表达式</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#函数式编程思想概述">
        <span class="has-mr-6">9.1</span>
        <span>函数式编程思想概述</span>
        </a></li><li>
        <a class="is-flex" href="#冗余的-Runnable-代码">
        <span class="has-mr-6">9.2</span>
        <span>冗余的 Runnable 代码</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#传统写法">
        <span class="has-mr-6">9.2.1</span>
        <span>传统写法</span>
        </a></li><li>
        <a class="is-flex" href="#代码分析">
        <span class="has-mr-6">9.2.2</span>
        <span>代码分析</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#编程思想转换">
        <span class="has-mr-6">9.3</span>
        <span>编程思想转换</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#做什么，而不是怎么做">
        <span class="has-mr-6">9.3.1</span>
        <span>做什么，而不是怎么做</span>
        </a></li><li>
        <a class="is-flex" href="#生活举例">
        <span class="has-mr-6">9.3.2</span>
        <span>生活举例</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#体验Lambda的更优写法">
        <span class="has-mr-6">9.4</span>
        <span>体验Lambda的更优写法</span>
        </a></li><li>
        <a class="is-flex" href="#回顾匿名内部类">
        <span class="has-mr-6">9.5</span>
        <span>回顾匿名内部类</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#使用实现类">
        <span class="has-mr-6">9.5.1</span>
        <span>使用实现类</span>
        </a></li><li>
        <a class="is-flex" href="#使用匿名内部类">
        <span class="has-mr-6">9.5.2</span>
        <span>使用匿名内部类</span>
        </a></li><li>
        <a class="is-flex" href="#匿名内部类的好处与弊端">
        <span class="has-mr-6">9.5.3</span>
        <span>匿名内部类的好处与弊端</span>
        </a></li><li>
        <a class="is-flex" href="#语义分析">
        <span class="has-mr-6">9.5.4</span>
        <span>语义分析</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#Lambda标准格式">
        <span class="has-mr-6">9.6</span>
        <span>Lambda标准格式</span>
        </a></li><li>
        <a class="is-flex" href="#练习：使用Lambda标准格式（无参无返回）">
        <span class="has-mr-6">9.7</span>
        <span>练习：使用Lambda标准格式（无参无返回）</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#题目">
        <span class="has-mr-6">9.7.1</span>
        <span>题目</span>
        </a></li><li>
        <a class="is-flex" href="#解答">
        <span class="has-mr-6">9.7.2</span>
        <span>解答</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#Lambda的参数和返回值">
        <span class="has-mr-6">9.8</span>
        <span>Lambda的参数和返回值</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#传统写法-1">
        <span class="has-mr-6">9.8.1</span>
        <span>传统写法</span>
        </a></li><li>
        <a class="is-flex" href="#代码分析-1">
        <span class="has-mr-6">9.8.2</span>
        <span>代码分析</span>
        </a></li><li>
        <a class="is-flex" href="#Lambda写法">
        <span class="has-mr-6">9.8.3</span>
        <span>Lambda写法</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#练习：使用Lambda标准格式（有参有返回）">
        <span class="has-mr-6">9.9</span>
        <span>练习：使用Lambda标准格式（有参有返回）</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#题目-1">
        <span class="has-mr-6">9.9.1</span>
        <span>题目</span>
        </a></li><li>
        <a class="is-flex" href="#解答-1">
        <span class="has-mr-6">9.9.2</span>
        <span>解答</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#Lambda-省略格式">
        <span class="has-mr-6">9.10</span>
        <span>Lambda 省略格式</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#可推导即可省略">
        <span class="has-mr-6">9.10.1</span>
        <span>可推导即可省略</span>
        </a></li><li>
        <a class="is-flex" href="#省略规则">
        <span class="has-mr-6">9.10.2</span>
        <span>省略规则</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#练习：使用-Lambda-省略格式">
        <span class="has-mr-6">9.11</span>
        <span>练习：使用 Lambda 省略格式</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#题目-2">
        <span class="has-mr-6">9.11.1</span>
        <span>题目</span>
        </a></li><li>
        <a class="is-flex" href="#解答-2">
        <span class="has-mr-6">9.11.2</span>
        <span>解答</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#Lambda-的使用前提">
        <span class="has-mr-6">9.12</span>
        <span>Lambda 的使用前提</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#Java-中的-IO-流">
        <span class="has-mr-6">10</span>
        <span>Java 中的 IO 流</span>
        </a></li></ul>
            </div>
        </div>
    </div>

    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                分类
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/C-python-Linux/">
            <span class="level-start">
                <span class="level-item">C-python-Linux</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Java%E5%AD%A6%E4%B9%A0/">
            <span class="level-start">
                <span class="level-item">Java学习</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">12</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/">
            <span class="level-start">
                <span class="level-item">前端知识</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/%E5%A4%A7%E5%AD%A6-%E7%94%9F%E6%B4%BB-%E5%85%B6%E4%BB%96/">
            <span class="level-start">
                <span class="level-item">大学-生活-其他</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/%E6%95%99%E7%A8%8B%E5%B7%A5%E5%85%B7/">
            <span class="level-start">
                <span class="level-item">教程工具</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">5</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">
            <span class="level-start">
                <span class="level-item">数据库</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">
            <span class="level-start">
                <span class="level-item">数据结构和算法</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
            <span class="level-start">
                <span class="level-item">计算机网络</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
    
        <div class="column-right-shadow  is-sticky">
        
            <div class="card widget">
	<div class="card-content">
		<h3 class="menu-label">我的歌单</h3>
		<div class="aplayer" data-id="1997628239" data-server="netease" data-type="playlist" data-mode="single"></div>
	</div>
</div>

        
            <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            标签云
        </h3>
        <a href="/tags/AJAX/" style="font-size: 10px;">AJAX</a> <a href="/tags/CMD%E5%91%BD%E4%BB%A4/" style="font-size: 10px;">CMD命令</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/IDEA%E6%95%99%E7%A8%8B/" style="font-size: 10px;">IDEA教程</a> <a href="/tags/IO-%E6%B5%81/" style="font-size: 10px;">IO 流</a> <a href="/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 16.67px;">Java基础</a> <a href="/tags/Java%E9%9B%86%E5%90%88/" style="font-size: 10px;">Java集合</a> <a href="/tags/Jenkins/" style="font-size: 10px;">Jenkins</a> <a href="/tags/Layui-%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">Layui 博客</a> <a href="/tags/LeetCode/" style="font-size: 10px;">LeetCode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">Oracle数据库</a> <a href="/tags/PL-SQL/" style="font-size: 10px;">PL/SQL</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SSM/" style="font-size: 10px;">SSM</a> <a href="/tags/Spring-Boot/" style="font-size: 13.33px;">Spring Boot</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/hello-world/" style="font-size: 10px;">hello world</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/icarus%E4%B8%BB%E9%A2%98/" style="font-size: 10px;">icarus主题</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/windows%E6%95%99%E7%A8%8B/" style="font-size: 10px;">windows教程</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">函数式编程</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" style="font-size: 10px;">博客搭建</a> <a href="/tags/%E5%8F%8D%E5%B0%84%E6%B3%A8%E8%A7%A3/" style="font-size: 10px;">反射注解</a> <a href="/tags/%E5%B8%B8%E7%94%A8-API/" style="font-size: 10px;">常用 API</a> <a href="/tags/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/" style="font-size: 10px;">常用算法</a> <a href="/tags/%E6%95%85%E4%BA%8B/" style="font-size: 10px;">故事</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">网络编程</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a>
    </div>
</div>
        
            <div class="card widget">
  <div class="card-content">
    <div class="menu">
      <h3 class="menu-label">
        订阅更新
      </h3>
      <div>
        <form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow"
          onsubmit="window.open('https://feedburner.google.com/fb/a/mailverify?uri=guoshizhanFeedsId', 'popupwindow', 'scrollbars=yes,width=550,height=520');return true">
          <input type="hidden" value="guoshizhanFeedsId" name="uri" />
          <input type="hidden" name="loc" value="en_US" />
          <div class="field">
            <div class="control has-icons-left">
              <input class="input" name="email" type="email" placeholder="请输入邮箱地址" />
              <span class="icon is-small is-left">
                <i class="fas fa-envelope"></i>
              </span>
            </div>
            <p class="help">立即订阅跳转人机认证后，点击完成按钮！</p>
          </div>
          <div class="field is-grouped is-grouped-right">
            <div class="control">
              <input class="button is-link is-rounded" type="submit" value="订阅">
            </div>
          </div>
        </form>
      </div>
    </div>
  </div>
</div>

        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/GSZ's-Blog.png" alt="Java 基础（下篇）" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 Java Developer&nbsp;
                Powered &#10084; ShiZhan·Guo
                </p>
            </div>    
            <script>
                (function(){
                    var bp = document.createElement('script');
                    var curProtocol = window.location.protocol.split(':')[0];
                    if (curProtocol === 'https') {
                        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                    }
                    else {
                        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                    }
                    var s = document.getElementsByTagName("script")[0];
                    s.parentNode.insertBefore(bp, s);
                })();
            </script>

            <div align="center" id="access-number">
                <br>
                <script type="text/javascript" src="/js/statistics.js"></script>
                <span id="statistic-times"></span>
                <br>
                <div align="center">
                    <span class="busuanzi_container_site_pv">总访问量 
                        <b><span id="busuanzi_value_site_pv"></span></b> 次
                    </span>
                    <span class="busuanzi_container_site_uv">您是第  
                        <b><span id="busuanzi_value_site_uv"></b>
                        </span> 位小伙伴
                    </span>
                    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
                </div>
            </div>
            
            
            <!--<div id="earth">
                <span>
                <script type="text/javascript" src="//rf.revolvermaps.com/0/0/2.js?i=0xetp0d4rdh&m=7&s=130&c=00fff6&t=1" async="async"></script>
                </span>
            </div>-->


            <!--这个一个空的 div ，目的是让卜算子统计居中-->
            <div id="empty"></div>


            <script>
                (function(){
                    var bp = document.createElement('script');
                    bp.src = '//push.zhanzhang.baidu.com/push.js';
                    var s = document.getElementsByTagName("script")[0];
                    s.parentNode.insertBefore(bp, s);
                })();
            </script>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'https://guoshizhan.github.io',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
    
    <!--配置看板娘-->
    <script type="text/javascript" async="" src="/live2d/autoload.js"></script>

    <!--音乐js文件-->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
    <script src="/js/APlayer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script>
</body>
</html>